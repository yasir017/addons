(function (exports, owl) {
    'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var owl__namespace = /*#__PURE__*/_interopNamespace(owl);

    /*
     * usage: every string should be translated either with _lt if they are registered with a registry at
     *  the load of the app or with Spreadsheet._t in the templates. Spreadsheet._t is exposed in the
     *  sub-env of Spreadsheet components as _t
     * */
    // define a mock translation function, when o-spreadsheet runs in standalone it doesn't translate any string
    let _translate = (s) => s;
    function sprintf(s, ...values) {
        if (values.length === 1 && typeof values[0] === "object") {
            const valuesDict = values[0];
            s = s.replace(/\%\(?([^\)]+)\)s/g, (match, value) => valuesDict[value]);
        }
        else if (values.length > 0) {
            s = s.replace(/\%s/g, () => values.shift());
        }
        return s;
    }
    /***
     * Allow to inject a translation function from outside o-spreadsheet.
     * @param tfn the function that will do the translation
     */
    function setTranslationMethod(tfn) {
        _translate = tfn;
    }
    const _t = function (s, ...values) {
        return sprintf(_translate(s), ...values);
    };
    const _lt = function (s, ...values) {
        return {
            toString: function () {
                return sprintf(_translate(s), ...values);
            },
            // casts the object to unknown then to string to trick typescript into thinking that the object it receives is actually a string
            // this way it will be typed correctly (behaves like a string) but tests like typeof _lt("whatever") will be object and not string !
        };
    };

    // Colors
    const BACKGROUND_GRAY_COLOR = "#f5f5f5";
    const BACKGROUND_HEADER_COLOR = "#F8F9FA";
    const BACKGROUND_HEADER_SELECTED_COLOR = "#E8EAED";
    const BACKGROUND_HEADER_ACTIVE_COLOR = "#595959";
    const TEXT_HEADER_COLOR = "#666666";
    const SELECTION_BORDER_COLOR = "#3266ca";
    const HEADER_BORDER_COLOR = "#C0C0C0";
    const CELL_BORDER_COLOR = "#E2E3E3";
    const BACKGROUND_CHART_COLOR = "#FFFFFF";
    const MENU_ITEM_DISABLED_COLOR = "#CACACA";
    // Dimensions
    const MIN_ROW_HEIGHT = 10;
    const MIN_COL_WIDTH = 5;
    const HEADER_HEIGHT = 26;
    const HEADER_WIDTH = 48;
    const TOPBAR_HEIGHT = 63;
    const BOTTOMBAR_HEIGHT = 36;
    const DEFAULT_CELL_WIDTH = 96;
    const DEFAULT_CELL_HEIGHT = 23;
    const SCROLLBAR_WIDTH$1 = 15;
    const PADDING_AUTORESIZE = 3;
    const AUTOFILL_EDGE_LENGTH = 8;
    const ICON_EDGE_LENGTH = 18;
    const UNHIDE_ICON_EDGE_LENGTH = 14;
    const MIN_CF_ICON_MARGIN = 4;
    const MIN_CELL_TEXT_MARGIN = 4;
    const CF_ICON_EDGE_LENGTH = 15;
    const LINK_TOOLTIP_HEIGHT = 43;
    const LINK_TOOLTIP_WIDTH = 220;
    // Menus
    const MENU_WIDTH = 200;
    const MENU_ITEM_HEIGHT = 24;
    const MENU_SEPARATOR_BORDER_WIDTH = 1;
    const MENU_SEPARATOR_PADDING = 5;
    const MENU_SEPARATOR_HEIGHT = MENU_SEPARATOR_BORDER_WIDTH + 2 * MENU_SEPARATOR_PADDING;
    const FIGURE_BORDER_SIZE = 1;
    // Fonts
    const DEFAULT_FONT_WEIGHT = "400";
    const DEFAULT_FONT_SIZE = 10;
    const HEADER_FONT_SIZE = 11;
    const DEFAULT_FONT = "'Roboto', arial";
    // Borders
    const DEFAULT_BORDER_DESC = ["thin", "#000"];
    const LINK_COLOR = "#00f";
    // DateTimeRegex
    const DATETIME_FORMAT = /[ymd:]/;
    // Ranges
    const INCORRECT_RANGE_STRING = "#REF";
    // Max Number of history steps kept in memory
    const MAX_HISTORY_STEPS = 99;
    // Id of the first revision
    const DEFAULT_REVISION_ID = "START_REVISION";
    // Chart
    const MAX_CHAR_LABEL = 20;
    const DEBOUNCE_TIME = 200;
    const MESSAGE_VERSION = 1;
    const LOADING = "Loading...";
    const DEFAULT_ERROR_MESSAGE = _lt("Invalid expression");
    const FORBIDDEN_IN_EXCEL_REGEX = /'|\*|\?|\/|\\|\[|\]/;
    // Cells
    const NULL_FORMAT = undefined;
    const FORMULA_REF_IDENTIFIER = "|";

    // -----------------------------------------------------------------------------
    // Date Type
    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    // Parsing
    // -----------------------------------------------------------------------------
    const CURRENT_MILLENIAL = 2000; // note: don't forget to update this in 2999
    const CURRENT_YEAR = new Date().getFullYear();
    const INITIAL_1900_DAY$1 = new Date(1899, 11, 30);
    const INITIAL_JS_DAY = new Date(0);
    const DATE_JS_1900_OFFSET = INITIAL_JS_DAY - INITIAL_1900_DAY$1;
    const mdyDateRegexp = /^\d{1,2}(\/|-|\s)\d{1,2}((\/|-|\s)\d{1,4})?$/;
    const ymdDateRegexp = /^\d{3,4}(\/|-|\s)\d{1,2}(\/|-|\s)\d{1,2}$/;
    const timeRegexp = /((\d+(:\d+)?(:\d+)?\s*(AM|PM))|(\d+:\d+(:\d+)?))$/;
    function parseDateTime(str) {
        str = str.trim();
        let time;
        const timeMatch = str.match(timeRegexp);
        if (timeMatch) {
            time = parseTime(timeMatch[0]);
            if (time === null) {
                return null;
            }
            str = str.replace(timeMatch[0], "").trim();
        }
        let date;
        const mdyDateMatch = str.match(mdyDateRegexp);
        const ymdDateMatch = str.match(ymdDateRegexp);
        if (mdyDateMatch || ymdDateMatch) {
            let dateMatch;
            if (mdyDateMatch) {
                dateMatch = mdyDateMatch[0];
                date = parseDate(dateMatch, "mdy");
            }
            else {
                dateMatch = ymdDateMatch[0];
                date = parseDate(dateMatch, "ymd");
            }
            if (date === null) {
                return null;
            }
            str = str.replace(dateMatch, "").trim();
        }
        if (str !== "" || !(date || time)) {
            return null;
        }
        if (date && time) {
            return {
                value: date.value + time.value,
                format: date.format + " " + (time.format === "hhhh:mm:ss" ? "hh:mm:ss" : time.format),
                jsDate: new Date(date.jsDate.getFullYear() + time.jsDate.getFullYear() - 1899, date.jsDate.getMonth() + time.jsDate.getMonth() - 11, date.jsDate.getDate() + time.jsDate.getDate() - 30, date.jsDate.getHours() + time.jsDate.getHours(), date.jsDate.getMinutes() + time.jsDate.getMinutes(), date.jsDate.getSeconds() + time.jsDate.getSeconds()),
            };
        }
        return date || time;
    }
    function parseDate(str, dateFormat) {
        const isMDY = dateFormat === "mdy";
        const isYMD = dateFormat === "ymd";
        if (isMDY || isYMD) {
            const parts = str.split(/\/|-|\s/);
            const monthIndex = isMDY ? 0 : 1;
            const dayIndex = isMDY ? 1 : 2;
            const yearIndex = isMDY ? 2 : 0;
            const month = Number(parts[monthIndex]);
            const day = Number(parts[dayIndex]);
            const leadingZero = (parts[monthIndex].length === 2 && month < 10) || (parts[dayIndex].length === 2 && day < 10);
            const year = parts[yearIndex] ? inferYear(parts[yearIndex]) : CURRENT_YEAR;
            const jsDate = new Date(year, month - 1, day);
            const sep = str.match(/\/|-|\s/)[0];
            if (jsDate.getMonth() !== month - 1 || jsDate.getDate() !== day) {
                // invalid date
                return null;
            }
            const delta = jsDate - INITIAL_1900_DAY$1;
            let format = leadingZero ? `mm${sep}dd` : `m${sep}d`;
            if (parts[yearIndex]) {
                format = isMDY ? format + sep + "yyyy" : "yyyy" + sep + format;
            }
            return {
                value: Math.round(delta / 86400000),
                format: format,
                jsDate,
            };
        }
        return null;
    }
    function inferYear(str) {
        const nbr = Number(str);
        switch (str.length) {
            case 1:
                return CURRENT_MILLENIAL + nbr;
            case 2:
                const offset = CURRENT_MILLENIAL + nbr > CURRENT_YEAR + 10 ? -100 : 0;
                const base = CURRENT_MILLENIAL + offset;
                return base + nbr;
            case 3:
            case 4:
                return nbr;
        }
        return 0;
    }
    function parseTime(str) {
        str = str.trim();
        if (timeRegexp.test(str)) {
            const isAM = /AM/i.test(str);
            const isPM = /PM/i.test(str);
            const strTime = isAM || isPM ? str.substring(0, str.length - 2).trim() : str;
            const parts = strTime.split(/:/);
            const isMinutes = parts.length >= 2;
            const isSeconds = parts.length === 3;
            let hours = Number(parts[0]);
            let minutes = isMinutes ? Number(parts[1]) : 0;
            let seconds = isSeconds ? Number(parts[2]) : 0;
            let format = isSeconds ? "hh:mm:ss" : "hh:mm";
            if (isAM || isPM) {
                format += " a";
            }
            else if (!isMinutes) {
                return null;
            }
            if (hours >= 12 && isAM) {
                hours -= 12;
            }
            else if (hours < 12 && isPM) {
                hours += 12;
            }
            minutes += Math.floor(seconds / 60);
            seconds %= 60;
            hours += Math.floor(minutes / 60);
            minutes %= 60;
            if (hours >= 24) {
                format = "hhhh:mm:ss";
            }
            const jsDate = new Date(1899, 11, 30, hours, minutes, seconds);
            return {
                value: hours / 24 + minutes / 1440 + seconds / 86400,
                format: format,
                jsDate: jsDate,
            };
        }
        return null;
    }
    // -----------------------------------------------------------------------------
    // Conversion
    // -----------------------------------------------------------------------------
    function numberToJsDate(value) {
        const truncValue = Math.trunc(value);
        let date = new Date(truncValue * 86400 * 1000 - DATE_JS_1900_OFFSET);
        let time = value - truncValue;
        time = time < 0 ? 1 + time : time;
        const hours = Math.round(time * 24);
        const minutes = Math.round((time - hours / 24) * 24 * 60);
        const seconds = Math.round((time - hours / 24 - minutes / 24 / 60) * 24 * 60 * 60);
        date.setHours(hours);
        date.setMinutes(minutes);
        date.setSeconds(seconds);
        return date;
    }
    // -----------------------------------------------------------------------------
    // Formatting
    // -----------------------------------------------------------------------------
    function formatDateTime(internalDate) {
        // TODO: unify the format functions for date and datetime
        // This requires some code to 'parse' or 'tokenize' the format, keep it in a
        // cache, and use it in a single mapping, that recognizes the special list
        // of tokens dd,d,m,y,h, ... and preserves the rest
        const dateTimeFormat = internalDate.format;
        const jsDate = internalDate.jsDate || numberToJsDate(internalDate.value);
        const indexH = dateTimeFormat.indexOf("h");
        let strDate = "";
        let strTime = "";
        if (indexH > 0) {
            strDate = formatJSDate(jsDate, dateTimeFormat.substring(0, indexH - 1));
            strTime = formatJSTime(jsDate, dateTimeFormat.substring(indexH));
        }
        else if (indexH === 0) {
            strTime = formatJSTime(jsDate, dateTimeFormat);
        }
        else if (indexH < 0) {
            strDate = formatJSDate(jsDate, dateTimeFormat);
        }
        return strDate + (strDate && strTime ? " " : "") + strTime;
    }
    function formatJSDate(jsDate, format) {
        const sep = format.match(/\/|-|\s/)[0];
        const parts = format.split(sep);
        return parts
            .map((p) => {
            switch (p) {
                case "d":
                    return jsDate.getDate();
                case "dd":
                    return jsDate.getDate().toString().padStart(2, "0");
                case "m":
                    return jsDate.getMonth() + 1;
                case "mm":
                    return String(jsDate.getMonth() + 1).padStart(2, "0");
                case "yyyy":
                    return jsDate.getFullYear();
                default:
                    throw new Error(`invalid format: ${format}`);
            }
        })
            .join(sep);
    }
    function formatJSTime(jsDate, format) {
        let parts = format.split(/:|\s/);
        const dateHours = jsDate.getHours();
        const isMeridian = parts[parts.length - 1] === "a";
        let hours = dateHours;
        let meridian = "";
        if (isMeridian) {
            hours = hours === 0 ? 12 : hours > 12 ? hours - 12 : hours;
            meridian = dateHours >= 12 ? " PM" : " AM";
            parts.pop();
        }
        return (parts
            .map((p) => {
            switch (p) {
                case "hhhh":
                    const helapsedHours = Math.floor((jsDate.getTime() - INITIAL_1900_DAY$1) / (60 * 60 * 1000));
                    return helapsedHours.toString();
                case "hh":
                    return hours.toString().padStart(2, "0");
                case "mm":
                    return jsDate.getMinutes().toString().padStart(2, "0");
                case "ss":
                    return jsDate.getSeconds().toString().padStart(2, "0");
                default:
                    throw new Error(`invalid format: ${format}`);
            }
        })
            .join(":") + meridian);
    }

    /**
     * This regexp is supposed to be as close as possible as the numberRegexp, but
     * its purpose is to be used by the tokenizer.
     *
     * - it tolerates extra characters at the end. This is useful because the tokenizer
     *   only needs to find the number at the start of a string
     * - it does not accept "," as thousand separator, because when we tokenize a
     *   formula, commas are used to separate arguments
     */
    const formulaNumberRegexp = /^-?\d+(\.?\d*(e\d+)?)?(\s*%)?|^-?\.\d+(\s*%)?/;
    const numberRegexp = /^-?\d+(,\d+)*(\.?\d*(e\d+)?)?(\s*%)?$|^-?\.\d+(\s*%)?$/;
    /**
     * Return true if the argument is a "number string".
     *
     * Note that "" (empty string) does not count as a number string
     */
    function isNumber(value) {
        // TO DO: add regexp for DATE string format (ex match: "28 02 2020")
        return numberRegexp.test(value.trim());
    }
    const commaRegexp = /,/g;
    /**
     * Convert a string into a number. It assumes that the string actually represents
     * a number (as determined by the isNumber function)
     *
     * Note that it accepts "" (empty string), even though it does not count as a
     * number from the point of view of the isNumber function.
     */
    function parseNumber(str) {
        let n = Number(str.replace(commaRegexp, ""));
        if (isNaN(n) && str.includes("%")) {
            n = Number(str.split("%")[0]);
            if (!isNaN(n)) {
                return n / 100;
            }
        }
        return n;
    }
    const decimalStandardRepresentation = new Intl.NumberFormat("en-US", {
        useGrouping: false,
        maximumFractionDigits: 10,
    });
    function formatStandardNumber(n) {
        if (Number.isInteger(n)) {
            return n.toString();
        }
        return decimalStandardRepresentation.format(n);
    }
    // this is a cache than can contains decimal representation formats
    // from 0 (minimum) to 20 (maximum) digits after the decimal point
    let decimalRepresentations = [];
    const maximumDecimalPlaces = 20;
    function formatDecimal(n, decimals, sep = "") {
        if (n < 0) {
            return "-" + formatDecimal(-n, decimals);
        }
        const maxDecimals = decimals >= maximumDecimalPlaces ? maximumDecimalPlaces : decimals;
        let formatter = decimalRepresentations[maxDecimals];
        if (!formatter) {
            formatter = new Intl.NumberFormat("en-US", {
                minimumFractionDigits: maxDecimals,
                maximumFractionDigits: maxDecimals,
                useGrouping: false,
            });
            decimalRepresentations[maxDecimals] = formatter;
        }
        let result = formatter.format(n);
        if (sep) {
            let p = result.indexOf(".");
            result = result.replace(/\d(?=(?:\d{3})+(?:\.|$))/g, (m, i) => p < 0 || i < p ? `${m}${sep}` : m);
        }
        return result;
    }
    function formatNumber(value, format) {
        const parts = format.split(";");
        const l = parts.length;
        if (value < 0) {
            if (l > 1) {
                return _formatValue(-value, parts[1]);
            }
            else {
                return "-" + _formatValue(-value, parts[0]);
            }
        }
        const index = l === 3 && value === 0 ? 2 : 0;
        return _formatValue(value, parts[index]);
    }
    function _formatValue(value, format) {
        const parts = format.split(".");
        const decimals = parts.length === 1 ? 0 : parts[1].match(/0/g).length;
        const separator = parts[0].includes(",") ? "," : "";
        const isPercent = format.includes("%");
        if (isPercent) {
            value = value * 100;
        }
        const rawNumber = formatDecimal(value, decimals, separator);
        if (isPercent) {
            return rawNumber + "%";
        }
        return rawNumber;
    }

    // HELPERS
    function assert(condition, message) {
        if (!condition()) {
            throw new Error(message);
        }
    }
    // -----------------------------------------------------------------------------
    // FORMAT FUNCTIONS
    // -----------------------------------------------------------------------------
    const expectNumberValueError = (value) => _lt("The function [[FUNCTION_NAME]] expects a number value, but '%s' is a string, and cannot be coerced to a number.", value);
    function toNumber(value) {
        switch (typeof value) {
            case "number":
                return value;
            case "boolean":
                return value ? 1 : 0;
            case "string":
                if (isNumber(value) || value === "") {
                    return parseNumber(value);
                }
                const internalDate = parseDateTime(value);
                if (internalDate) {
                    return internalDate.value;
                }
                throw new Error(expectNumberValueError(value));
            default:
                return 0;
        }
    }
    function strictToNumber(value) {
        if (value === "") {
            throw new Error(expectNumberValueError(value));
        }
        return toNumber(value);
    }
    function toString(value) {
        switch (typeof value) {
            case "string":
                return value;
            case "number":
                return value.toString();
            case "boolean":
                return value ? "TRUE" : "FALSE";
            default:
                return "";
        }
    }
    const expectBooleanValueError = (value) => _lt("The function [[FUNCTION_NAME]] expects a boolean value, but '%s' is a text, and cannot be coerced to a number.", value);
    function toBoolean(value) {
        switch (typeof value) {
            case "boolean":
                return value;
            case "string":
                if (value) {
                    let uppercaseVal = value.toUpperCase();
                    if (uppercaseVal === "TRUE") {
                        return true;
                    }
                    if (uppercaseVal === "FALSE") {
                        return false;
                    }
                    throw new Error(expectBooleanValueError(value));
                }
                else {
                    return false;
                }
            case "number":
                return value ? true : false;
            default:
                return false;
        }
    }
    function strictToBoolean(value) {
        if (value === "") {
            throw new Error(expectBooleanValueError(value));
        }
        return toBoolean(value);
    }
    function toJsDate(value) {
        return numberToJsDate(toNumber(value));
    }
    // -----------------------------------------------------------------------------
    // VISIT FUNCTIONS
    // -----------------------------------------------------------------------------
    function visitArgs(args, cellCb, dataCb) {
        for (let arg of args) {
            if (Array.isArray(arg)) {
                // arg is ref to a Cell/Range
                const lenRow = arg.length;
                const lenCol = arg[0].length;
                for (let y = 0; y < lenCol; y++) {
                    for (let x = 0; x < lenRow; x++) {
                        cellCb(arg[x][y]);
                    }
                }
            }
            else {
                // arg is set directly in the formula function
                dataCb(arg);
            }
        }
    }
    function visitAny(args, cb) {
        visitArgs(args, cb, cb);
    }
    function visitNumbers(args, cb) {
        visitArgs(args, (cellValue) => {
            if (typeof cellValue === "number") {
                cb(cellValue);
            }
        }, (argValue) => {
            cb(strictToNumber(argValue));
        });
    }
    // -----------------------------------------------------------------------------
    // REDUCE FUNCTIONS
    // -----------------------------------------------------------------------------
    function reduceArgs(args, cellCb, dataCb, initialValue) {
        let val = initialValue;
        for (let arg of args) {
            if (Array.isArray(arg)) {
                // arg is ref to a Cell/Range
                const lenRow = arg.length;
                const lenCol = arg[0].length;
                for (let y = 0; y < lenCol; y++) {
                    for (let x = 0; x < lenRow; x++) {
                        val = cellCb(val, arg[x][y]);
                    }
                }
            }
            else {
                // arg is set directly in the formula function
                val = dataCb(val, arg);
            }
        }
        return val;
    }
    function reduceAny(args, cb, initialValue) {
        return reduceArgs(args, cb, cb, initialValue);
    }
    function reduceNumbers(args, cb, initialValue) {
        return reduceArgs(args, (acc, ArgValue) => {
            if (typeof ArgValue === "number") {
                return cb(acc, ArgValue);
            }
            return acc;
        }, (acc, argValue) => {
            return cb(acc, strictToNumber(argValue));
        }, initialValue);
    }
    function reduceNumbersTextAs0(args, cb, initialValue) {
        return reduceArgs(args, (acc, ArgValue) => {
            if (ArgValue !== undefined && ArgValue !== null) {
                if (typeof ArgValue === "number") {
                    return cb(acc, ArgValue);
                }
                else if (typeof ArgValue === "boolean") {
                    return cb(acc, toNumber(ArgValue));
                }
                else {
                    return cb(acc, 0);
                }
            }
            return acc;
        }, (acc, argValue) => {
            return cb(acc, toNumber(argValue));
        }, initialValue);
    }
    // -----------------------------------------------------------------------------
    // CONDITIONAL EXPLORE FUNCTIONS
    // -----------------------------------------------------------------------------
    /**
     * This function allows to visit arguments and stop the visit if necessary.
     * It is mainly used to bypass argument evaluation for functions like OR or AND.
     */
    function conditionalVisitArgs(args, cellCb, dataCb) {
        for (let arg of args) {
            if (Array.isArray(arg)) {
                // arg is ref to a Cell/Range
                const lenRow = arg.length;
                const lenCol = arg[0].length;
                for (let y = 0; y < lenCol; y++) {
                    for (let x = 0; x < lenRow; x++) {
                        if (!cellCb(arg[x][y]))
                            return;
                    }
                }
            }
            else {
                // arg is set directly in the formula function
                if (!dataCb(arg))
                    return;
            }
        }
    }
    function conditionalVisitBoolean(args, cb) {
        return conditionalVisitArgs(args, (ArgValue) => {
            if (typeof ArgValue === "boolean") {
                return cb(ArgValue);
            }
            if (typeof ArgValue === "number") {
                return cb(ArgValue ? true : false);
            }
            return true;
        }, (argValue) => {
            if (argValue !== undefined && argValue !== null) {
                return cb(strictToBoolean(argValue));
            }
            return true;
        });
    }
    function getPredicate(descr, isQuery) {
        let operator;
        let operand;
        let subString = descr.substring(0, 2);
        if (subString === "<=" || subString === ">=" || subString === "<>") {
            operator = subString;
            operand = descr.substring(2);
        }
        else {
            subString = descr.substring(0, 1);
            if (subString === "<" || subString === ">" || subString === "=") {
                operator = subString;
                operand = descr.substring(1);
            }
            else {
                operator = "=";
                operand = descr;
            }
        }
        if (isNumber(operand)) {
            operand = toNumber(operand);
        }
        else if (operand === "TRUE" || operand === "FALSE") {
            operand = toBoolean(operand);
        }
        const result = { operator, operand };
        if (typeof operand === "string") {
            if (isQuery) {
                operand += "*";
            }
            result.regexp = operandToRegExp(operand);
        }
        return result;
    }
    function operandToRegExp(operand) {
        let exp = "";
        let predecessor = "";
        for (let char of operand) {
            if (char === "?" && predecessor !== "~") {
                exp += ".";
            }
            else if (char === "*" && predecessor !== "~") {
                exp += ".*";
            }
            else {
                if (char === "*" || char === "?") {
                    //remove "~"
                    exp = exp.slice(0, -1);
                }
                if (["^", ".", "[", "]", "$", "(", ")", "*", "+", "?", "|", "{", "}", "\\"].includes(char)) {
                    exp += "\\";
                }
                exp += char;
            }
            predecessor = char;
        }
        return new RegExp("^" + exp + "$", "i");
    }
    function evaluatePredicate(value, criterion) {
        const { operator, operand } = criterion;
        if (value === undefined || operand === undefined) {
            return false;
        }
        if (typeof operand === "number" && operator === "=") {
            return toString(value) === toString(operand);
        }
        if (operator === "<>" || operator === "=") {
            let result;
            if (typeof value === typeof operand) {
                if (typeof value === "string" && criterion.regexp) {
                    result = criterion.regexp.test(value);
                }
                else {
                    result = value === operand;
                }
            }
            else {
                result = false;
            }
            return operator === "=" ? result : !result;
        }
        if (typeof value === typeof operand) {
            switch (operator) {
                case "<":
                    return value < operand;
                case ">":
                    return value > operand;
                case "<=":
                    return value <= operand;
                case ">=":
                    return value >= operand;
            }
        }
        return false;
    }
    /**
     * Functions used especially for predicate evaluation on ranges.
     *
     * Take ranges with same dimensions and take predicates, one for each range.
     * For (i, j) coordinates, if all elements with coordinates (i, j) of each
     * range correspond to the associated predicate, then the function uses a callback
     * function with the parameters "i" and "j".
     *
     * Syntax:
     * visitMatchingRanges([range1, predicate1, range2, predicate2, ...], cb(i,j), likeSelection)
     *
     * - range1 (range): The range to check against predicate1.
     * - predicate1 (string): The pattern or test to apply to range1.
     * - range2: (range, repeatable) ranges to check.
     * - predicate2 (string, repeatable): Additional pattern or test to apply to range2.
     *
     * - cb(i: number, j: number) => void: the callback function.
     *
     * - isQuery (boolean) indicates if the comparison with a string should be done as a SQL-like query.
     * (Ex1 isQuery = true, predicate = "abc", element = "abcde": predicate match the element),
     * (Ex2 isQuery = false, predicate = "abc", element = "abcde": predicate not match the element).
     * (Ex3 isQuery = true, predicate = "abc", element = "abc": predicate match the element),
     * (Ex4 isQuery = false, predicate = "abc", element = "abc": predicate match the element).
     */
    function visitMatchingRanges(args, cb, isQuery = false) {
        const countArg = args.length;
        if (countArg % 2 === 1) {
            throw new Error(_lt(`Function [[FUNCTION_NAME]] expects criteria_range and criterion to be in pairs.`));
        }
        const dimRow = args[0].length;
        const dimCol = args[0][0].length;
        let predicates = [];
        for (let i = 0; i < countArg - 1; i += 2) {
            const criteriaRange = args[i];
            if (!Array.isArray(criteriaRange) ||
                criteriaRange.length !== dimRow ||
                criteriaRange[0].length !== dimCol) {
                throw new Error(_lt(`Function [[FUNCTION_NAME]] expects criteria_range to have the same dimension`));
            }
            const description = toString(args[i + 1]);
            predicates.push(getPredicate(description, isQuery));
        }
        for (let i = 0; i < dimRow; i++) {
            for (let j = 0; j < dimCol; j++) {
                let validatedPredicates = true;
                for (let k = 0; k < countArg - 1; k += 2) {
                    const criteriaValue = args[k][i][j];
                    const criterion = predicates[k / 2];
                    validatedPredicates = evaluatePredicate(criteriaValue, criterion);
                    if (!validatedPredicates) {
                        break;
                    }
                }
                if (validatedPredicates) {
                    cb(i, j);
                }
            }
        }
    }
    // -----------------------------------------------------------------------------
    // COMMON FUNCTIONS
    // -----------------------------------------------------------------------------
    /**
     * Perform a dichotomic search and return the index of the nearest match less than
     * or equal to the target. If all values in the range are greater than the target,
     * -1 is returned.
     * If the range is not in sorted order, an incorrect value might be returned.
     *
     * Example:
     * - [3, 6, 10], 3 => 0
     * - [3, 6, 10], 6 => 1
     * - [3, 6, 10], 9 => 1
     * - [3, 6, 10], 42 => 2
     * - [3, 6, 10], 2 => -1
     * - [3, undefined, 6, undefined, 10], 9 => 2
     * - [3, 6, undefined, undefined, undefined, 10], 2 => -1
     */
    function dichotomicPredecessorSearch(range, target) {
        if (target === undefined) {
            return -1;
        }
        const targetType = typeof target;
        let valMin = undefined;
        let valMinIndex = undefined;
        let indexLeft = 0;
        let indexRight = range.length - 1;
        if (typeof range[indexLeft] === targetType && target < range[indexLeft]) {
            return -1;
        }
        if (typeof range[indexRight] === targetType && range[indexRight] <= target) {
            return indexRight;
        }
        let indexMedian;
        let currentIndex;
        let currentVal;
        let currentType;
        while (indexRight - indexLeft >= 0) {
            indexMedian = Math.ceil((indexLeft + indexRight) / 2);
            currentIndex = indexMedian;
            currentVal = range[currentIndex];
            currentType = typeof currentVal;
            // 1 - linear search to find value with the same type
            while (indexLeft <= currentIndex && targetType !== currentType) {
                currentIndex--;
                currentVal = range[currentIndex];
                currentType = typeof currentVal;
            }
            // 2 - check if value match
            if (currentType === targetType && currentVal <= target) {
                if (valMin === undefined ||
                    valMin < currentVal ||
                    (valMin === currentVal && valMinIndex < currentIndex)) {
                    valMin = currentVal;
                    valMinIndex = currentIndex;
                }
            }
            // 3 - give new indexs for the Binary search
            if (currentType === targetType && currentVal > target) {
                indexRight = currentIndex - 1;
            }
            else {
                indexLeft = indexMedian + 1;
            }
        }
        // note that valMinIndex could be 0
        return valMinIndex !== undefined ? valMinIndex : -1;
    }
    /**
     * Perform a dichotomic search and return the index of the nearest match more than
     * or equal to the target. If all values in the range are smaller than the target,
     * -1 is returned.
     * If the range is not in sorted order, an incorrect value might be returned.
     *
     * Example:
     * - [10, 6, 3], 3 => 2
     * - [10, 6, 3], 6 => 1
     * - [10, 6, 3], 9 => 0
     * - [10, 6, 3], 42 => -1
     * - [10, 6, 3], 2 => 2
     * - [10, undefined, 6, undefined, 3], 9 => 0
     * - [10, 6, undefined, undefined, undefined, 3], 2 => 5
     */
    function dichotomicSuccessorSearch(range, target) {
        const targetType = typeof target;
        let valMax;
        let valMaxIndex = undefined;
        let indexLeft = 0;
        let indexRight = range.length - 1;
        if (typeof range[indexLeft] === targetType && target > range[indexLeft]) {
            return -1;
        }
        if (typeof range[indexRight] === targetType && range[indexRight] > target) {
            return indexRight;
        }
        let indexMedian;
        let currentIndex;
        let currentVal;
        let currentType;
        while (indexRight - indexLeft >= 0) {
            indexMedian = Math.ceil((indexLeft + indexRight) / 2);
            currentIndex = indexMedian;
            currentVal = range[currentIndex];
            currentType = typeof currentVal;
            // 1 - linear search to find value with the same type
            while (indexLeft <= currentIndex && targetType !== currentType) {
                currentIndex--;
                currentVal = range[currentIndex];
                currentType = typeof currentVal;
            }
            // 2 - check if value match
            if (currentType === targetType && currentVal >= target) {
                if (valMax === undefined ||
                    valMax > currentVal ||
                    (valMax === currentVal && valMaxIndex > currentIndex)) {
                    valMax = currentVal;
                    valMaxIndex = currentIndex;
                }
            }
            // 3 - give new indexs for the Binary search
            if (currentType === targetType && currentVal <= target) {
                indexRight = currentIndex - 1;
            }
            else {
                indexLeft = indexMedian + 1;
            }
        }
        // note that valMaxIndex could be 0
        return valMaxIndex !== undefined ? valMaxIndex : -1;
    }

    /**
     * Registry
     *
     * The Registry class is basically just a mapping from a string key to an object.
     * It is really not much more than an object. It is however useful for the
     * following reasons:
     *
     * 1. it let us react and execute code when someone add something to the registry
     *   (for example, the FunctionRegistry subclass this for this purpose)
     * 2. it throws an error when the get operation fails
     * 3. it provides a chained API to add items to the registry.
     */
    class Registry {
        constructor() {
            this.content = {};
        }
        /**
         * Add an item to the registry
         *
         * Note that this also returns the registry, so another add method call can
         * be chained
         */
        add(key, value) {
            this.content[key] = value;
            return this;
        }
        /**
         * Get an item from the registry
         */
        get(key) {
            /**
             * Note: key in {} is ~12 times slower than {}[key].
             * So, we check the absence of key only when the direct access returns
             * a falsy value. It's done to ensure that the registry can contains falsy values
             */
            const content = this.content[key];
            if (!content) {
                if (!(key in this.content)) {
                    throw new Error(`Cannot find ${key} in this registry!`);
                }
            }
            return content;
        }
        /**
         * Get a list of all elements in the registry
         */
        getAll() {
            return Object.values(this.content);
        }
        /**
         * Remove an item from the registry
         */
        remove(key) {
            delete this.content[key];
        }
    }

    //------------------------------------------------------------------------------
    // Arg description DSL
    //------------------------------------------------------------------------------
    const ARG_REGEXP = /(.*?)\((.*?)\)(.*)/;
    const ARG_TYPES = [
        "ANY",
        "BOOLEAN",
        "DATE",
        "NUMBER",
        "STRING",
        "RANGE",
        "RANGE<BOOLEAN>",
        "RANGE<DATE>",
        "RANGE<NUMBER>",
        "RANGE<STRING>",
        "META",
    ];
    /**
     * This function is meant to be used as a tag for a template strings.
     *
     * Its job is to convert a textual description of the list of arguments into an
     * actual array of Arg, suitable for consumption.
     */
    function args(strings) {
        let lines = strings.split("\n");
        const result = [];
        for (let l of lines) {
            l = l.trim();
            if (l) {
                result.push(makeArg(l));
            }
        }
        return result;
    }
    function makeArg(str) {
        let parts = str.match(ARG_REGEXP);
        let name = parts[1].trim();
        let types = [];
        let isOptional = false;
        let isRepeating = false;
        let isLazy = false;
        let defaultValue;
        for (let param of parts[2].split(",")) {
            const key = param.trim().toUpperCase();
            let type = ARG_TYPES.find((t) => key === t);
            if (type) {
                types.push(type);
            }
            else if (key === "RANGE<ANY>") {
                types.push("RANGE");
            }
            else if (key === "OPTIONAL") {
                isOptional = true;
            }
            else if (key === "REPEATING") {
                isRepeating = true;
            }
            else if (key === "LAZY") {
                isLazy = true;
            }
            else if (key.startsWith("DEFAULT=")) {
                defaultValue = param.trim().slice(8);
            }
        }
        let description = parts[3].trim();
        const result = {
            name,
            description,
            type: types,
        };
        if (isOptional) {
            result.optional = true;
        }
        if (isRepeating) {
            result.repeating = true;
        }
        if (isLazy) {
            result.lazy = true;
        }
        if (defaultValue !== undefined) {
            result.default = true;
            result.defaultValue = defaultValue;
        }
        return result;
    }
    /**
     * This function adds on description more general information derived from the
     * arguments.
     *
     * This information is useful during compilation.
     */
    function addMetaInfoFromArg(addDescr) {
        let countArg = 0;
        let minArg = 0;
        let repeatingArg = 0;
        for (let arg of addDescr.args) {
            countArg++;
            if (!arg.optional && !arg.repeating && !arg.default) {
                minArg++;
            }
            if (arg.repeating) {
                repeatingArg++;
            }
        }
        const descr = addDescr;
        descr.minArgRequired = minArg;
        descr.maxArgPossible = repeatingArg ? Infinity : countArg;
        descr.nbrArgRepeating = repeatingArg;
        descr.getArgToFocus = argTargeting(countArg, repeatingArg);
        return descr;
    }
    /**
     * Returns a function allowing finding which argument corresponds a position
     * in a function. This is particularly useful for functions with repeatable
     * arguments.
     *
     * Indeed the function makes it possible to etablish corespondance between
     * arguments when the number of arguments supplied is greater than the number of
     * arguments defined by the function.
     *
     * Ex:
     *
     * in the formula "=SUM(11, 55, 66)" which is defined like this "SUM(value1, [value2, ...])"
     * - 11 corresponds to the value1 argument => position will be 1
     * - 55 corresponds to the [value2, ...] argument => position will be 2
     * - 66 corresponds to the [value2, ...] argument => position will be 2
     *
     * in the formula "=AVERAGE.WEIGHTED(1, 2, 3, 4, 5, 6)" which is defined like this
     * "AVERAGE.WEIGHTED(values, weights, [additional_values, ...], [additional_weights, ...])"
     * - 1 corresponds to the values argument => position will be 1
     * - 2 corresponds to the weights argument => position will be 2
     * - 3 corresponds to the [additional_values, ...] argument => position will be 3
     * - 4 corresponds to the [additional_weights, ...] argument => position will be 4
     * - 5 corresponds to the [additional_values, ...] argument => position will be 3
     * - 6 corresponds to the [additional_weights, ...] argument => position will be 4
     */
    function argTargeting(countArg, repeatingArg) {
        if (!repeatingArg) {
            return (argPosition) => argPosition;
        }
        if (repeatingArg === 1) {
            return (argPosition) => Math.min(argPosition, countArg);
        }
        const argBeforeRepeat = countArg - repeatingArg;
        return (argPosition) => {
            if (argPosition <= argBeforeRepeat) {
                return argPosition;
            }
            const argAfterRepeat = (argPosition - argBeforeRepeat) % repeatingArg || repeatingArg;
            return argBeforeRepeat + argAfterRepeat;
        };
    }
    //------------------------------------------------------------------------------
    // Argument validation
    //------------------------------------------------------------------------------
    function validateArguments(args) {
        let previousArgRepeating = false;
        let previousArgOptional = false;
        let previousArgDefault = false;
        for (let current of args) {
            if (current.type.includes("META") && current.type.length > 1) {
                throw new Error(_lt("Function ${name} has an argument that has been declared with more than one type whose type 'META'. The 'META' type can only be declared alone."));
            }
            if (previousArgRepeating && !current.repeating) {
                throw new Error(_lt("Function ${name} has no-repeatable arguments declared after repeatable ones. All repeatable arguments must be declared last."));
            }
            const previousIsOptional = previousArgOptional || previousArgRepeating || previousArgDefault;
            const currentIsntOptional = !(current.optional || current.repeating || current.default);
            if (previousIsOptional && currentIsntOptional) {
                throw new Error(_lt("Function ${name} has at mandatory arguments declared after optional ones. All optional arguments must be after all mandatory arguments."));
            }
            previousArgRepeating = current.repeating;
            previousArgOptional = current.optional;
            previousArgDefault = current.default;
        }
    }

    var CellValueType;
    (function (CellValueType) {
        CellValueType["boolean"] = "boolean";
        CellValueType["number"] = "number";
        CellValueType["text"] = "text";
        CellValueType["empty"] = "empty";
        CellValueType["error"] = "error";
    })(CellValueType || (CellValueType = {}));

    function isSheetDependent(cmd) {
        return "sheetId" in cmd;
    }
    function isGridDependent(cmd) {
        return "dimension" in cmd;
    }
    function isTargetDependent(cmd) {
        return "target" in cmd;
    }
    function isPositionDependent(cmd) {
        return "col" in cmd && "row" in cmd;
    }
    const invalidateEvaluationCommands = new Set([
        "RENAME_SHEET",
        "DELETE_SHEET",
        "CREATE_SHEET",
        "ADD_COLUMNS_ROWS",
        "REMOVE_COLUMNS_ROWS",
        "DELETE_CELL",
        "INSERT_CELL",
        "UNDO",
        "REDO",
    ]);
    const readonlyAllowedCommands = new Set([
        "START",
        "ACTIVATE_SHEET",
        "COPY",
        "START_SELECTION",
        "SET_SELECTION",
        "ALTER_SELECTION",
        "START_SELECTION_EXPANSION",
        "PREPARE_SELECTION_EXPANSION",
        "STOP_SELECTION",
        "RESIZE_VIEWPORT",
        "SET_VIEWPORT_OFFSET",
        "SELECT_ALL",
        "SELECT_CELL",
        "SELECT_COLUMN",
        "SELECT_ROW",
        "MOVE_POSITION",
        "SELECT_SEARCH_NEXT_MATCH",
        "SELECT_SEARCH_PREVIOUS_MATCH",
        "REFRESH_SEARCH",
        "UPDATE_SEARCH",
        "CLEAR_SEARCH",
        "EVALUATE_CELLS",
        "SET_CURRENT_CONTENT",
        "SET_FORMULA_VISIBILITY",
    ]);
    const coreTypes = new Set([
        /** CELLS */
        "UPDATE_CELL",
        "UPDATE_CELL_POSITION",
        "CLEAR_CELL",
        "DELETE_CONTENT",
        /** GRID SHAPE */
        "ADD_COLUMNS_ROWS",
        "REMOVE_COLUMNS_ROWS",
        "RESIZE_COLUMNS_ROWS",
        "HIDE_COLUMNS_ROWS",
        "UNHIDE_COLUMNS_ROWS",
        "SET_GRID_LINES_VISIBILITY",
        /** MERGE */
        "ADD_MERGE",
        "REMOVE_MERGE",
        /** SHEETS MANIPULATION */
        "CREATE_SHEET",
        "DELETE_SHEET",
        "DUPLICATE_SHEET",
        "MOVE_SHEET",
        "RENAME_SHEET",
        /** CONDITIONAL FORMAT */
        "ADD_CONDITIONAL_FORMAT",
        "REMOVE_CONDITIONAL_FORMAT",
        /** FIGURES */
        "CREATE_FIGURE",
        "DELETE_FIGURE",
        "UPDATE_FIGURE",
        /** FORMATTING */
        "SET_FORMATTING",
        "CLEAR_FORMATTING",
        "SET_BORDER",
        "SET_DECIMAL",
        /** CHART */
        "CREATE_CHART",
        "UPDATE_CHART",
    ]);
    function isCoreCommand(cmd) {
        return coreTypes.has(cmd.type);
    }
    function canExecuteInReadonly(cmd) {
        return readonlyAllowedCommands.has(cmd.type);
    }
    /**
     * Holds the result of a command dispatch.
     * The command may have been successfully dispatched or cancelled
     * for one or more reasons.
     */
    class DispatchResult {
        constructor(results = []) {
            if (!Array.isArray(results)) {
                results = [results];
            }
            results = [...new Set(results)];
            this.reasons = results.filter((result) => result !== 0 /* Success */);
        }
        /**
         * Static helper which returns a successful DispatchResult
         */
        static get Success() {
            return new DispatchResult();
        }
        get isSuccessful() {
            return this.reasons.length === 0;
        }
        /**
         * Check if the dispatch has been cancelled because of
         * the given reason.
         */
        isCancelledBecause(reason) {
            return this.reasons.includes(reason);
        }
    }
    exports.CommandResult = void 0;
    (function (CommandResult) {
        CommandResult[CommandResult["Success"] = 0] = "Success";
        CommandResult[CommandResult["CancelledForUnknownReason"] = 1] = "CancelledForUnknownReason";
        CommandResult[CommandResult["WillRemoveExistingMerge"] = 2] = "WillRemoveExistingMerge";
        CommandResult[CommandResult["MergeIsDestructive"] = 3] = "MergeIsDestructive";
        CommandResult[CommandResult["CellIsMerged"] = 4] = "CellIsMerged";
        CommandResult[CommandResult["EmptyUndoStack"] = 5] = "EmptyUndoStack";
        CommandResult[CommandResult["EmptyRedoStack"] = 6] = "EmptyRedoStack";
        CommandResult[CommandResult["NotEnoughElements"] = 7] = "NotEnoughElements";
        CommandResult[CommandResult["NotEnoughSheets"] = 8] = "NotEnoughSheets";
        CommandResult[CommandResult["MissingSheetName"] = 9] = "MissingSheetName";
        CommandResult[CommandResult["DuplicatedSheetName"] = 10] = "DuplicatedSheetName";
        CommandResult[CommandResult["ForbiddenCharactersInSheetName"] = 11] = "ForbiddenCharactersInSheetName";
        CommandResult[CommandResult["WrongSheetMove"] = 12] = "WrongSheetMove";
        CommandResult[CommandResult["WrongSheetPosition"] = 13] = "WrongSheetPosition";
        CommandResult[CommandResult["InvalidAnchorZone"] = 14] = "InvalidAnchorZone";
        CommandResult[CommandResult["SelectionOutOfBound"] = 15] = "SelectionOutOfBound";
        CommandResult[CommandResult["TargetOutOfSheet"] = 16] = "TargetOutOfSheet";
        CommandResult[CommandResult["WrongPasteSelection"] = 17] = "WrongPasteSelection";
        CommandResult[CommandResult["EmptyClipboard"] = 18] = "EmptyClipboard";
        CommandResult[CommandResult["EmptyRange"] = 19] = "EmptyRange";
        CommandResult[CommandResult["InvalidRange"] = 20] = "InvalidRange";
        CommandResult[CommandResult["InvalidSheetId"] = 21] = "InvalidSheetId";
        CommandResult[CommandResult["InputAlreadyFocused"] = 22] = "InputAlreadyFocused";
        CommandResult[CommandResult["MaximumRangesReached"] = 23] = "MaximumRangesReached";
        CommandResult[CommandResult["InvalidChartDefinition"] = 24] = "InvalidChartDefinition";
        CommandResult[CommandResult["EmptyDataSet"] = 25] = "EmptyDataSet";
        CommandResult[CommandResult["InvalidDataSet"] = 26] = "InvalidDataSet";
        CommandResult[CommandResult["InvalidLabelRange"] = 27] = "InvalidLabelRange";
        CommandResult[CommandResult["InvalidAutofillSelection"] = 28] = "InvalidAutofillSelection";
        CommandResult[CommandResult["WrongComposerSelection"] = 29] = "WrongComposerSelection";
        CommandResult[CommandResult["MinBiggerThanMax"] = 30] = "MinBiggerThanMax";
        CommandResult[CommandResult["LowerBiggerThanUpper"] = 31] = "LowerBiggerThanUpper";
        CommandResult[CommandResult["MidBiggerThanMax"] = 32] = "MidBiggerThanMax";
        CommandResult[CommandResult["MinBiggerThanMid"] = 33] = "MinBiggerThanMid";
        CommandResult[CommandResult["FirstArgMissing"] = 34] = "FirstArgMissing";
        CommandResult[CommandResult["SecondArgMissing"] = 35] = "SecondArgMissing";
        CommandResult[CommandResult["MinNaN"] = 36] = "MinNaN";
        CommandResult[CommandResult["MidNaN"] = 37] = "MidNaN";
        CommandResult[CommandResult["MaxNaN"] = 38] = "MaxNaN";
        CommandResult[CommandResult["ValueUpperInflectionNaN"] = 39] = "ValueUpperInflectionNaN";
        CommandResult[CommandResult["ValueLowerInflectionNaN"] = 40] = "ValueLowerInflectionNaN";
        CommandResult[CommandResult["MinInvalidFormula"] = 41] = "MinInvalidFormula";
        CommandResult[CommandResult["MidInvalidFormula"] = 42] = "MidInvalidFormula";
        CommandResult[CommandResult["MaxInvalidFormula"] = 43] = "MaxInvalidFormula";
        CommandResult[CommandResult["ValueUpperInvalidFormula"] = 44] = "ValueUpperInvalidFormula";
        CommandResult[CommandResult["ValueLowerInvalidFormula"] = 45] = "ValueLowerInvalidFormula";
        CommandResult[CommandResult["InvalidSortZone"] = 46] = "InvalidSortZone";
        CommandResult[CommandResult["WaitingSessionConfirmation"] = 47] = "WaitingSessionConfirmation";
        CommandResult[CommandResult["MergeOverlap"] = 48] = "MergeOverlap";
        CommandResult[CommandResult["TooManyHiddenElements"] = 49] = "TooManyHiddenElements";
        CommandResult[CommandResult["Readonly"] = 50] = "Readonly";
        CommandResult[CommandResult["InvalidOffset"] = 51] = "InvalidOffset";
        CommandResult[CommandResult["InvalidViewportSize"] = 52] = "InvalidViewportSize";
        CommandResult[CommandResult["FigureDoesNotExist"] = 53] = "FigureDoesNotExist";
    })(exports.CommandResult || (exports.CommandResult = {}));

    var ReturnFormatType;
    (function (ReturnFormatType) {
        ReturnFormatType["FormatFromArgument"] = "FormatFromArgument";
    })(ReturnFormatType || (ReturnFormatType = {}));

    var DIRECTION;
    (function (DIRECTION) {
        DIRECTION[DIRECTION["UP"] = 0] = "UP";
        DIRECTION[DIRECTION["DOWN"] = 1] = "DOWN";
        DIRECTION[DIRECTION["LEFT"] = 2] = "LEFT";
        DIRECTION[DIRECTION["RIGHT"] = 3] = "RIGHT";
    })(DIRECTION || (DIRECTION = {}));

    var LAYERS;
    (function (LAYERS) {
        LAYERS[LAYERS["Background"] = 0] = "Background";
        LAYERS[LAYERS["Highlights"] = 1] = "Highlights";
        LAYERS[LAYERS["Clipboard"] = 2] = "Clipboard";
        LAYERS[LAYERS["Search"] = 3] = "Search";
        LAYERS[LAYERS["Chart"] = 4] = "Chart";
        LAYERS[LAYERS["Selection"] = 5] = "Selection";
        LAYERS[LAYERS["Autofill"] = 6] = "Autofill";
        LAYERS[LAYERS["Headers"] = 7] = "Headers";
    })(LAYERS || (LAYERS = {}));

    const DEFAULT_FACTOR = 1;
    const DEFAULT_MODE = 0;
    const DEFAULT_PLACES = 0;
    const DEFAULT_SIGNIFICANCE = 1;
    // -----------------------------------------------------------------------------
    // ABS
    // -----------------------------------------------------------------------------
    const ABS = {
        description: _lt("Absolute value of a number."),
        args: args(`
    value (number) ${_lt("The number of which to return the absolute value.")}
  `),
        returns: ["NUMBER"],
        compute: function (value) {
            return Math.abs(toNumber(value));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ACOS
    // -----------------------------------------------------------------------------
    const ACOS = {
        description: _lt("Inverse cosine of a value, in radians."),
        args: args(`
    value (number) ${_lt("The value for which to calculate the inverse cosine. Must be between -1 and 1, inclusive.")}
  `),
        returns: ["NUMBER"],
        compute: function (value) {
            const _value = toNumber(value);
            assert(() => Math.abs(_value) <= 1, _lt("The value (%s) must be between -1 and 1 inclusive.", _value.toString()));
            return Math.acos(_value);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ACOSH
    // -----------------------------------------------------------------------------
    const ACOSH = {
        description: _lt("Inverse hyperbolic cosine of a number."),
        args: args(`
    value (number) ${_lt("The value for which to calculate the inverse hyperbolic cosine. Must be greater than or equal to 1.")}
  `),
        returns: ["NUMBER"],
        compute: function (value) {
            const _value = toNumber(value);
            assert(() => _value >= 1, _lt("The value (%s) must be greater than or equal to 1.", _value.toString()));
            return Math.acosh(_value);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ACOT
    // -----------------------------------------------------------------------------
    const ACOT = {
        description: _lt("Inverse cotangent of a value."),
        args: args(`
    value (number) ${_lt("The value for which to calculate the inverse cotangent.")}
  `),
        returns: ["NUMBER"],
        compute: function (value) {
            const _value = toNumber(value);
            const sign = Math.sign(_value) || 1;
            // ACOT has two possible configurations:
            // @compatibility Excel: return Math.PI / 2 - Math.atan(toNumber(_value));
            // @compatibility Google: return sign * Math.PI / 2 - Math.atan(toNumber(_value));
            return (sign * Math.PI) / 2 - Math.atan(_value);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ACOTH
    // -----------------------------------------------------------------------------
    const ACOTH = {
        description: _lt("Inverse hyperbolic cotangent of a value."),
        args: args(`
    value (number) ${_lt("The value for which to calculate the inverse hyperbolic cotangent. Must not be between -1 and 1, inclusive.")}
  `),
        returns: ["NUMBER"],
        compute: function (value) {
            const _value = toNumber(value);
            assert(() => Math.abs(_value) > 1, _lt("The value (%s) cannot be between -1 and 1 inclusive.", _value.toString()));
            return Math.log((_value + 1) / (_value - 1)) / 2;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ASIN
    // -----------------------------------------------------------------------------
    const ASIN = {
        description: _lt("Inverse sine of a value, in radians."),
        args: args(`
    value (number) ${_lt("The value for which to calculate the inverse sine. Must be between -1 and 1, inclusive.")}
  `),
        returns: ["NUMBER"],
        compute: function (value) {
            const _value = toNumber(value);
            assert(() => Math.abs(_value) <= 1, _lt("The value (%s) must be between -1 and 1 inclusive.", _value.toString()));
            return Math.asin(_value);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ASINH
    // -----------------------------------------------------------------------------
    const ASINH = {
        description: _lt("Inverse hyperbolic sine of a number."),
        args: args(`
    value (number) ${_lt("The value for which to calculate the inverse hyperbolic sine.")}
  `),
        returns: ["NUMBER"],
        compute: function (value) {
            return Math.asinh(toNumber(value));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ATAN
    // -----------------------------------------------------------------------------
    const ATAN = {
        description: _lt("Inverse tangent of a value, in radians."),
        args: args(`
    value (number) ${_lt("The value for which to calculate the inverse tangent.")}
  `),
        returns: ["NUMBER"],
        compute: function (value) {
            return Math.atan(toNumber(value));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ATAN2
    // -----------------------------------------------------------------------------
    const ATAN2 = {
        description: _lt("Angle from the X axis to a point (x,y), in radians."),
        args: args(`
    x (number) ${_lt("The x coordinate of the endpoint of the line segment for which to calculate the angle from the x-axis.")}
    y (number) ${_lt("The y coordinate of the endpoint of the line segment for which to calculate the angle from the x-axis.")}
  `),
        returns: ["NUMBER"],
        compute: function (x, y) {
            const _x = toNumber(x);
            const _y = toNumber(y);
            assert(() => _x !== 0 || _y !== 0, _lt(`Function [[FUNCTION_NAME]] caused a divide by zero error.`));
            return Math.atan2(_y, _x);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ATANH
    // -----------------------------------------------------------------------------
    const ATANH = {
        description: _lt("Inverse hyperbolic tangent of a number."),
        args: args(`
    value (number) ${_lt("The value for which to calculate the inverse hyperbolic tangent. Must be between -1 and 1, exclusive.")}
  `),
        returns: ["NUMBER"],
        compute: function (value) {
            const _value = toNumber(value);
            assert(() => Math.abs(_value) < 1, _lt("The value (%s) must be between -1 and 1 exclusive.", _value.toString()));
            return Math.atanh(_value);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // CEILING
    // -----------------------------------------------------------------------------
    const CEILING = {
        description: _lt(`Rounds number up to nearest multiple of factor.`),
        args: args(`
    value (number) ${_lt("The value to round up to the nearest integer multiple of factor.")}
    factor (number, default=${DEFAULT_FACTOR}) ${_lt("The number to whose multiples value will be rounded.")}
  `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (value, factor = DEFAULT_FACTOR) {
            const _value = toNumber(value);
            const _factor = toNumber(factor);
            assert(() => _factor >= 0 || _value <= 0, _lt("The factor (%s) must be positive when the value (%s) is positive.", _factor.toString(), _value.toString()));
            return _factor ? Math.ceil(_value / _factor) * _factor : 0;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // CEILING.MATH
    // -----------------------------------------------------------------------------
    const CEILING_MATH = {
        description: _lt(`Rounds number up to nearest multiple of factor.`),
        args: args(`
    number (number) ${_lt("The value to round up to the nearest integer multiple of significance.")}
    significance (number, default=${DEFAULT_SIGNIFICANCE}) ${_lt("The number to whose multiples number will be rounded. The sign of significance will be ignored.")}
    mode (number, default=${DEFAULT_MODE}) ${_lt("If number is negative, specifies the rounding direction. If 0 or blank, it is rounded towards zero. Otherwise, it is rounded away from zero.")}
  `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (number, significance = DEFAULT_SIGNIFICANCE, mode = DEFAULT_MODE) {
            let _significance = toNumber(significance);
            if (_significance === 0) {
                return 0;
            }
            const _number = toNumber(number);
            _significance = Math.abs(_significance);
            if (_number >= 0) {
                return Math.ceil(_number / _significance) * _significance;
            }
            const _mode = toNumber(mode);
            if (_mode === 0) {
                return -Math.floor(Math.abs(_number) / _significance) * _significance;
            }
            return -Math.ceil(Math.abs(_number) / _significance) * _significance;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // CEILING.PRECISE
    // -----------------------------------------------------------------------------
    const CEILING_PRECISE = {
        description: _lt(`Rounds number up to nearest multiple of factor.`),
        args: args(`
    number (number) ${_lt("The value to round up to the nearest integer multiple of significance.")}
    significance (number, default=${DEFAULT_SIGNIFICANCE}) ${_lt("The number to whose multiples number will be rounded.")}
  `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (number, significance) {
            return CEILING_MATH.compute(number, significance, 0);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // COS
    // -----------------------------------------------------------------------------
    const COS = {
        description: _lt("Cosine of an angle provided in radians."),
        args: args(`
    angle (number) ${_lt("The angle to find the cosine of, in radians.")}
  `),
        returns: ["NUMBER"],
        compute: function (angle) {
            return Math.cos(toNumber(angle));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // COSH
    // -----------------------------------------------------------------------------
    const COSH = {
        description: _lt("Hyperbolic cosine of any real number."),
        args: args(`
    value (number) ${_lt("Any real value to calculate the hyperbolic cosine of.")}
  `),
        returns: ["NUMBER"],
        compute: function (value) {
            return Math.cosh(toNumber(value));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // COT
    // -----------------------------------------------------------------------------
    const COT = {
        description: _lt("Cotangent of an angle provided in radians."),
        args: args(`
    angle (number) ${_lt("The angle to find the cotangent of, in radians.")}
  `),
        returns: ["NUMBER"],
        compute: function (angle) {
            const _angle = toNumber(angle);
            assert(() => _angle !== 0, _lt(`Evaluation of function [[FUNCTION_NAME]] caused a divide by zero error.`));
            return 1 / Math.tan(_angle);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // COTH
    // -----------------------------------------------------------------------------
    const COTH = {
        description: _lt("Hyperbolic cotangent of any real number."),
        args: args(`
    value (number) ${_lt("Any real value to calculate the hyperbolic cotangent of.")}
  `),
        returns: ["NUMBER"],
        compute: function (value) {
            const _value = toNumber(value);
            assert(() => _value !== 0, _lt(`Evaluation of function [[FUNCTION_NAME]] caused a divide by zero error.`));
            return 1 / Math.tanh(_value);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // COUNTBLANK
    // -----------------------------------------------------------------------------
    const COUNTBLANK = {
        description: _lt("Number of empty values."),
        args: args(`
    value1 (any, range) ${_lt("The first value or range in which to count the number of blanks.")}
    value2 (any, range, repeating) ${_lt("Additional values or ranges in which to count the number of blanks.")}
  `),
        returns: ["NUMBER"],
        compute: function (...argsValues) {
            return reduceAny(argsValues, (acc, a) => (a === null || a === undefined || a === "" ? acc + 1 : acc), 0);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // COUNTIF
    // -----------------------------------------------------------------------------
    const COUNTIF = {
        description: _lt("A conditional count across a range."),
        args: args(`
    range (range) ${_lt("The range that is tested against criterion.")}
    criterion (string) ${_lt("The pattern or test to apply to range.")}
  `),
        returns: ["NUMBER"],
        compute: function (...argsValues) {
            let count = 0;
            visitMatchingRanges(argsValues, (i, j) => {
                count += 1;
            });
            return count;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // COUNTIFS
    // -----------------------------------------------------------------------------
    const COUNTIFS = {
        description: _lt("Count values depending on multiple criteria."),
        args: args(`
    criteria_range1 (range) ${_lt("The range to check against criterion1.")}
    criterion1 (string) ${_lt("The pattern or test to apply to criteria_range1.")}
    criteria_range2 (any, range, repeating) ${_lt("Additional ranges over which to evaluate the additional criteria. The filtered set will be the intersection of the sets produced by each criterion-range pair.")}
    criterion2 (string, repeating) ${_lt("Additional criteria to check.")}
  `),
        returns: ["NUMBER"],
        compute: function (...argsValues) {
            let count = 0;
            visitMatchingRanges(argsValues, (i, j) => {
                count += 1;
            });
            return count;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // COUNTUNIQUE
    // -----------------------------------------------------------------------------
    function isDefined$1(value) {
        switch (value) {
            case undefined:
                return false;
            case "":
                return false;
            case null:
                return false;
            default:
                return true;
        }
    }
    const COUNTUNIQUE = {
        description: _lt("Counts number of unique values in a range."),
        args: args(`
    value1 (any, range) ${_lt("The first value or range to consider for uniqueness.")}
    value2 (any, range, repeating) ${_lt("Additional values or ranges to consider for uniqueness.")}
  `),
        returns: ["NUMBER"],
        compute: function (...argsValues) {
            return reduceAny(argsValues, (acc, a) => (isDefined$1(a) ? acc.add(a) : acc), new Set()).size;
        },
    };
    // -----------------------------------------------------------------------------
    // COUNTUNIQUEIFS
    // -----------------------------------------------------------------------------
    const COUNTUNIQUEIFS = {
        description: _lt("Counts number of unique values in a range, filtered by a set of criteria."),
        args: args(`
    range (range) ${_lt("The range of cells from which the number of unique values will be counted.")}
    criteria_range1 (range) ${_lt("The range of cells over which to evaluate criterion1.")}
    criterion1 (string) ${_lt("The pattern or test to apply to criteria_range1, such that each cell that evaluates to TRUE will be included in the filtered set.")}
    criteria_range2 (any, range, repeating) ${_lt("Additional ranges over which to evaluate the additional criteria. The filtered set will be the intersection of the sets produced by each criterion-range pair.")}
    criterion2 (string, repeating) ${_lt("The pattern or test to apply to criteria_range2.")}
  `),
        returns: ["NUMBER"],
        compute: function (range, ...argsValues) {
            let uniqueValues = new Set();
            visitMatchingRanges(argsValues, (i, j) => {
                const value = range[i][j];
                if (isDefined$1(value)) {
                    uniqueValues.add(value);
                }
            });
            return uniqueValues.size;
        },
    };
    // -----------------------------------------------------------------------------
    // CSC
    // -----------------------------------------------------------------------------
    const CSC = {
        description: _lt("Cosecant of an angle provided in radians."),
        args: args(`
    angle (number) ${_lt("The angle to find the cosecant of, in radians.")}
  `),
        returns: ["NUMBER"],
        compute: function (angle) {
            const _angle = toNumber(angle);
            assert(() => _angle !== 0, _lt(`Evaluation of function [[FUNCTION_NAME]] caused a divide by zero error.`));
            return 1 / Math.sin(_angle);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // CSCH
    // -----------------------------------------------------------------------------
    const CSCH = {
        description: _lt("Hyperbolic cosecant of any real number."),
        args: args(`
    value (number) ${_lt("Any real value to calculate the hyperbolic cosecant of.")}
  `),
        returns: ["NUMBER"],
        compute: function (value) {
            const _value = toNumber(value);
            assert(() => _value !== 0, _lt(`Evaluation of function [[FUNCTION_NAME]] caused a divide by zero error.`));
            return 1 / Math.sinh(_value);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // DECIMAL
    // -----------------------------------------------------------------------------
    const DECIMAL = {
        description: _lt("Converts from another base to decimal."),
        args: args(`
    value (string) ${_lt("The number to convert.")},
    base (number) ${_lt("The base to convert the value from.")},
  `),
        returns: ["NUMBER"],
        compute: function (value, base) {
            let _base = toNumber(base);
            _base = Math.floor(_base);
            assert(() => 2 <= _base && _base <= 36, _lt("The base (%s) must be between 2 and 36 inclusive.", _base.toString()));
            const _value = toString(value);
            if (_value === "") {
                return 0;
            }
            /**
             * @compatibility: on Google sheets, expects the parameter 'value' to be positive.
             * Return error if 'value' is positive.
             * Remove '-?' in the next regex to catch this error.
             */
            assert(() => !!_value.match(/^-?[a-z0-9]+$/i), _lt("The value (%s) must be a valid base %s representation.", _value, _base.toString()));
            const deci = parseInt(_value, _base);
            assert(() => !isNaN(deci), _lt("The value (%s) must be a valid base %s representation.", _value, _base.toString()));
            return deci;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // DEGREES
    // -----------------------------------------------------------------------------
    const DEGREES = {
        description: _lt(`Converts an angle value in radians to degrees.`),
        args: args(`
    angle (number)  ${_lt("The angle to convert from radians to degrees.")}
  `),
        returns: ["NUMBER"],
        compute: function (angle) {
            return (toNumber(angle) * 180) / Math.PI;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // EXP
    // -----------------------------------------------------------------------------
    const EXP = {
        description: _lt(`Euler's number, e (~2.718) raised to a power.`),
        args: args(`
    value (number) ${_lt("The exponent to raise e.")}
  `),
        returns: ["NUMBER"],
        compute: function (value) {
            return Math.exp(toNumber(value));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // FLOOR
    // -----------------------------------------------------------------------------
    const FLOOR = {
        description: _lt(`Rounds number down to nearest multiple of factor.`),
        args: args(`
    value (number) ${_lt("The value to round down to the nearest integer multiple of factor.")}
    factor (number, default=${DEFAULT_FACTOR}) ${_lt("The number to whose multiples value will be rounded.")}
  `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (value, factor = DEFAULT_FACTOR) {
            const _value = toNumber(value);
            const _factor = toNumber(factor);
            assert(() => _factor >= 0 || _value <= 0, _lt("The factor (%s) must be positive when the value (%s) is positive.", _factor.toString(), _value.toString()));
            return _factor ? Math.floor(_value / _factor) * _factor : 0;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // FLOOR.MATH
    // -----------------------------------------------------------------------------
    const FLOOR_MATH = {
        description: _lt(`Rounds number down to nearest multiple of factor.`),
        args: args(`
    number (number) ${_lt("The value to round down to the nearest integer multiple of significance.")}
    significance (number, default=${DEFAULT_SIGNIFICANCE}) ${_lt("The number to whose multiples number will be rounded. The sign of significance will be ignored.")}
    mode (number, default=${DEFAULT_MODE}) ${_lt("If number is negative, specifies the rounding direction. If 0 or blank, it is rounded away from zero. Otherwise, it is rounded towards zero.")}
  `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (number, significance = DEFAULT_SIGNIFICANCE, mode = DEFAULT_MODE) {
            let _significance = toNumber(significance);
            if (_significance === 0) {
                return 0;
            }
            const _number = toNumber(number);
            _significance = Math.abs(_significance);
            if (_number >= 0) {
                return Math.floor(_number / _significance) * _significance;
            }
            const _mode = toNumber(mode);
            if (_mode === 0) {
                return -Math.ceil(Math.abs(_number) / _significance) * _significance;
            }
            return -Math.floor(Math.abs(_number) / _significance) * _significance;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // FLOOR.PRECISE
    // -----------------------------------------------------------------------------
    const FLOOR_PRECISE = {
        description: _lt(`Rounds number down to nearest multiple of factor.`),
        args: args(`
    number (number) ${_lt("The value to round down to the nearest integer multiple of significance.")}
    significance (number, default=${DEFAULT_SIGNIFICANCE}) ${_lt("The number to whose multiples number will be rounded.")}
  `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (number, significance = DEFAULT_SIGNIFICANCE) {
            return FLOOR_MATH.compute(number, significance, 0);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ISEVEN
    // -----------------------------------------------------------------------------
    const ISEVEN = {
        description: _lt(`Whether the provided value is even.`),
        args: args(`
    value (number) ${_lt("The value to be verified as even.")}
  `),
        returns: ["BOOLEAN"],
        compute: function (value) {
            const _value = strictToNumber(value);
            return Math.floor(Math.abs(_value)) & 1 ? false : true;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ISO.CEILING
    // -----------------------------------------------------------------------------
    const ISO_CEILING = {
        description: _lt(`Rounds number up to nearest multiple of factor.`),
        args: args(`
      number (number) ${_lt("The value to round up to the nearest integer multiple of significance.")}
      significance (number, default=${DEFAULT_SIGNIFICANCE}) ${_lt("The number to whose multiples number will be rounded.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (number, significance = DEFAULT_SIGNIFICANCE) {
            return CEILING_MATH.compute(number, significance, 0);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ISODD
    // -----------------------------------------------------------------------------
    const ISODD = {
        description: _lt(`Whether the provided value is even.`),
        args: args(`
    value (number) ${_lt("The value to be verified as even.")}
  `),
        returns: ["BOOLEAN"],
        compute: function (value) {
            const _value = strictToNumber(value);
            return Math.floor(Math.abs(_value)) & 1 ? true : false;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // LN
    // -----------------------------------------------------------------------------
    const LN = {
        description: _lt(`The logarithm of a number, base e (euler's number).`),
        args: args(`
    value (number) ${_lt("The value for which to calculate the logarithm, base e.")}
  `),
        returns: ["NUMBER"],
        compute: function (value) {
            const _value = toNumber(value);
            assert(() => _value > 0, _lt("The value (%s) must be strictly positive.", _value.toString()));
            return Math.log(_value);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // MOD
    // -----------------------------------------------------------------------------
    const MOD = {
        description: _lt(`Modulo (remainder) operator.`),
        args: args(`
      dividend (number) ${_lt("The number to be divided to find the remainder.")}
      divisor (number) ${_lt("The number to divide by.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (dividend, divisor) {
            const _divisor = toNumber(divisor);
            assert(() => _divisor !== 0, _lt("The divisor must be different from 0."));
            const _dividend = toNumber(dividend);
            const modulus = _dividend % _divisor;
            // -42 % 10 = -2 but we want 8, so need the code below
            if ((modulus > 0 && _divisor < 0) || (modulus < 0 && _divisor > 0)) {
                return modulus + _divisor;
            }
            return modulus;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ODD
    // -----------------------------------------------------------------------------
    const ODD = {
        description: _lt(`Rounds a number up to the nearest odd integer.`),
        args: args(`
      value (number) ${_lt("The value to round to the next greatest odd number.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (value) {
            const _value = toNumber(value);
            let temp = Math.ceil(Math.abs(_value));
            temp = temp & 1 ? temp : temp + 1;
            return _value < 0 ? -temp : temp;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // PI
    // -----------------------------------------------------------------------------
    const PI = {
        description: _lt(`The number pi.`),
        args: [],
        returns: ["NUMBER"],
        compute: function () {
            return Math.PI;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // POWER
    // -----------------------------------------------------------------------------
    const POWER = {
        description: _lt(`A number raised to a power.`),
        args: args(`
      base (number) ${_lt("The number to raise to the exponent power.")}
      exponent (number) ${_lt("The exponent to raise base to.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (base, exponent) {
            const _base = toNumber(base);
            const _exponent = toNumber(exponent);
            assert(() => _base >= 0 || Number.isInteger(_exponent), _lt("The exponent (%s) must be an integer when the base is negative.", _exponent.toString()));
            return Math.pow(_base, _exponent);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // PRODUCT
    // -----------------------------------------------------------------------------
    const PRODUCT = {
        description: _lt("Result of multiplying a series of numbers together."),
        args: args(`
      factor1 (number, range<number>) ${_lt("The first number or range to calculate for the product.")}
      factor2 (number, range<number>, repeating) ${_lt("More numbers or ranges to calculate for the product.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (...factors) {
            let count = 0;
            let acc = 1;
            for (let n of factors) {
                if (Array.isArray(n)) {
                    for (let i of n) {
                        for (let j of i) {
                            if (typeof j === "number") {
                                acc *= j;
                                count += 1;
                            }
                        }
                    }
                }
                else if (n !== null && n !== undefined) {
                    acc *= strictToNumber(n);
                    count += 1;
                }
            }
            if (count === 0) {
                return 0;
            }
            return acc;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // RAND
    // -----------------------------------------------------------------------------
    const RAND = {
        description: _lt("A random number between 0 inclusive and 1 exclusive."),
        args: [],
        returns: ["NUMBER"],
        compute: function () {
            return Math.random();
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // RANDBETWEEN
    // -----------------------------------------------------------------------------
    const RANDBETWEEN = {
        description: _lt("Random integer between two values, inclusive."),
        args: args(`
      low (number) ${_lt("The low end of the random range.")}
      high (number) ${_lt("The high end of the random range.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (low, high) {
            let _low = toNumber(low);
            if (!Number.isInteger(_low)) {
                _low = Math.ceil(_low);
            }
            let _high = toNumber(high);
            if (!Number.isInteger(_high)) {
                _high = Math.floor(_high);
            }
            assert(() => _low <= _high, _lt("The high (%s) must be greater than or equal to the low (%s).", _high.toString(), _low.toString()));
            return _low + Math.ceil((_high - _low + 1) * Math.random()) - 1;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ROUND
    // -----------------------------------------------------------------------------
    const ROUND = {
        description: _lt("Rounds a number according to standard rules."),
        args: args(`
      value (number) ${_lt("The value to round to places number of places.")}
      places (number, default=${DEFAULT_PLACES}) ${_lt("The number of decimal places to which to round.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (value, places = DEFAULT_PLACES) {
            const _value = toNumber(value);
            let _places = toNumber(places);
            const absValue = Math.abs(_value);
            let tempResult;
            if (_places === 0) {
                tempResult = Math.round(absValue);
            }
            else {
                if (!Number.isInteger(_places)) {
                    _places = Math.trunc(_places);
                }
                tempResult = Math.round(absValue * Math.pow(10, _places)) / Math.pow(10, _places);
            }
            return _value >= 0 ? tempResult : -tempResult;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ROUNDDOWN
    // -----------------------------------------------------------------------------
    const ROUNDDOWN = {
        description: _lt(`Rounds down a number.`),
        args: args(`
      value (number) ${_lt("The value to round to places number of places, always rounding down.")}
      places (number, default=${DEFAULT_PLACES}) ${_lt("The number of decimal places to which to round.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (value, places = DEFAULT_PLACES) {
            const _value = toNumber(value);
            let _places = toNumber(places);
            const absValue = Math.abs(_value);
            let tempResult;
            if (_places === 0) {
                tempResult = Math.floor(absValue);
            }
            else {
                if (!Number.isInteger(_places)) {
                    _places = Math.trunc(_places);
                }
                tempResult = Math.floor(absValue * Math.pow(10, _places)) / Math.pow(10, _places);
            }
            return _value >= 0 ? tempResult : -tempResult;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ROUNDUP
    // -----------------------------------------------------------------------------
    const ROUNDUP = {
        description: _lt(`Rounds up a number.`),
        args: args(`
      value (number) ${_lt("The value to round to places number of places, always rounding up.")}
      places (number, default=${DEFAULT_PLACES}) ${_lt("The number of decimal places to which to round.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (value, places = DEFAULT_PLACES) {
            const _value = toNumber(value);
            let _places = toNumber(places);
            const absValue = Math.abs(_value);
            let tempResult;
            if (_places === 0) {
                tempResult = Math.ceil(absValue);
            }
            else {
                if (!Number.isInteger(_places)) {
                    _places = Math.trunc(_places);
                }
                tempResult = Math.ceil(absValue * Math.pow(10, _places)) / Math.pow(10, _places);
            }
            return _value >= 0 ? tempResult : -tempResult;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // SEC
    // -----------------------------------------------------------------------------
    const SEC = {
        description: _lt("Secant of an angle provided in radians."),
        args: args(`
    angle (number) ${_lt("The angle to find the secant of, in radians.")}
  `),
        returns: ["NUMBER"],
        compute: function (angle) {
            return 1 / Math.cos(toNumber(angle));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // SECH
    // -----------------------------------------------------------------------------
    const SECH = {
        description: _lt("Hyperbolic secant of any real number."),
        args: args(`
    value (number) ${_lt("Any real value to calculate the hyperbolic secant of.")}
  `),
        returns: ["NUMBER"],
        compute: function (value) {
            return 1 / Math.cosh(toNumber(value));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // SIN
    // -----------------------------------------------------------------------------
    const SIN = {
        description: _lt("Sine of an angle provided in radians."),
        args: args(`
      angle (number) ${_lt("The angle to find the sine of, in radians.")}
    `),
        returns: ["NUMBER"],
        compute: function (angle) {
            return Math.sin(toNumber(angle));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // SINH
    // -----------------------------------------------------------------------------
    const SINH = {
        description: _lt("Hyperbolic sine of any real number."),
        args: args(`
    value (number) ${_lt("Any real value to calculate the hyperbolic sine of.")}
  `),
        returns: ["NUMBER"],
        compute: function (value) {
            return Math.sinh(toNumber(value));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // SQRT
    // -----------------------------------------------------------------------------
    const SQRT = {
        description: _lt("Positive square root of a positive number."),
        args: args(`
      value (number) ${_lt("The number for which to calculate the positive square root.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (value) {
            const _value = toNumber(value);
            assert(() => _value >= 0, _lt("The value (%s) must be positive or null.", _value.toString()));
            return Math.sqrt(_value);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // SUM
    // -----------------------------------------------------------------------------
    const SUM = {
        description: _lt("Sum of a series of numbers and/or cells."),
        args: args(`
      value1 (number, range<number>) ${_lt("The first number or range to add together.")}
      value2 (number, range<number>, repeating) ${_lt("Additional numbers or ranges to add to value1.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (...values) {
            return reduceNumbers(values, (acc, a) => acc + a, 0);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // SUMIF
    // -----------------------------------------------------------------------------
    const SUMIF = {
        description: _lt("A conditional sum across a range."),
        args: args(`
      criteria_range (range) ${_lt("The range which is tested against criterion.")}
      criterion (string) ${_lt("The pattern or test to apply to range.")}
      sum_range (range, default=criteria_range) ${_lt("The range to be summed, if different from range.")}
    `),
        returns: ["NUMBER"],
        compute: function (criteriaRange, criterion, sumRange = undefined) {
            if (sumRange === undefined) {
                sumRange = criteriaRange;
            }
            let sum = 0;
            visitMatchingRanges([criteriaRange, criterion], (i, j) => {
                const value = sumRange[i][j];
                if (typeof value === "number") {
                    sum += value;
                }
            });
            return sum;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // SUMIFS
    // -----------------------------------------------------------------------------
    const SUMIFS = {
        description: _lt("Sums a range depending on multiple criteria."),
        args: args(`
      sum_range (range) ${_lt("The range to sum.")}
      criteria_range1 (range) ${_lt("The range to check against criterion1.")}
      criterion1 (string) ${_lt("The pattern or test to apply to criteria_range1.")}
      criteria_range2 (any, range, repeating) ${_lt("Additional ranges to check.")}
      criterion2 (string, repeating) ${_lt("Additional criteria to check.")}
    `),
        returns: ["NUMBER"],
        compute: function (sumRange, ...criters) {
            let sum = 0;
            visitMatchingRanges(criters, (i, j) => {
                const value = sumRange[i][j];
                if (typeof value === "number") {
                    sum += value;
                }
            });
            return sum;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // TAN
    // -----------------------------------------------------------------------------
    const TAN = {
        description: _lt("Tangent of an angle provided in radians."),
        args: args(`
    angle (number) ${_lt("The angle to find the tangent of, in radians.")}
  `),
        returns: ["NUMBER"],
        compute: function (angle) {
            return Math.tan(toNumber(angle));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // TANH
    // -----------------------------------------------------------------------------
    const TANH = {
        description: _lt("Hyperbolic tangent of any real number."),
        args: args(`
    value (number) ${_lt("Any real value to calculate the hyperbolic tangent of.")}
  `),
        returns: ["NUMBER"],
        compute: function (value) {
            return Math.tanh(toNumber(value));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // TRUNC
    // -----------------------------------------------------------------------------
    const TRUNC = {
        description: _lt("Truncates a number."),
        args: args(`
      value (number) ${_lt("The value to be truncated.")}
      places (number, default=${DEFAULT_PLACES}) ${_lt("The number of significant digits to the right of the decimal point to retain.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (value, places = DEFAULT_PLACES) {
            const _value = toNumber(value);
            let _places = toNumber(places);
            if (_places === 0) {
                return Math.trunc(_value);
            }
            if (!Number.isInteger(_places)) {
                _places = Math.trunc(_places);
            }
            return Math.trunc(_value * Math.pow(10, _places)) / Math.pow(10, _places);
        },
        isExported: true,
    };

    var math = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ABS: ABS,
        ACOS: ACOS,
        ACOSH: ACOSH,
        ACOT: ACOT,
        ACOTH: ACOTH,
        ASIN: ASIN,
        ASINH: ASINH,
        ATAN: ATAN,
        ATAN2: ATAN2,
        ATANH: ATANH,
        CEILING: CEILING,
        CEILING_MATH: CEILING_MATH,
        CEILING_PRECISE: CEILING_PRECISE,
        COS: COS,
        COSH: COSH,
        COT: COT,
        COTH: COTH,
        COUNTBLANK: COUNTBLANK,
        COUNTIF: COUNTIF,
        COUNTIFS: COUNTIFS,
        COUNTUNIQUE: COUNTUNIQUE,
        COUNTUNIQUEIFS: COUNTUNIQUEIFS,
        CSC: CSC,
        CSCH: CSCH,
        DECIMAL: DECIMAL,
        DEGREES: DEGREES,
        EXP: EXP,
        FLOOR: FLOOR,
        FLOOR_MATH: FLOOR_MATH,
        FLOOR_PRECISE: FLOOR_PRECISE,
        ISEVEN: ISEVEN,
        ISO_CEILING: ISO_CEILING,
        ISODD: ISODD,
        LN: LN,
        MOD: MOD,
        ODD: ODD,
        PI: PI,
        POWER: POWER,
        PRODUCT: PRODUCT,
        RAND: RAND,
        RANDBETWEEN: RANDBETWEEN,
        ROUND: ROUND,
        ROUNDDOWN: ROUNDDOWN,
        ROUNDUP: ROUNDUP,
        SEC: SEC,
        SECH: SECH,
        SIN: SIN,
        SINH: SINH,
        SQRT: SQRT,
        SUM: SUM,
        SUMIF: SUMIF,
        SUMIFS: SUMIFS,
        TAN: TAN,
        TANH: TANH,
        TRUNC: TRUNC
    });

    const colors$1 = [
        "#eb6d00",
        "#0074d9",
        "#ad8e00",
        "#169ed4",
        "#b10dc9",
        "#00a82d",
        "#00a3a3",
        "#f012be",
        "#3d9970",
        "#111111",
        "#62A300",
        "#ff4136",
        "#949494",
        "#85144b",
        "#001f3f",
    ];
    /*
     * transform a color number (R * 256^2 + G * 256 + B) into classic RGB
     * */
    function colorNumberString(color) {
        return color.toString(16).padStart(6, "0");
    }
    let colorIndex = 0;
    function getNextColor() {
        colorIndex = ++colorIndex % colors$1.length;
        return colors$1[colorIndex];
    }
    /**
     * Converts any CSS color value to a standardized hex6 value.
     * Accepts: hex3, hex6 and rgb (rgba is not supported)
     *
     * toHex6("#ABC")
     * >> "AABBCC"
     *
     * toHex6("#AAAFFF")
     * >> "AAAFFF"
     *
     * toHex6("rgb(30, 80, 16)")
     * >> "1E5010"
     *
     * (note: number sign is dropped as it is not supported in xlsx format)
     */
    function toHex6(color) {
        if (color.includes("rgb")) {
            return rgbToHex6(color);
        }
        color = color.replace("#", "").toUpperCase();
        if (color.length === 3) {
            color = color.split("").reduce((acc, h) => acc + h + h, "");
        }
        return color;
    }
    /**
     * Convert a CSS rgb color string to a standardized hex6 color value.
     *
     * rgbToHex6("rgb(30, 80, 16)")
     * >> "1E5010"
     */
    function rgbToHex6(color) {
        return color
            .slice(4, -1)
            .split(",")
            .map((valueString) => parseInt(valueString, 10).toString(16).padStart(2, "0"))
            .join("")
            .toUpperCase();
    }

    /**
     * Regex that detect cell reference and a range reference (without the sheetName)
     */
    const cellReference = new RegExp(/\$?([A-Z]{1,3})\$?([0-9]{1,7})/, "i");
    const rangeReference = new RegExp(/^\s*(.*!)?\$?[A-Z]{1,3}\$?[0-9]{1,7}\s*(\s*:\s*\$?[A-Z]{1,3}\$?[0-9]{1,7}\s*)?$/, "i");

    //------------------------------------------------------------------------------
    /**
     * Convert a (col) number to the corresponding letter.
     *
     * Examples:
     *     0 => 'A'
     *     25 => 'Z'
     *     26 => 'AA'
     *     27 => 'AB'
     */
    function numberToLetters(n) {
        if (n < 26) {
            return String.fromCharCode(65 + n);
        }
        else {
            return numberToLetters(Math.floor(n / 26) - 1) + numberToLetters(n % 26);
        }
    }
    /**
     * Convert a string (describing a column) to its number value.
     *
     * Examples:
     *     'A' => 0
     *     'Z' => 25
     *     'AA' => 26
     */
    function lettersToNumber(letters) {
        let result = 0;
        const l = letters.length;
        for (let i = 0; i < l; i++) {
            let n = letters.charCodeAt(i) - 65 + (i < l - 1 ? 1 : 0);
            result += n * 26 ** (l - i - 1);
        }
        return result;
    }
    /**
     * Convert a "XC" coordinate to cartesian coordinates.
     *
     * Examples:
     *   A1 => [0,0]
     *   B3 => [1,2]
     *
     * Note: it also accepts lowercase coordinates, but not fixed references
     */
    function toCartesian(xc) {
        xc = xc.toUpperCase().trim();
        const [m, letters, numbers] = xc.match(cellReference);
        if (m !== xc) {
            throw new Error(`Invalid cell description: ${xc}`);
        }
        const col = lettersToNumber(letters);
        const row = parseInt(numbers, 10) - 1;
        return [col, row];
    }
    /**
     * Convert from cartesian coordinate to the "XC" coordinate system.
     *
     * Examples:
     *   - 0,0 => A1
     *   - 1,2 => B3
     *   - 0,0, {colFixed: false, rowFixed: true} => A$1
     *   - 1,2, {colFixed: true, rowFixed: false} => $B3
     */
    function toXC(col, row, rangePart = { colFixed: false, rowFixed: false }) {
        return ((rangePart.colFixed ? "$" : "") +
            numberToLetters(col) +
            (rangePart.rowFixed ? "$" : "") +
            String(row + 1));
    }

    const MAX_DELAY = 140;
    const MIN_DELAY = 20;
    const ACCELERATION = 0.035;
    /**
     * Decreasing exponential function used to determine the "speed" of edge-scrolling
     * as the timeout delay.
     *
     * Returns a timeout delay in milliseconds.
     */
    function scrollDelay(value) {
        // decreasing exponential from MAX_DELAY to MIN_DELAY
        return MIN_DELAY + (MAX_DELAY - MIN_DELAY) * Math.exp(-ACCELERATION * (value - 1));
    }

    const fontSizes = [
        { pt: 7.5, px: 10 },
        { pt: 8, px: 11 },
        { pt: 9, px: 12 },
        { pt: 10, px: 13 },
        { pt: 10.5, px: 14 },
        { pt: 11, px: 15 },
        { pt: 12, px: 16 },
        { pt: 14, px: 18.7 },
        { pt: 15, px: 20 },
        { pt: 16, px: 21.3 },
        { pt: 18, px: 24 },
        { pt: 22, px: 29.3 },
        { pt: 24, px: 32 },
        { pt: 26, px: 34.7 },
        { pt: 36, px: 48 },
    ];
    const fontSizeMap = {};
    for (let font of fontSizes) {
        fontSizeMap[font.pt] = font.px;
    }

    //------------------------------------------------------------------------------
    /**
     * Stringify an object, like JSON.stringify, except that the first level of keys
     * is ordered.
     */
    function stringify(obj) {
        return JSON.stringify(obj, Object.keys(obj).sort());
    }
    /**
     * Deep copy arrays, plain objects and primitive values.
     * Throws an error for other types such as class instances.
     * Sparse arrays remain sparse.
     */
    function deepCopy(obj) {
        const result = Array.isArray(obj) ? [] : {};
        switch (typeof obj) {
            case "object": {
                if (obj === null) {
                    return obj;
                }
                else if (!(isPlainObject(obj) || obj instanceof Array)) {
                    throw new Error("Unsupported type: only objects and arrays are supported");
                }
                for (const key in obj) {
                    result[key] = deepCopy(obj[key]);
                }
                return result;
            }
            case "number":
            case "string":
            case "boolean":
            case "function":
            case "undefined":
                return obj;
            default:
                throw new Error(`Unsupported type: ${typeof obj}`);
        }
    }
    /**
     * Check if the object is a plain old javascript object.
     */
    function isPlainObject(obj) {
        return typeof obj === "object" && (obj === null || obj === void 0 ? void 0 : obj.constructor) === Object;
    }
    /**
     * Sanitize the name of a sheet, by eventually removing quotes
     * @param sheetName name of the sheet, potentially quoted with single quotes
     */
    function getUnquotedSheetName(sheetName) {
        if (sheetName.startsWith("'")) {
            sheetName = sheetName.slice(1, -1).replace(/''/g, "'");
        }
        return sheetName;
    }
    /**
     * Add quotes around the sheet name if it contains at least one non alphanumeric character
     * '\w' captures [0-9][a-z][A-Z] and _.
     * @param sheetName Name of the sheet
     */
    function getComposerSheetName(sheetName) {
        var _a;
        if (((_a = sheetName.match(/\w/g)) === null || _a === void 0 ? void 0 : _a.length) !== sheetName.length) {
            sheetName = `'${sheetName}'`;
        }
        return sheetName;
    }
    function clip(val, min, max) {
        return val < min ? min : val > max ? max : val;
    }
    function computeTextWidth(context, text, style) {
        const italic = style.italic ? "italic " : "";
        const weight = style.bold ? "bold" : DEFAULT_FONT_WEIGHT;
        const sizeInPt = style.fontSize || DEFAULT_FONT_SIZE;
        const size = fontSizeMap[sizeInPt];
        context.font = `${italic}${weight} ${size}px ${DEFAULT_FONT}`;
        return context.measureText(text).width;
    }
    function computeIconWidth(context, style) {
        const sizeInPt = style.fontSize || DEFAULT_FONT_SIZE;
        const size = fontSizeMap[sizeInPt];
        return size + 2 * MIN_CF_ICON_MARGIN;
    }
    /**
     * Create a range from start (included) to end (excluded).
     * range(10, 13) => [10, 11, 12]
     * range(2, 8, 2) => [2, 4, 6]
     */
    function range(start, end, step = 1) {
        if (end <= start && step > 0) {
            return [];
        }
        if (step === 0) {
            throw new Error("range() step must not be zero");
        }
        const length = Math.ceil(Math.abs((end - start) / step));
        const array = Array(length);
        for (let i = 0; i < length; i++) {
            array[i] = start + i * step;
        }
        return array;
    }
    /**
     * Groups consecutive numbers.
     * The input array is assumed to be sorted
     * @param numbers
     */
    function groupConsecutive(numbers) {
        return numbers.reduce((groups, currentRow, index, rows) => {
            if (Math.abs(currentRow - rows[index - 1]) === 1) {
                const lastGroup = groups[groups.length - 1];
                lastGroup.push(currentRow);
            }
            else {
                groups.push([currentRow]);
            }
            return groups;
        }, []);
    }
    /**
     * Create one generator from two generators by linking
     * each item of the first generator to the next item of
     * the second generator.
     *
     * Let's say generator G1 yields A, B, C and generator G2 yields X, Y, Z.
     * The resulting generator of `linkNext(G1, G2)` will yield A', B', C'
     * where `A' = A & {next: Y}`, `B' = B & {next: Z}` and `C' = C & {next: undefined}`
     * @param generator
     * @param nextGenerator
     */
    function* linkNext(generator, nextGenerator) {
        nextGenerator.next();
        for (const item of generator) {
            const nextItem = nextGenerator.next();
            yield {
                ...item,
                next: nextItem.done ? undefined : nextItem.value,
            };
        }
    }
    function isBoolean(str) {
        const upperCased = str.toUpperCase();
        return upperCased === "TRUE" || upperCased === "FALSE";
    }
    function isDateTime(str) {
        return parseDateTime(str) !== null;
    }
    const MARKDOWN_LINK_REGEX = /^\[([^\[]+)\]\((.+)\)$/;
    //link must start with http or https
    //https://stackoverflow.com/a/3809435/4760614
    const WEB_LINK_REGEX = /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,4}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)$/;
    function isMarkdownLink(str) {
        return MARKDOWN_LINK_REGEX.test(str);
    }
    /**
     * Check if the string is a web link.
     * e.g. http://odoo.com
     */
    function isWebLink(str) {
        return WEB_LINK_REGEX.test(str);
    }
    /**
     * Build a markdown link from a label and an url
     */
    function markdownLink(label, url) {
        return `[${label}](${url})`;
    }
    function parseMarkdownLink(str) {
        const matches = str.match(MARKDOWN_LINK_REGEX) || [];
        const label = matches[1];
        const url = matches[2];
        if (!label || !url) {
            throw new Error(`Could not parse markdown link ${str}.`);
        }
        return {
            label,
            url,
        };
    }
    const O_SPREADSHEET_LINK_PREFIX = "o-spreadsheet://";
    function isMarkdownSheetLink(str) {
        if (!isMarkdownLink(str)) {
            return false;
        }
        const { url } = parseMarkdownLink(str);
        return url.startsWith(O_SPREADSHEET_LINK_PREFIX);
    }
    function buildSheetLink(sheetId) {
        return `${O_SPREADSHEET_LINK_PREFIX}${sheetId}`;
    }
    /**
     * Parse a sheet link and return the sheet id
     */
    function parseSheetLink(sheetLink) {
        if (sheetLink.startsWith(O_SPREADSHEET_LINK_PREFIX)) {
            return sheetLink.substr(O_SPREADSHEET_LINK_PREFIX.length);
        }
        throw new Error(`${sheetLink} is not a valid sheet link`);
    }
    /**
     * This helper function can be used as a type guard when filtering arrays.
     * const foo: number[] = [1, 2, undefined, 4].filter(isDefined)
     */
    function isDefined(argument) {
        return argument !== undefined;
    }
    const DEBUG = {};

    /**
     * Convert from a cartesian reference to a Zone
     * The range boundaries will be kept in the same order as the
     * ones in the text.
     * Examples:
     *    "A1" ==> Top 0, Bottom 0, Left: 0, Right: 0
     *    "B1:B3" ==> Top 0, Bottom 3, Left: 1, Right: 1
     *    "Sheet1!A1" ==> Top 0, Bottom 0, Left: 0, Right: 0
     *    "Sheet1!B1:B3" ==> Top 0, Bottom 3, Left: 1, Right: 1
     *    "C3:A1" ==> Top 2, Bottom 0, Left 2, Right 0}
     *
     * @param xc the string reference to convert
     *
     */
    function toZoneWithoutBoundaryChanges(xc) {
        xc = xc.split("!").pop();
        const ranges = xc.replace(/\$/g, "").split(":");
        let top, bottom, left, right;
        let c = toCartesian(ranges[0].trim());
        left = right = c[0];
        top = bottom = c[1];
        if (ranges.length === 2) {
            let d = toCartesian(ranges[1].trim());
            right = d[0];
            bottom = d[1];
        }
        return { top, bottom, left, right };
    }
    /**
     * Convert from a cartesian reference to a Zone
     *
     * Examples:
     *    "A1" ==> Top 0, Bottom 0, Left: 0, Right: 0
     *    "B1:B3" ==> Top 0, Bottom 3, Left: 1, Right: 1
     *    "Sheet1!A1" ==> Top 0, Bottom 0, Left: 0, Right: 0
     *    "Sheet1!B1:B3" ==> Top 0, Bottom 3, Left: 1, Right: 1
     *
     * @param xc the string reference to convert
     *
     */
    function toZone(xc) {
        let { top, bottom, left, right } = toZoneWithoutBoundaryChanges(xc);
        if (right < left) {
            [right, left] = [left, right];
        }
        if (bottom < top) {
            [bottom, top] = [top, bottom];
        }
        return { top, bottom, left, right };
    }
    /**
     * Check that the zone has valid coordinates and in
     * the correct order.
     */
    function isZoneValid(zone) {
        // Typescript *should* prevent this kind of errors but
        // it's better to be on the safe side at runtime as well.
        if (isNaN(zone.bottom) || isNaN(zone.top) || isNaN(zone.left) || isNaN(zone.right)) {
            return false;
        }
        return zone.bottom >= zone.top && zone.right >= zone.left;
    }
    /**
     * Convert from zone to a cartesian reference
     *
     */
    function zoneToXc(zone) {
        const { top, bottom, left, right } = zone;
        const isOneCell = top === bottom && left === right;
        return isOneCell ? toXC(left, top) : `${toXC(left, top)}:${toXC(right, bottom)}`;
    }
    /**
     * Expand a zone after inserting columns or rows.
     */
    function expandZoneOnInsertion(zone, start, base, position, quantity) {
        const dimension = start === "left" ? "columns" : "rows";
        const baseElement = position === "before" ? base - 1 : base;
        const end = start === "left" ? "right" : "bottom";
        const shouldIncludeEnd = position === "before" ? zone[end] > baseElement : zone[end] >= baseElement;
        if (zone[start] <= baseElement && shouldIncludeEnd) {
            return createAdaptedZone(zone, dimension, "RESIZE", quantity);
        }
        if (baseElement < zone[start]) {
            return createAdaptedZone(zone, dimension, "MOVE", quantity);
        }
        return { ...zone };
    }
    /**
     * Update the selection after column/row addition
     */
    function updateSelectionOnInsertion(selection, start, base, position, quantity) {
        const dimension = start === "left" ? "columns" : "rows";
        const baseElement = position === "before" ? base - 1 : base;
        const end = start === "left" ? "right" : "bottom";
        if (selection[start] <= baseElement && selection[end] > baseElement) {
            return createAdaptedZone(selection, dimension, "RESIZE", quantity);
        }
        if (baseElement < selection[start]) {
            return createAdaptedZone(selection, dimension, "MOVE", quantity);
        }
        return { ...selection };
    }
    /**
     * Update the selection after column/row deletion
     */
    function updateSelectionOnDeletion(zone, start, elements) {
        const end = start === "left" ? "right" : "bottom";
        let newStart = zone[start];
        let newEnd = zone[end];
        for (let removedElement of elements.sort((a, b) => b - a)) {
            if (zone[start] > removedElement) {
                newStart--;
                newEnd--;
            }
            if (zone[start] < removedElement && zone[end] >= removedElement) {
                newEnd--;
            }
        }
        return { ...zone, [start]: newStart, [end]: newEnd };
    }
    /**
     * Reduce a zone after deletion of elements
     */
    function reduceZoneOnDeletion(zone, start, elements) {
        const end = start === "left" ? "right" : "bottom";
        let newStart = zone[start];
        let newEnd = zone[end];
        for (let removedElement of elements.sort((a, b) => b - a)) {
            if (zone[start] > removedElement) {
                newStart--;
                newEnd--;
            }
            if (zone[start] <= removedElement && zone[end] >= removedElement) {
                newEnd--;
            }
        }
        if (newStart > newEnd) {
            return undefined;
        }
        return { ...zone, [start]: newStart, [end]: newEnd };
    }
    /**
     * Compute the union of two zones. It is the smallest zone which contains the
     * two arguments.
     */
    function union(z1, z2) {
        return {
            top: Math.min(z1.top, z2.top),
            left: Math.min(z1.left, z2.left),
            bottom: Math.max(z1.bottom, z2.bottom),
            right: Math.max(z1.right, z2.right),
        };
    }
    /**
     * Compute the intersection of two zones. Returns nothing if the two zones don't overlap
     */
    function intersection(z1, z2) {
        if (!overlap(z1, z2)) {
            return undefined;
        }
        return {
            top: Math.max(z1.top, z2.top),
            left: Math.max(z1.left, z2.left),
            bottom: Math.min(z1.bottom, z2.bottom),
            right: Math.min(z1.right, z2.right),
        };
    }
    /**
     * Two zones are equal if they represent the same area, so we clearly cannot use
     * reference equality.
     */
    function isEqual(z1, z2) {
        return (z1.left === z2.left && z1.right === z2.right && z1.top === z2.top && z1.bottom === z2.bottom);
    }
    /**
     * Return true if two zones overlap, false otherwise.
     */
    function overlap(z1, z2) {
        if (z1.bottom < z2.top || z2.bottom < z1.top) {
            return false;
        }
        if (z1.right < z2.left || z2.right < z1.left) {
            return false;
        }
        return true;
    }
    function isInside(col, row, zone) {
        const { left, right, top, bottom } = zone;
        return col >= left && col <= right && row >= top && row <= bottom;
    }
    /**
     * Check if a zone is inside another
     */
    function isZoneInside(smallZone, biggerZone) {
        return isEqual(union(biggerZone, smallZone), biggerZone);
    }
    /**
     * Recompute the ranges of the zone to contain all the cells in zones, without the cells in toRemoveZones
     * Also regroup zones together to shorten the string
     * (A1, A2, B1, B2, [C1:C2], C3 => [A1:B2],[C1:C3])
     * To do so, the cells are separated and remerged in zones by columns, and then
     * if possible zones in adjacent columns are merged together.
     */
    function recomputeZones(zones, toRemoveZones) {
        const zonesPerColumn = {};
        //separate the existing zones per column
        for (let z of zones) {
            if (z) {
                const zone = toZone(z);
                for (let col = zone.left; col <= zone.right; col++) {
                    if (zonesPerColumn[col] === undefined) {
                        zonesPerColumn[col] = [];
                    }
                    zonesPerColumn[col].push({
                        top: zone.top,
                        bottom: zone.bottom,
                        remove: false,
                    });
                }
            }
        }
        //separate the to deleted zones per column
        for (let z of toRemoveZones) {
            const zone = toZone(z);
            for (let col = zone.left; col <= zone.right; col++) {
                if (zonesPerColumn[col] === undefined) {
                    zonesPerColumn[col] = [];
                }
                zonesPerColumn[col].push({
                    top: zone.top,
                    bottom: zone.bottom,
                    remove: true,
                });
            }
        }
        const OptimizedZonePerColumn = [];
        //regroup zones per column
        for (let [col, zones] of Object.entries(zonesPerColumn)) {
            OptimizedZonePerColumn.push({
                col: parseInt(col),
                ranges: optimiseColumn(zones),
            });
        }
        //merge zones that spread over multiple columns that can be merged
        const result = mergeColumns(OptimizedZonePerColumn);
        return result.map(zoneToXc);
    }
    /**
     * Recompute the ranges of a column, without the remove cells.
     * takes as input a array of {top, bottom, remove} where top and bottom
     * are the start and end of ranges in the column and remove expresses if the
     * cell should be kept or not.
     */
    function optimiseColumn(zones) {
        const toKeep = new Set();
        const toRemove = new Set();
        for (let zone of zones) {
            for (let x = zone.top; x <= zone.bottom; x++) {
                zone.remove ? toRemove.add(x) : toKeep.add(x);
            }
        }
        const finalElements = [...toKeep]
            .filter((x) => !toRemove.has(x))
            .sort((a, b) => {
            return a - b;
        });
        const newZones = [];
        let currentZone;
        for (let x of finalElements) {
            if (!currentZone) {
                currentZone = { top: x, bottom: x };
            }
            else if (x === currentZone.bottom + 1) {
                currentZone.bottom = x;
            }
            else {
                newZones.push({ top: currentZone.top, bottom: currentZone.bottom });
                currentZone = { top: x, bottom: x };
            }
        }
        if (currentZone) {
            newZones.push({ top: currentZone.top, bottom: currentZone.bottom });
        }
        return newZones;
    }
    /**
     * Verify if ranges in two adjacent columns can be merged in one in one range,
     * and if they can, merge them in the same range.
     */
    function mergeColumns(zonePerCol) {
        const orderedZones = zonePerCol.sort((a, b) => {
            return a.col - b.col;
        });
        const finalZones = [];
        let inProgressZones = [];
        let currentCol = 0;
        for (let index = 0; index <= orderedZones.length - 1; index++) {
            let newInProgress = [];
            if (currentCol + 1 === orderedZones[index].col) {
                for (let z1 of orderedZones[index].ranges) {
                    let merged = false;
                    for (let z2 of inProgressZones) {
                        //extend existing zone with the adjacent col
                        if (z1.top == z2.top && z1.bottom == z2.bottom) {
                            newInProgress.push(z2);
                            merged = true;
                        }
                    }
                    // create new zone as it could not be merged with a previous one
                    if (!merged) {
                        newInProgress.push({ top: z1.top, bottom: z1.bottom, startCol: orderedZones[index].col });
                    }
                }
            }
            else {
                // create new zone as it was not adjacent to the previous zones
                newInProgress = orderedZones[index].ranges.map((zone) => {
                    return {
                        top: zone.top,
                        bottom: zone.bottom,
                        startCol: orderedZones[index].col,
                    };
                });
            }
            //All the zones from inProgressZones that are not transferred in newInProgress
            //are zones that were not extended and are therefore final.
            const difference = inProgressZones.filter((x) => !newInProgress.includes(x));
            for (let x of difference) {
                finalZones.push({ top: x.top, bottom: x.bottom, left: x.startCol, right: currentCol });
            }
            currentCol = orderedZones[index].col;
            inProgressZones = newInProgress;
        }
        //after the last iteration, the unfinished zones need to be finalized to.
        for (let x of inProgressZones) {
            finalZones.push({ top: x.top, bottom: x.bottom, left: x.startCol, right: currentCol });
        }
        return finalZones;
    }
    function mapCellsInZone(zone, sheet, callback, emptyCellValue = undefined, stepX = 1, stepY = 1) {
        var _a;
        const { top, bottom, left, right } = zone;
        const result = new Array(Math.floor((right - left + 1) / stepX));
        for (let c = left; c <= right; c += stepX) {
            let col = new Array(Math.floor((bottom - top + 1) / stepY));
            result[c - left] = col;
            for (let r = top; r <= bottom; r += stepY) {
                let cell = (_a = sheet.rows[r]) === null || _a === void 0 ? void 0 : _a.cells[c];
                col[(r - top) / stepY] = cell ? callback(cell) : emptyCellValue;
            }
        }
        return result;
    }
    function zoneToDimension(zone) {
        return {
            height: zone.bottom - zone.top + 1,
            width: zone.right - zone.left + 1,
        };
    }
    function isOneDimensional(zone) {
        const { width, height } = zoneToDimension(zone);
        return width === 1 || height === 1;
    }
    /**
     * Array of all positions in the zone.
     */
    function positions(zone) {
        const positions = [];
        const [left, right] = [zone.right, zone.left].sort((a, b) => a - b);
        const [top, bottom] = [zone.top, zone.bottom].sort((a, b) => a - b);
        for (const col of range(left, right + 1)) {
            for (const row of range(top, bottom + 1)) {
                positions.push([col, row]);
            }
        }
        return positions;
    }
    function createAdaptedZone(zone, dimension, operation, by) {
        const start = dimension === "columns" ? "left" : "top";
        const end = dimension === "columns" ? "right" : "bottom";
        const newZone = { ...zone };
        if (operation === "MOVE") {
            newZone[start] += by;
        }
        newZone[end] += by;
        return newZone;
    }
    /**
     * Returns a Zone array with unique occurrence of each zone.
     * For each multiple occurrence, the occurrence with the largest index is kept.
     * This allows to always have the last selection made in the last position.
     * */
    function uniqueZones(zones) {
        return zones
            .reverse()
            .filter((zone, index, self) => index ===
            self.findIndex((z) => z.top === zone.top &&
                z.bottom === zone.bottom &&
                z.left === zone.left &&
                z.right === zone.right))
            .reverse();
    }
    /**
     * This function will compare the modifications of selection to determine
     * a cell that is part of the new zone and not the previous one.
     */
    function findCellInNewZone(oldZone, currentZone, viewport) {
        let col, row;
        const { left: oldLeft, right: oldRight, top: oldTop, bottom: oldBottom } = oldZone;
        const { left, right, top, bottom } = currentZone;
        if (left != oldLeft) {
            col = left;
        }
        else if (right != oldRight) {
            col = right;
        }
        else {
            col = viewport.left;
        }
        if (top != oldTop) {
            row = top;
        }
        else if (bottom != oldBottom) {
            row = bottom;
        }
        else {
            row = viewport.top;
        }
        return [col, row];
    }
    function organizeZone(zone) {
        return {
            top: Math.min(zone.top, zone.bottom),
            bottom: Math.max(zone.top, zone.bottom),
            left: Math.min(zone.left, zone.right),
            right: Math.max(zone.left, zone.right),
        };
    }

    /*
     * Contains all method to update ranges with grid_manipulation
     */
    function updateRemoveColumns(range, columns) {
        let { left, right, top, bottom } = toZone(range);
        columns = columns.slice().sort((a, b) => b - a);
        for (let column of columns) {
            if (left > column) {
                left -= 1;
            }
            if (left >= column || right >= column) {
                right -= 1;
            }
        }
        if (left > right) {
            return null;
        }
        return toXC(left, top) + ":" + toXC(right, bottom);
    }
    function updateRemoveRows(range, rows) {
        let { left, right, top, bottom } = toZone(range);
        rows = rows.slice().sort((a, b) => b - a);
        for (let row of rows) {
            if (top > row) {
                top -= 1;
            }
            if (top >= row || bottom >= row) {
                bottom -= 1;
            }
        }
        if (top > bottom) {
            return null;
        }
        return toXC(left, top) + ":" + toXC(right, bottom);
    }
    function updateAddColumns(range, column, step) {
        let { left, right, top, bottom } = toZone(range);
        if (left >= column) {
            left += step;
        }
        if (left >= column || right >= column) {
            right += step;
        }
        if (left > right) {
            return null;
        }
        return toXC(left, top) + ":" + toXC(right, bottom);
    }
    function updateAddRows(range, row, step) {
        let { left, right, top, bottom } = toZone(range);
        if (top >= row) {
            top += step;
        }
        if (top >= row || bottom >= row) {
            bottom += step;
        }
        if (top > bottom) {
            return null;
        }
        return toXC(left, top) + ":" + toXC(right, bottom);
    }

    function createDefaultCols(colNumber) {
        const cols = [];
        let current = 0;
        for (let i = 0; i < colNumber; i++) {
            const size = DEFAULT_CELL_WIDTH;
            const col = {
                start: current,
                end: current + size,
                size: size,
                name: numberToLetters(i),
            };
            cols.push(col);
            current = col.end;
        }
        return cols;
    }
    function createDefaultRows(rowNumber) {
        const rows = [];
        let current = 0;
        for (let i = 0; i < rowNumber; i++) {
            const size = DEFAULT_CELL_HEIGHT;
            const row = {
                start: current,
                end: current + size,
                size: size,
                name: String(i + 1),
                cells: {},
            };
            rows.push(row);
            current = row.end;
        }
        return rows;
    }
    function createCols(savedCols, colNumber) {
        var _a;
        const cols = [];
        let current = 0;
        for (let i = 0; i < colNumber; i++) {
            const size = savedCols[i] ? savedCols[i].size || DEFAULT_CELL_WIDTH : DEFAULT_CELL_WIDTH;
            const hidden = ((_a = savedCols[i]) === null || _a === void 0 ? void 0 : _a.isHidden) || false;
            const end = hidden ? current : current + size;
            const col = {
                start: current,
                end: end,
                size: size,
                name: numberToLetters(i),
            };
            if (hidden) {
                col.isHidden = hidden;
            }
            cols.push(col);
            current = col.end;
        }
        return cols;
    }
    function createRows(savedRows, rowNumber) {
        var _a;
        const rows = [];
        let current = 0;
        for (let i = 0; i < rowNumber; i++) {
            const size = savedRows[i] ? savedRows[i].size || DEFAULT_CELL_HEIGHT : DEFAULT_CELL_HEIGHT;
            const hidden = ((_a = savedRows[i]) === null || _a === void 0 ? void 0 : _a.isHidden) || false;
            const end = hidden ? current : current + size;
            const row = {
                start: current,
                end: end,
                size: size,
                name: String(i + 1),
                cells: {},
            };
            if (hidden) {
                row.isHidden = hidden;
            }
            rows.push(row);
            current = row.end;
        }
        return rows;
    }
    function exportCols(cols, exportDefaults = false) {
        const exportedCols = {};
        for (let i in cols) {
            const col = cols[i];
            if (col.size !== DEFAULT_CELL_WIDTH || exportDefaults) {
                exportedCols[i] = { size: col.size };
            }
            if (col.isHidden) {
                exportedCols[i] = exportedCols[i] || {};
                exportedCols[i]["isHidden"] = col.isHidden;
            }
        }
        return exportedCols;
    }
    function exportRows(rows, exportDefaults = false) {
        const exportedRows = {};
        for (let i in rows) {
            const row = rows[i];
            if (row.size !== DEFAULT_CELL_HEIGHT || exportDefaults) {
                exportedRows[i] = { size: row.size };
            }
            if (row.isHidden) {
                exportedRows[i] = exportedRows[i] || {};
                exportedRows[i]["isHidden"] = row.isHidden;
            }
        }
        return exportedRows;
    }

    /*
     * https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
     * */
    class UuidGenerator {
        constructor() {
            this.isFastIdStrategy = false;
            this.fastIdStart = 0;
        }
        setIsFastStrategy(isFast) {
            this.isFastIdStrategy = isFast;
        }
        uuidv4() {
            if (this.isFastIdStrategy) {
                this.fastIdStart++;
                return String(this.fastIdStart);
                //@ts-ignore
            }
            else if (window.crypto && window.crypto.getRandomValues) {
                //@ts-ignore
                return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) => (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16));
            }
            else {
                // mainly for jest and other browsers that do not have the crypto functionality
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
                    var r = (Math.random() * 16) | 0, v = c == "x" ? r : (r & 0x3) | 0x8;
                    return v.toString(16);
                });
            }
        }
    }

    function getNextVisibleCellCoords(sheet, col, row) {
        return [
            findVisibleHeader(sheet, "cols", range(col, sheet.cols.length)),
            findVisibleHeader(sheet, "rows", range(row, sheet.rows.length)),
        ];
    }
    function findVisibleHeader(sheet, dimension, indexes) {
        const headers = sheet[dimension];
        return indexes.find((index) => !headers[index].isHidden);
    }
    function findLastVisibleColRow(sheet, dimension) {
        let lastIndex = sheet[dimension].length - 1;
        while (lastIndex >= 0 && sheet[dimension][lastIndex].isHidden === true) {
            lastIndex--;
        }
        return sheet[dimension][lastIndex];
    }

    // Note: dataY and dataX may not have the same dimension
    function covariance(dataY, dataX, isSample) {
        let flatDataY = [];
        let flatDataX = [];
        let lenY = 0;
        let lenX = 0;
        visitAny([dataY], (y) => {
            flatDataY.push(y);
            lenY += 1;
        });
        visitAny([dataX], (x) => {
            flatDataX.push(x);
            lenX += 1;
        });
        assert(() => lenY === lenX, _lt("[[FUNCTION_NAME]] has mismatched argument count %s vs %s.", lenY.toString(), lenX.toString()));
        let count = 0;
        let sumY = 0;
        let sumX = 0;
        for (let i = 0; i < lenY; i++) {
            const valueY = flatDataY[i];
            const valueX = flatDataX[i];
            if (typeof valueY === "number" && typeof valueX === "number") {
                count += 1;
                sumY += valueY;
                sumX += valueX;
            }
        }
        assert(() => count !== 0 && (!isSample || count !== 1), _lt(`Evaluation of function [[FUNCTION_NAME]] caused a divide by zero error.`));
        const averageY = sumY / count;
        const averageX = sumX / count;
        let acc = 0;
        for (let i = 0; i < lenY; i++) {
            const valueY = flatDataY[i];
            const valueX = flatDataX[i];
            if (typeof valueY === "number" && typeof valueX === "number") {
                acc += (valueY - averageY) * (valueX - averageX);
            }
        }
        return acc / (count - (isSample ? 1 : 0));
    }
    function variance(args, isSample, textAs0) {
        let count = 0;
        let sum = 0;
        const reduceFunction = textAs0 ? reduceNumbersTextAs0 : reduceNumbers;
        sum = reduceFunction(args, (acc, a) => {
            count += 1;
            return acc + a;
        }, 0);
        assert(() => count !== 0 && (!isSample || count !== 1), _lt(`Evaluation of function [[FUNCTION_NAME]] caused a divide by zero error.`));
        const average = sum / count;
        return (reduceFunction(args, (acc, a) => acc + Math.pow(a - average, 2), 0) /
            (count - (isSample ? 1 : 0)));
    }
    function centile(data, percent, isInclusive) {
        const _percent = toNumber(percent);
        assert(() => (isInclusive ? 0 <= _percent && _percent <= 1 : 0 < _percent && _percent < 1), _lt(`Function [[FUNCTION_NAME]] parameter 2 value is out of range.`));
        let sortedArray = [];
        let index;
        let count = 0;
        visitAny(data, (d) => {
            if (typeof d === "number") {
                index = dichotomicPredecessorSearch(sortedArray, d);
                sortedArray.splice(index + 1, 0, d);
                count++;
            }
        });
        assert(() => count !== 0, _lt(`[[FUNCTION_NAME]] has no valid input data.`));
        let percentIndex = (count + (isInclusive ? -1 : 1)) * _percent;
        if (!isInclusive) {
            assert(() => 1 <= percentIndex && percentIndex <= count, _lt(`Function [[FUNCTION_NAME]] parameter 2 value is out of range.`));
            percentIndex--;
        }
        if (Number.isInteger(percentIndex)) {
            return sortedArray[percentIndex];
        }
        const indexSup = Math.ceil(percentIndex);
        const indexLow = Math.floor(percentIndex);
        return (sortedArray[indexSup] * (percentIndex - indexLow) +
            sortedArray[indexLow] * (indexSup - percentIndex));
    }
    // -----------------------------------------------------------------------------
    // AVEDEV
    // -----------------------------------------------------------------------------
    const AVEDEV = {
        description: _lt("Average magnitude of deviations from mean."),
        args: args(`
    value1 (number, range<number>) ${_lt("The first value or range of the sample.")}
    value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to include in the sample.")}
  `),
        returns: ["NUMBER"],
        compute: function (...values) {
            let count = 0;
            const sum = reduceNumbers(values, (acc, a) => {
                count += 1;
                return acc + a;
            }, 0);
            assert(() => count !== 0, _lt(`Evaluation of function [[FUNCTION_NAME]] caused a divide by zero error.`));
            const average = sum / count;
            return reduceNumbers(values, (acc, a) => acc + Math.abs(average - a), 0) / count;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // AVERAGE
    // -----------------------------------------------------------------------------
    const AVERAGE = {
        description: _lt(`Numerical average value in a dataset, ignoring text.`),
        args: args(`
      value1 (number, range<number>) ${_lt("The first value or range to consider when calculating the average value.")}
      value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to consider when calculating the average value.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (...values) {
            let count = 0;
            const sum = reduceNumbers(values, (acc, a) => {
                count += 1;
                return acc + a;
            }, 0);
            assert(() => count !== 0, _lt(`Evaluation of function [[FUNCTION_NAME]] caused a divide by zero error.`));
            return sum / count;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // AVERAGE.WEIGHTED
    // -----------------------------------------------------------------------------
    const rangeError = _lt(`[[FUNCTION_NAME]] has mismatched range sizes.`);
    const negativeWeightError = _lt(`[[FUNCTION_NAME]] expects the weight to be positive or equal to 0.`);
    const AVERAGE_WEIGHTED = {
        description: _lt(`Weighted average.`),
        args: args(`
      values (number, range<number>) ${_lt("Values to average.")}
      weights (number, range<number>) ${_lt("Weights for each corresponding value.")}
      additional_values (number, range<number>, repeating) ${_lt("Additional values to average.")}
      additional_weights (number, range<number>, repeating) ${_lt("Additional weights.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (...values) {
            let sum = 0;
            let count = 0;
            let value;
            let weight;
            assert(() => values.length % 2 === 0, _lt(`Wrong number of Argument[]. Expected an even number of Argument[].`));
            for (let n = 0; n < values.length - 1; n += 2) {
                value = values[n];
                weight = values[n + 1];
                // if (typeof value != typeof weight) {
                //   throw new Error(rangeError);
                // }
                if (Array.isArray(value)) {
                    assert(() => Array.isArray(weight), rangeError);
                    let dimColValue = value.length;
                    let dimLinValue = value[0].length;
                    assert(() => dimColValue === weight.length && dimLinValue === weight[0].length, rangeError);
                    for (let i = 0; i < dimColValue; i++) {
                        for (let j = 0; j < dimLinValue; j++) {
                            let subValue = value[i][j];
                            let subWeight = weight[i][j];
                            let subValueIsNumber = typeof subValue === "number";
                            let subWeightIsNumber = typeof subWeight === "number";
                            // typeof subValue or subWeight can be 'number' or 'undefined'
                            assert(() => subValueIsNumber === subWeightIsNumber, _lt(`[[FUNCTION_NAME]] expects number values.`));
                            if (subWeightIsNumber) {
                                assert(() => subWeight >= 0, negativeWeightError);
                                sum += subValue * subWeight;
                                count += subWeight;
                            }
                        }
                    }
                }
                else {
                    weight = toNumber(weight);
                    value = toNumber(value);
                    assert(() => weight >= 0, negativeWeightError);
                    sum += value * weight;
                    count += weight;
                }
            }
            assert(() => count !== 0, _lt(`Evaluation of function [[FUNCTION_NAME]] caused a divide by zero error.`));
            return sum / count;
        },
    };
    // -----------------------------------------------------------------------------
    // AVERAGEA
    // -----------------------------------------------------------------------------
    const AVERAGEA = {
        description: _lt(`Numerical average value in a dataset.`),
        args: args(`
      value1 (number, range<number>) ${_lt("The first value or range to consider when calculating the average value.")}
      value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to consider when calculating the average value.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (...values) {
            let count = 0;
            const sum = reduceNumbersTextAs0(values, (acc, a) => {
                count += 1;
                return acc + a;
            }, 0);
            assert(() => count !== 0, _lt(`Evaluation of function [[FUNCTION_NAME]] caused a divide by zero error.`));
            return sum / count;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // AVERAGEIF
    // -----------------------------------------------------------------------------
    const AVERAGEIF = {
        description: _lt(`Average of values depending on criteria.`),
        args: args(`
      criteria_range (range) ${_lt("The range to check against criterion.")}
      criterion (string) ${_lt("The pattern or test to apply to criteria_range.")}
      average_range (range, default=criteria_range) ${_lt("The range to average. If not included, criteria_range is used for the average instead.")}
    `),
        returns: ["NUMBER"],
        compute: function (criteriaRange, criterion, averageRange = undefined) {
            if (averageRange === undefined || averageRange === null) {
                averageRange = criteriaRange;
            }
            let count = 0;
            let sum = 0;
            visitMatchingRanges([criteriaRange, criterion], (i, j) => {
                const value = (averageRange || criteriaRange)[i][j];
                if (typeof value === "number") {
                    count += 1;
                    sum += value;
                }
            });
            assert(() => count !== 0, _lt(`Evaluation of function [[FUNCTION_NAME]] caused a divide by zero error.`));
            return sum / count;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // AVERAGEIFS
    // -----------------------------------------------------------------------------
    const AVERAGEIFS = {
        description: _lt(`Average of values depending on multiple criteria.`),
        args: args(`
      average_range (range) ${_lt("The range to average.")}
      criteria_range1 (range) ${_lt("The range to check against criterion1.")}
      criterion1 (string) ${_lt("The pattern or test to apply to criteria_range1.")}
      criteria_range2 (any, range, repeating) ${_lt("Additional criteria_range and criterion to check.")}
      criterion2 (string, repeating) ${_lt("The pattern or test to apply to criteria_range2.")}
    `),
        returns: ["NUMBER"],
        compute: function (averageRange, ...values) {
            let count = 0;
            let sum = 0;
            visitMatchingRanges(values, (i, j) => {
                const value = averageRange[i][j];
                if (typeof value === "number") {
                    count += 1;
                    sum += value;
                }
            });
            assert(() => count !== 0, _lt(`Evaluation of function [[FUNCTION_NAME]] caused a divide by zero error.`));
            return sum / count;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // COUNT
    // -----------------------------------------------------------------------------
    const COUNT = {
        description: _lt(`The number of numeric values in dataset.`),
        args: args(`
    value1 (number, range<number>) ${_lt("The first value or range to consider when counting.")}
    value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to consider when counting.")}
  `),
        returns: ["NUMBER"],
        compute: function (...values) {
            let count = 0;
            for (let n of values) {
                if (Array.isArray(n)) {
                    for (let i of n) {
                        for (let j of i) {
                            if (typeof j === "number") {
                                count += 1;
                            }
                        }
                    }
                }
                else if (typeof n !== "string" || isNumber(n) || parseDateTime(n)) {
                    count += 1;
                }
            }
            return count;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // COUNTA
    // -----------------------------------------------------------------------------
    const COUNTA = {
        description: _lt(`The number of values in a dataset.`),
        args: args(`
    value1 (any, range) ${_lt("The first value or range to consider when counting.")}
    value2 (any, range, repeating) ${_lt("Additional values or ranges to consider when counting.")}
  `),
        returns: ["NUMBER"],
        compute: function (...values) {
            return reduceAny(values, (acc, a) => (a !== undefined && a !== null ? acc + 1 : acc), 0);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // COVAR
    // -----------------------------------------------------------------------------
    // Note: Unlike the VAR function which corresponds to the variance over a sample (VAR.S),
    // the COVAR function corresponds to the covariance over an entire population (COVAR.P)
    const COVAR = {
        description: _lt(`The covariance of a dataset.`),
        args: args(`
    data_y (any, range) ${_lt("The range representing the array or matrix of dependent data.")}
    data_x (any, range) ${_lt("The range representing the array or matrix of independent data.")}
  `),
        returns: ["NUMBER"],
        compute: function (dataY, dataX) {
            return covariance(dataY, dataX, false);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // COVARIANCE.P
    // -----------------------------------------------------------------------------
    const COVARIANCE_P = {
        description: _lt(`The covariance of a dataset.`),
        args: args(`
    data_y (any, range) ${_lt("The range representing the array or matrix of dependent data.")}
    data_x (any, range) ${_lt("The range representing the array or matrix of independent data.")}
  `),
        returns: ["NUMBER"],
        compute: function (dataY, dataX) {
            return covariance(dataY, dataX, false);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // COVARIANCE.S
    // -----------------------------------------------------------------------------
    const COVARIANCE_S = {
        description: _lt(`The sample covariance of a dataset.`),
        args: args(`
    data_y (any, range) ${_lt("The range representing the array or matrix of dependent data.")}
    data_x (any, range) ${_lt("The range representing the array or matrix of independent data.")}
  `),
        returns: ["NUMBER"],
        compute: function (dataY, dataX) {
            return covariance(dataY, dataX, true);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // LARGE
    // -----------------------------------------------------------------------------
    const LARGE = {
        description: _lt("Nth largest element from a data set."),
        args: args(`
      data (any, range) ${_lt("Array or range containing the dataset to consider.")}
      n (number) ${_lt("The rank from largest to smallest of the element to return.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (data, n) {
            const _n = Math.trunc(toNumber(n));
            let largests = [];
            let index;
            let count = 0;
            visitAny([data], (d) => {
                if (typeof d === "number") {
                    index = dichotomicPredecessorSearch(largests, d);
                    largests.splice(index + 1, 0, d);
                    count++;
                    if (count > _n) {
                        largests.shift();
                        count--;
                    }
                }
            });
            const result = largests.shift();
            assert(() => result !== undefined, _lt(`[[FUNCTION_NAME]] has no valid input data.`));
            assert(() => count >= _n, _lt("Function [[FUNCTION_NAME]] parameter 2 value (%s) is out of range.", _n.toString()));
            return result;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // MAX
    // -----------------------------------------------------------------------------
    const MAX = {
        description: _lt("Maximum value in a numeric dataset."),
        args: args(`
      value1 (number, range<number>) ${_lt("The first value or range to consider when calculating the maximum value.")}
      value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to consider when calculating the maximum value.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (...values) {
            const result = reduceNumbers(values, (acc, a) => (acc < a ? a : acc), -Infinity);
            return result === -Infinity ? 0 : result;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // MAXA
    // -----------------------------------------------------------------------------
    const MAXA = {
        description: _lt("Maximum numeric value in a dataset."),
        args: args(`
      value1 (any, range) ${_lt("The first value or range to consider when calculating the maximum value.")}
      value2 (any, range, repeating) ${_lt("Additional values or ranges to consider when calculating the maximum value.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (...values) {
            const maxa = reduceNumbersTextAs0(values, (acc, a) => {
                return Math.max(a, acc);
            }, -Infinity);
            return maxa === -Infinity ? 0 : maxa;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // MAXIFS
    // -----------------------------------------------------------------------------
    const MAXIFS = {
        description: _lt("Returns the maximum value in a range of cells, filtered by a set of criteria."),
        args: args(`
      range (range) ${_lt("The range of cells from which the maximum will be determined.")}
      criteria_range1 (range) ${_lt("The range of cells over which to evaluate criterion1.")}
      criterion1 (string) ${_lt("The pattern or test to apply to criteria_range1, such that each cell that evaluates to TRUE will be included in the filtered set.")}
      criteria_range2 (any, range, repeating) ${_lt("Additional ranges over which to evaluate the additional criteria. The filtered set will be the intersection of the sets produced by each criterion-range pair.")}
      criterion2 (string, repeating) ${_lt("The pattern or test to apply to criteria_range2.")}
    `),
        returns: ["NUMBER"],
        compute: function (range, ...args) {
            let result = -Infinity;
            visitMatchingRanges(args, (i, j) => {
                const value = range[i][j];
                if (typeof value === "number") {
                    result = result < value ? value : result;
                }
            });
            return result === -Infinity ? 0 : result;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // MEDIAN
    // -----------------------------------------------------------------------------
    const MEDIAN = {
        description: _lt("Median value in a numeric dataset."),
        args: args(`
      value1 (any, range) ${_lt("The first value or range to consider when calculating the median value.")}
      value2 (any, range, repeating) ${_lt("Additional values or ranges to consider when calculating the median value.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (...values) {
            let data = [];
            visitNumbers(values, (arg) => {
                data.push(arg);
            });
            return centile(data, 0.5, true);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // MIN
    // -----------------------------------------------------------------------------
    const MIN = {
        description: _lt("Minimum value in a numeric dataset."),
        args: args(`
      value1 (number, range<number>) ${_lt("The first value or range to consider when calculating the minimum value.")}
      value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to consider when calculating the minimum value.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (...values) {
            const result = reduceNumbers(values, (acc, a) => (a < acc ? a : acc), Infinity);
            return result === Infinity ? 0 : result;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // MINA
    // -----------------------------------------------------------------------------
    const MINA = {
        description: _lt("Minimum numeric value in a dataset."),
        args: args(`
      value1 (number, range<number>) ${_lt("The first value or range to consider when calculating the minimum value.")}
      value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to consider when calculating the minimum value.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (...values) {
            const mina = reduceNumbersTextAs0(values, (acc, a) => {
                return Math.min(a, acc);
            }, Infinity);
            return mina === Infinity ? 0 : mina;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // MINIFS
    // -----------------------------------------------------------------------------
    const MINIFS = {
        description: _lt("Returns the minimum value in a range of cells, filtered by a set of criteria."),
        args: args(`
      range (range) ${_lt("The range of cells from which the minimum will be determined.")}
      criteria_range1 (range) ${_lt("The range of cells over which to evaluate criterion1.")}
      criterion1 (string) ${_lt("The pattern or test to apply to criteria_range1, such that each cell that evaluates to TRUE will be included in the filtered set.")}
      criteria_range2 (any, range, repeating) ${_lt("Additional ranges over which to evaluate the additional criteria. The filtered set will be the intersection of the sets produced by each criterion-range pair.")}
      criterion2 (string, repeating) ${_lt("The pattern or test to apply to criteria_range2.")}
    `),
        returns: ["NUMBER"],
        compute: function (range, ...args) {
            let result = Infinity;
            visitMatchingRanges(args, (i, j) => {
                const value = range[i][j];
                if (typeof value === "number") {
                    result = result > value ? value : result;
                }
            });
            return result === Infinity ? 0 : result;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // PERCENTILE
    // -----------------------------------------------------------------------------
    const PERCENTILE = {
        description: _lt("Value at a given percentile of a dataset."),
        args: args(`
      data (any, range) ${_lt("The array or range containing the dataset to consider.")}
      percentile (number) ${_lt("The percentile whose value within data will be calculated and returned.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (data, percentile) {
            return PERCENTILE_INC.compute(data, percentile);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // PERCENTILE.EXC
    // -----------------------------------------------------------------------------
    const PERCENTILE_EXC = {
        description: _lt("Value at a given percentile of a dataset exclusive of 0 and 1."),
        args: args(`
      data (any, range) ${_lt("The array or range containing the dataset to consider.")}
      percentile (number) ${_lt("The percentile, exclusive of 0 and 1, whose value within 'data' will be calculated and returned.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (data, percentile) {
            return centile([data], percentile, false);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // PERCENTILE.INC
    // -----------------------------------------------------------------------------
    const PERCENTILE_INC = {
        description: _lt("Value at a given percentile of a dataset."),
        args: args(`
      data (any, range) ${_lt("The array or range containing the dataset to consider.")}
      percentile (number) ${_lt("The percentile whose value within data will be calculated and returned.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (data, percentile) {
            return centile([data], percentile, true);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // QUARTILE
    // -----------------------------------------------------------------------------
    const QUARTILE = {
        description: _lt("Value nearest to a specific quartile of a dataset."),
        args: args(`
      data (any, range) ${_lt("The array or range containing the dataset to consider.")}
      quartile_number (number) ${_lt("Which quartile value to return.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (data, quartileNumber) {
            return QUARTILE_INC.compute(data, quartileNumber);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // QUARTILE.EXC
    // -----------------------------------------------------------------------------
    const QUARTILE_EXC = {
        description: _lt("Value nearest to a specific quartile of a dataset exclusive of 0 and 4."),
        args: args(`
      data (any, range) ${_lt("The array or range containing the dataset to consider.")}
      quartile_number (number) ${_lt("Which quartile value, exclusive of 0 and 4, to return.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (data, quartileNumber) {
            const _quartileNumber = Math.trunc(toNumber(quartileNumber));
            return centile([data], 0.25 * _quartileNumber, false);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // QUARTILE.INC
    // -----------------------------------------------------------------------------
    const QUARTILE_INC = {
        description: _lt("Value nearest to a specific quartile of a dataset."),
        args: args(`
      data (any, range) ${_lt("The array or range containing the dataset to consider.")}
      quartile_number (number) ${_lt("Which quartile value to return.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (data, quartileNumber) {
            const _quartileNumber = Math.trunc(toNumber(quartileNumber));
            return centile([data], 0.25 * _quartileNumber, true);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // SMALL
    // -----------------------------------------------------------------------------
    const SMALL = {
        description: _lt("Nth smallest element in a data set."),
        args: args(`
      data (any, range) ${_lt("The array or range containing the dataset to consider.")}
      n (number) ${_lt("The rank from smallest to largest of the element to return.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (data, n) {
            const _n = Math.trunc(toNumber(n));
            let largests = [];
            let index;
            let count = 0;
            visitAny([data], (d) => {
                if (typeof d === "number") {
                    index = dichotomicPredecessorSearch(largests, d);
                    largests.splice(index + 1, 0, d);
                    count++;
                    if (count > _n) {
                        largests.pop();
                        count--;
                    }
                }
            });
            const result = largests.pop();
            assert(() => result !== undefined, _lt(`[[FUNCTION_NAME]] has no valid input data.`));
            assert(() => count >= _n, _lt("Function [[FUNCTION_NAME]] parameter 2 value (%s) is out of range.", _n.toString()));
            return result;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // STDEV
    // -----------------------------------------------------------------------------
    const STDEV = {
        description: _lt("Standard deviation."),
        args: args(`
      value1 (number, range<number>) ${_lt("The first value or range of the sample.")}
      value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to include in the sample.")}
    `),
        returns: ["NUMBER"],
        compute: function (...values) {
            return Math.sqrt(VAR.compute(...values));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // STDEV.P
    // -----------------------------------------------------------------------------
    const STDEV_P = {
        description: _lt("Standard deviation of entire population."),
        args: args(`
      value1 (number, range<number>) ${_lt("The first value or range of the population.")}
      value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to include in the population.")}
    `),
        returns: ["NUMBER"],
        compute: function (...values) {
            return Math.sqrt(VAR_P.compute(...values));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // STDEV.S
    // -----------------------------------------------------------------------------
    const STDEV_S = {
        description: _lt("Standard deviation."),
        args: args(`
      value1 (number, range<number>) ${_lt("The first value or range of the sample.")}
      value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to include in the sample.")}
    `),
        returns: ["NUMBER"],
        compute: function (...values) {
            return Math.sqrt(VAR_S.compute(...values));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // STDEVA
    // -----------------------------------------------------------------------------
    const STDEVA = {
        description: _lt("Standard deviation of sample (text as 0)."),
        args: args(`
    value1 (number, range<number>) ${_lt("The first value or range of the sample.")}
    value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to include in the sample.")}
  `),
        returns: ["NUMBER"],
        compute: function (...values) {
            return Math.sqrt(VARA.compute(...values));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // STDEVP
    // -----------------------------------------------------------------------------
    const STDEVP = {
        description: _lt("Standard deviation of entire population."),
        args: args(`
    value1 (number, range<number>) ${_lt("The first value or range of the population.")}
    value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to include in the population.")}
  `),
        returns: ["NUMBER"],
        compute: function (...values) {
            return Math.sqrt(VARP.compute(...values));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // STDEVPA
    // -----------------------------------------------------------------------------
    const STDEVPA = {
        description: _lt("Standard deviation of entire population (text as 0)."),
        args: args(`
    value1 (number, range<number>) ${_lt("The first value or range of the population.")}
    value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to include in the population.")}
  `),
        returns: ["NUMBER"],
        compute: function (...values) {
            return Math.sqrt(VARPA.compute(...values));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // VAR
    // -----------------------------------------------------------------------------
    const VAR = {
        description: _lt("Variance."),
        args: args(`
      value1 (number, range<number>) ${_lt("The first value or range of the sample.")}
      value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to include in the sample.")}
    `),
        returns: ["NUMBER"],
        compute: function (...values) {
            return variance(values, true, false);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // VAR.P
    // -----------------------------------------------------------------------------
    const VAR_P = {
        description: _lt("Variance of entire population."),
        args: args(`
      value1 (number, range<number>) ${_lt("The first value or range of the population.")}
      value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to include in the population.")}
    `),
        returns: ["NUMBER"],
        compute: function (...values) {
            return variance(values, false, false);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // VAR.S
    // -----------------------------------------------------------------------------
    const VAR_S = {
        description: _lt("Variance."),
        args: args(`
      value1 (number, range<number>) ${_lt("The first value or range of the sample.")}
      value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to include in the sample.")}
    `),
        returns: ["NUMBER"],
        compute: function (...values) {
            return variance(values, true, false);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // VARA
    // -----------------------------------------------------------------------------
    const VARA = {
        description: _lt("Variance of sample (text as 0)."),
        args: args(`
    value1 (number, range<number>) ${_lt("The first value or range of the sample.")}
    value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to include in the sample.")}
  `),
        returns: ["NUMBER"],
        compute: function (...values) {
            return variance(values, true, true);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // VARP
    // -----------------------------------------------------------------------------
    const VARP = {
        description: _lt("Variance of entire population."),
        args: args(`
    value1 (number, range<number>) ${_lt("The first value or range of the population.")}
    value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to include in the population.")}
  `),
        returns: ["NUMBER"],
        compute: function (...values) {
            return variance(values, false, false);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // VARPA
    // -----------------------------------------------------------------------------
    const VARPA = {
        description: _lt("Variance of entire population (text as 0)."),
        args: args(`
    value1 (number, range<number>) ${_lt("The first value or range of the population.")}
    value2 (number, range<number>, repeating) ${_lt("Additional values or ranges to include in the population.")}
  `),
        returns: ["NUMBER"],
        compute: function (...values) {
            return variance(values, false, true);
        },
        isExported: true,
    };

    var statistical = /*#__PURE__*/Object.freeze({
        __proto__: null,
        AVEDEV: AVEDEV,
        AVERAGE: AVERAGE,
        AVERAGE_WEIGHTED: AVERAGE_WEIGHTED,
        AVERAGEA: AVERAGEA,
        AVERAGEIF: AVERAGEIF,
        AVERAGEIFS: AVERAGEIFS,
        COUNT: COUNT,
        COUNTA: COUNTA,
        COVAR: COVAR,
        COVARIANCE_P: COVARIANCE_P,
        COVARIANCE_S: COVARIANCE_S,
        LARGE: LARGE,
        MAX: MAX,
        MAXA: MAXA,
        MAXIFS: MAXIFS,
        MEDIAN: MEDIAN,
        MIN: MIN,
        MINA: MINA,
        MINIFS: MINIFS,
        PERCENTILE: PERCENTILE,
        PERCENTILE_EXC: PERCENTILE_EXC,
        PERCENTILE_INC: PERCENTILE_INC,
        QUARTILE: QUARTILE,
        QUARTILE_EXC: QUARTILE_EXC,
        QUARTILE_INC: QUARTILE_INC,
        SMALL: SMALL,
        STDEV: STDEV,
        STDEV_P: STDEV_P,
        STDEV_S: STDEV_S,
        STDEVA: STDEVA,
        STDEVP: STDEVP,
        STDEVPA: STDEVPA,
        VAR: VAR,
        VAR_P: VAR_P,
        VAR_S: VAR_S,
        VARA: VARA,
        VARP: VARP,
        VARPA: VARPA
    });

    function getMatchingCells(database, field, criteria) {
        // Example
        var _a;
        // # DATABASE             # CRITERIA          # field = "C"
        //
        // | A | B | C |          | A | C |
        // |===========|          |=======|
        // | 1 | x | j |          |<2 | j |
        // | 1 | Z | k |          |   | 7 |
        // | 5 | y | 7 |
        // 1 - Select coordinates of database columns ----------------------------------------------------
        const indexColNameDB = new Map();
        const dimRowDB = database.length;
        for (let indexCol = dimRowDB - 1; indexCol >= 0; indexCol--) {
            indexColNameDB.set(toString(database[indexCol][0]).toUpperCase(), indexCol);
        }
        // Example continuation: indexColNameDB = {"A" => 0, "B" => 1, "C" => 2}
        // 2 - Check if the field parameter exists in the column names of the database -------------------
        // field may either be a text label corresponding to a column header in the
        // first row of database or a numeric index indicating which column to consider,
        // where the first column has the value 1.
        if (typeof field !== "number" && typeof field !== "string") {
            throw new Error(_lt("The field must be a number or a string"));
        }
        let index;
        if (typeof field === "number") {
            index = Math.trunc(field) - 1;
            if (index < 0 || dimRowDB - 1 < index) {
                throw new Error(_lt("The field (%s) must be one of %s or must be a number between 1 and %s inclusive.", field.toString(), dimRowDB.toString()));
            }
        }
        else {
            const colName = toString(field).toUpperCase();
            index = (_a = indexColNameDB.get(colName)) !== null && _a !== void 0 ? _a : -1;
            if (index === -1) {
                throw new Error(_lt("The field (%s) must be one of %s.", toString(field), [...indexColNameDB.keys()].toString()));
            }
        }
        // Example continuation: index = 2
        // 3 - For each criteria row, find database row that correspond ----------------------------------
        const dimColCriteria = criteria[0].length;
        if (dimColCriteria < 2) {
            throw new Error(_lt("The criteria range contains %s row, it must be at least 2 rows.", dimColCriteria.toString()));
        }
        let matchingRows = new Set();
        const dimColDB = database[0].length;
        for (let indexRow = 1; indexRow < dimColCriteria; indexRow++) {
            let args = [];
            let existColNameDB = true;
            for (let indexCol = 0; indexCol < criteria.length; indexCol++) {
                const currentName = toString(criteria[indexCol][0]).toUpperCase();
                const indexColDB = indexColNameDB.get(currentName);
                const criter = criteria[indexCol][indexRow];
                if (criter !== undefined) {
                    if (indexColDB !== undefined) {
                        args.push([database[indexColDB].slice(1, dimColDB)]);
                        args.push(criter);
                    }
                    else {
                        existColNameDB = false;
                        break;
                    }
                }
            }
            // Example continuation: args1 = [[1,1,5], "<2", ["j","k",7], "j"]
            // Example continuation: args2 = [["j","k",7], "7"]
            if (existColNameDB) {
                if (args.length > 0) {
                    visitMatchingRanges(args, (i, j) => {
                        matchingRows.add(j);
                    }, true);
                }
                else {
                    // return indices of each database row when a criteria table row is void
                    matchingRows = new Set(Array(dimColDB - 1).keys());
                    break;
                }
            }
        }
        // Example continuation: matchingRows = {0, 2}
        // 4 - return for each database row corresponding, the cells corresponding to the field parameter
        const fieldCol = database[index];
        // Example continuation:: fieldCol = ["C", "j", "k", 7]
        const matchingCells = [...matchingRows].map((x) => fieldCol[x + 1]);
        // Example continuation:: matchingCells = ["j", 7]
        return matchingCells;
    }
    const databaseArgs = args(`
  database (range) ${_lt("The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.")}
  field (any) ${_lt("Indicates which column in database contains the values to be extracted and operated on.")}
  criteria (range) ${_lt("An array or range containing zero or more criteria to filter the database values by before operating.")}
`);
    // -----------------------------------------------------------------------------
    // DAVERAGE
    // -----------------------------------------------------------------------------
    const DAVERAGE = {
        description: _lt("Average of a set of values from a table-like range."),
        args: databaseArgs,
        returns: ["NUMBER"],
        compute: function (database, field, criteria) {
            const cells = getMatchingCells(database, field, criteria);
            return AVERAGE.compute([cells]);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // DCOUNT
    // -----------------------------------------------------------------------------
    const DCOUNT = {
        description: _lt("Counts values from a table-like range."),
        args: databaseArgs,
        returns: ["NUMBER"],
        compute: function (database, field, criteria) {
            const cells = getMatchingCells(database, field, criteria);
            return COUNT.compute([cells]);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // DCOUNTA
    // -----------------------------------------------------------------------------
    const DCOUNTA = {
        description: _lt("Counts values and text from a table-like range."),
        args: databaseArgs,
        returns: ["NUMBER"],
        compute: function (database, field, criteria) {
            const cells = getMatchingCells(database, field, criteria);
            return COUNTA.compute([cells]);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // DGET
    // -----------------------------------------------------------------------------
    const DGET = {
        description: _lt("Single value from a table-like range."),
        args: databaseArgs,
        returns: ["NUMBER"],
        compute: function (database, field, criteria) {
            const cells = getMatchingCells(database, field, criteria);
            assert(() => cells.length === 1, _lt("More than one match found in DGET evaluation."));
            return cells[0];
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // DMAX
    // -----------------------------------------------------------------------------
    const DMAX = {
        description: _lt("Maximum of values from a table-like range."),
        args: databaseArgs,
        returns: ["NUMBER"],
        compute: function (database, field, criteria) {
            const cells = getMatchingCells(database, field, criteria);
            return MAX.compute([cells]);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // DMIN
    // -----------------------------------------------------------------------------
    const DMIN = {
        description: _lt("Minimum of values from a table-like range."),
        args: databaseArgs,
        returns: ["NUMBER"],
        compute: function (database, field, criteria) {
            const cells = getMatchingCells(database, field, criteria);
            return MIN.compute([cells]);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // DPRODUCT
    // -----------------------------------------------------------------------------
    const DPRODUCT = {
        description: _lt("Product of values from a table-like range."),
        args: databaseArgs,
        returns: ["NUMBER"],
        compute: function (database, field, criteria) {
            const cells = getMatchingCells(database, field, criteria);
            return PRODUCT.compute([cells]);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // DSTDEV
    // -----------------------------------------------------------------------------
    const DSTDEV = {
        description: _lt("Standard deviation of population sample from table."),
        args: databaseArgs,
        returns: ["NUMBER"],
        compute: function (database, field, criteria) {
            const cells = getMatchingCells(database, field, criteria);
            return STDEV.compute([cells]);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // DSTDEVP
    // -----------------------------------------------------------------------------
    const DSTDEVP = {
        description: _lt("Standard deviation of entire population from table."),
        args: databaseArgs,
        returns: ["NUMBER"],
        compute: function (database, field, criteria) {
            const cells = getMatchingCells(database, field, criteria);
            return STDEVP.compute([cells]);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // DSUM
    // -----------------------------------------------------------------------------
    const DSUM = {
        description: _lt("Sum of values from a table-like range."),
        args: databaseArgs,
        returns: ["NUMBER"],
        compute: function (database, field, criteria) {
            const cells = getMatchingCells(database, field, criteria);
            return SUM.compute([cells]);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // DVAR
    // -----------------------------------------------------------------------------
    const DVAR = {
        description: _lt("Variance of population sample from table-like range."),
        args: databaseArgs,
        returns: ["NUMBER"],
        compute: function (database, field, criteria) {
            const cells = getMatchingCells(database, field, criteria);
            return VAR.compute([cells]);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // DVARP
    // -----------------------------------------------------------------------------
    const DVARP = {
        description: _lt("Variance of a population from a table-like range."),
        args: databaseArgs,
        returns: ["NUMBER"],
        compute: function (database, field, criteria) {
            const cells = getMatchingCells(database, field, criteria);
            return VARP.compute([cells]);
        },
        isExported: true,
    };

    var database = /*#__PURE__*/Object.freeze({
        __proto__: null,
        DAVERAGE: DAVERAGE,
        DCOUNT: DCOUNT,
        DCOUNTA: DCOUNTA,
        DGET: DGET,
        DMAX: DMAX,
        DMIN: DMIN,
        DPRODUCT: DPRODUCT,
        DSTDEV: DSTDEV,
        DSTDEVP: DSTDEVP,
        DSUM: DSUM,
        DVAR: DVAR,
        DVARP: DVARP
    });

    const INITIAL_1900_DAY = new Date(1899, 11, 30);
    const DEFAULT_TYPE = 1;
    const DEFAULT_WEEKEND = 1;
    function isLeapYear(year) {
        const _year = Math.trunc(year);
        return (_year % 4 === 0 && _year % 100 != 0) || _year % 400 == 0;
    }
    // -----------------------------------------------------------------------------
    // DATE
    // -----------------------------------------------------------------------------
    const DATE = {
        description: _lt("Converts year/month/day into a date."),
        args: args(`
    year (number) ${_lt("The year component of the date.")}
    month (number) ${_lt("The month component of the date.")}
    day (number) ${_lt("The day component of the date.")}
    `),
        returns: ["DATE"],
        returnFormat: { specificFormat: "m/d/yyyy" },
        compute: function (year, month, day) {
            let _year = Math.trunc(toNumber(year));
            const _month = Math.trunc(toNumber(month));
            const _day = Math.trunc(toNumber(day));
            // For years less than 0 or greater than 10000, return #ERROR.
            assert(() => 0 <= _year && _year <= 9999, _lt("The year (%s) must be between 0 and 9999 inclusive.", _year.toString()));
            // Between 0 and 1899, we add that value to 1900 to calculate the year
            if (_year < 1900) {
                _year += 1900;
            }
            const jsDate = new Date(_year, _month - 1, _day);
            const delta = jsDate.getTime() - INITIAL_1900_DAY.getTime();
            assert(() => delta >= 0, _lt(`The function [[FUNCTION_NAME]] result must be greater than or equal 01/01/1900.`));
            return Math.round(delta / 86400000);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // DATEVALUE
    // -----------------------------------------------------------------------------
    const DATEVALUE = {
        description: _lt("Converts a date string to a date value."),
        args: args(`
      date_string (string) ${_lt("The string representing the date.")}
    `),
        returns: ["NUMBER"],
        compute: function (dateString) {
            const _dateString = toString(dateString);
            const internalDate = parseDateTime(_dateString);
            assert(() => internalDate !== null, _lt("The date_string (%s) cannot be parsed to date/time.", _dateString.toString()));
            return Math.trunc(internalDate.value);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // DAY
    // -----------------------------------------------------------------------------
    const DAY = {
        description: _lt("Day of the month that a specific date falls on."),
        args: args(`
      date (string) ${_lt("The date from which to extract the day.")}
    `),
        returns: ["NUMBER"],
        compute: function (date) {
            return toJsDate(date).getDate();
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // DAYS
    // -----------------------------------------------------------------------------
    const DAYS = {
        description: _lt("Number of days between two dates."),
        args: args(`
      end_date (date) ${_lt("The end of the date range.")}
      start_date (date) ${_lt("The start of the date range.")}
    `),
        returns: ["NUMBER"],
        compute: function (endDate, startDate) {
            const _endDate = toJsDate(endDate);
            const _startDate = toJsDate(startDate);
            const dateDif = _endDate.getTime() - _startDate.getTime();
            return Math.round(dateDif / 86400000);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // EDATE
    // -----------------------------------------------------------------------------
    const EDATE = {
        description: _lt("Date a number of months before/after another date."),
        args: args(`
    start_date (date) ${_lt("The date from which to calculate the result.")}
    months (number) ${_lt("The number of months before (negative) or after (positive) 'start_date' to calculate.")}
    `),
        returns: ["DATE"],
        returnFormat: { specificFormat: "m/d/yyyy" },
        compute: function (startDate, months) {
            const _startDate = toJsDate(startDate);
            const _months = Math.trunc(toNumber(months));
            const yStart = _startDate.getFullYear();
            const mStart = _startDate.getMonth();
            const dStart = _startDate.getDate();
            const jsDate = new Date(yStart, mStart + _months, dStart);
            const delta = jsDate.getTime() - INITIAL_1900_DAY.getTime();
            return Math.round(delta / 86400000);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // EOMONTH
    // -----------------------------------------------------------------------------
    const EOMONTH = {
        description: _lt("Last day of a month before or after a date."),
        args: args(`
    start_date (date) ${_lt("The date from which to calculate the result.")}
    months (number) ${_lt("The number of months before (negative) or after (positive) 'start_date' to consider.")}
    `),
        returns: ["DATE"],
        returnFormat: { specificFormat: "m/d/yyyy" },
        compute: function (startDate, months) {
            const _startDate = toJsDate(startDate);
            const _months = Math.trunc(toNumber(months));
            const yStart = _startDate.getFullYear();
            const mStart = _startDate.getMonth();
            const jsDate = new Date(yStart, mStart + _months + 1, 0);
            const delta = jsDate.getTime() - INITIAL_1900_DAY.getTime();
            return Math.round(delta / 86400000);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // HOUR
    // -----------------------------------------------------------------------------
    const HOUR = {
        description: _lt("Hour component of a specific time."),
        args: args(`
    time (date) ${_lt("The time from which to calculate the hour component.")}
    `),
        returns: ["NUMBER"],
        compute: function (date) {
            return toJsDate(date).getHours();
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ISOWEEKNUM
    // -----------------------------------------------------------------------------
    const ISOWEEKNUM = {
        description: _lt("ISO week number of the year."),
        args: args(`
    date (date) ${_lt("The date for which to determine the ISO week number. Must be a reference to a cell containing a date, a function returning a date type, or a number.")}
    `),
        returns: ["NUMBER"],
        compute: function (date) {
            const _date = toJsDate(date);
            const y = _date.getFullYear();
            // 1 - As the 1st week of a year can start the previous year or after the 1st
            // january we first look if the date is in the weeks of the current year, previous
            // year or year after.
            // A - We look for the current year, the first days of the first week
            // and the last days of the last week
            // The first week of the year is the week that contains the first
            // Thursday of the year.
            let firstThursday = 1;
            while (new Date(y, 0, firstThursday).getDay() !== 4) {
                firstThursday += 1;
            }
            const firstDayOfFirstWeek = new Date(y, 0, firstThursday - 3);
            // The last week of the year is the week that contains the last Thursday of
            // the year.
            let lastThursday = 31;
            while (new Date(y, 11, lastThursday).getDay() !== 4) {
                lastThursday -= 1;
            }
            const lastDayOfLastWeek = new Date(y, 11, lastThursday + 3);
            // B - If our date > lastDayOfLastWeek then it's in the weeks of the year after
            // If our date < firstDayOfFirstWeek then it's in the weeks of the year before
            let offsetYear;
            if (firstDayOfFirstWeek.getTime() <= _date.getTime()) {
                if (_date.getTime() <= lastDayOfLastWeek.getTime()) {
                    offsetYear = 0;
                }
                else {
                    offsetYear = 1;
                }
            }
            else {
                offsetYear = -1;
            }
            // 2 - now that the year is known, we are looking at the difference between
            // the first day of this year and the date. The difference in days divided by
            // 7 gives us the week number
            let firstDay;
            switch (offsetYear) {
                case 0:
                    firstDay = firstDayOfFirstWeek;
                    break;
                case 1:
                    // firstDay is the 1st day of the 1st week of the year after
                    // firstDay = lastDayOfLastWeek + 1 Day
                    firstDay = new Date(y, 11, lastThursday + 3 + 1);
                    break;
                case -1:
                    // firstDay is the 1st day of the 1st week of the previous year.
                    // The first week of the previous year is the week that contains the
                    // first Thursday of the previous year.
                    let firstThursdayPreviousYear = 1;
                    while (new Date(y - 1, 0, firstThursdayPreviousYear).getDay() !== 4) {
                        firstThursdayPreviousYear += 1;
                    }
                    firstDay = new Date(y - 1, 0, firstThursdayPreviousYear - 3);
                    break;
            }
            const dif = (_date.getTime() - firstDay.getTime()) / 86400000;
            return Math.floor(dif / 7) + 1;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // MINUTE
    // -----------------------------------------------------------------------------
    const MINUTE = {
        description: _lt("Minute component of a specific time."),
        args: args(`
      time (date) ${_lt("The time from which to calculate the minute component.")}
    `),
        returns: ["NUMBER"],
        compute: function (date) {
            return toJsDate(date).getMinutes();
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // MONTH
    // -----------------------------------------------------------------------------
    const MONTH = {
        description: _lt("Month of the year a specific date falls in"),
        args: args(`
      date (date) ${_lt("The date from which to extract the month.")}
    `),
        returns: ["NUMBER"],
        compute: function (date) {
            return toJsDate(date).getMonth() + 1;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // NETWORKDAYS
    // -----------------------------------------------------------------------------
    const NETWORKDAYS = {
        description: _lt("Net working days between two provided days."),
        args: args(`
      start_date (date) ${_lt("The start date of the period from which to calculate the number of net working days.")}
      end_date (date) ${_lt("The end date of the period from which to calculate the number of net working days.")}
      holidays (date, range<date>, optional) ${_lt("A range or array constant containing the date serial numbers to consider holidays.")}
    `),
        returns: ["NUMBER"],
        compute: function (startDate, endDate, holidays = undefined) {
            return NETWORKDAYS_INTL.compute(startDate, endDate, 1, holidays);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // NETWORKDAYS.INTL
    // -----------------------------------------------------------------------------
    /**
     * Transform weekend Spreadsheet information into Date Day JavaScript information.
     * Take string (String method) or number (Number method), return array of numbers.
     *
     * String method: weekends can be specified using seven 0’s and 1’s, where the
     * first number in the set represents Monday and the last number is for Sunday.
     * A zero means that the day is a work day, a 1 means that the day is a weekend.
     * For example, “0000011” would mean Saturday and Sunday are weekends.
     *
     * Number method: instead of using the string method above, a single number can
     * be used. 1 = Saturday/Sunday are weekends, 2 = Sunday/Monday, and this pattern
     * repeats until 7 = Friday/Saturday. 11 = Sunday is the only weekend, 12 = Monday
     * is the only weekend, and this pattern repeats until 17 = Saturday is the only
     * weekend.
     *
     * Example:
     * - 11 return [0] (correspond to Sunday)
     * - 12 return [1] (correspond to Monday)
     * - 3 return [1,2] (correspond to Monday and Tuesday)
     * - "0101010" return [2,4,6] (correspond to Tuesday, Thursday and Saturday)
     */
    function weekendToDayNumber(weekend) {
        // case "string"
        if (typeof weekend === "string") {
            assert(() => {
                if (weekend.length !== 7) {
                    return false;
                }
                for (let day of weekend) {
                    if (day !== "0" && day !== "1") {
                        return false;
                    }
                }
                return true;
            }, _lt('When weekend is a string (%s) it must be composed of "0" or "1".', weekend));
            let result = [];
            for (let i = 0; i < 7; i++) {
                if (weekend[i] === "1") {
                    result.push((i + 1) % 7);
                }
            }
            return result;
        }
        //case "number"
        if (typeof weekend === "number") {
            assert(() => (1 <= weekend && weekend <= 7) || (11 <= weekend && weekend <= 17), _lt("The weekend (%s) must be a string or a number in the range 1-7 or 11-17.", weekend.toString()));
            // case 1 <= weekend <= 7
            if (weekend <= 7) {
                // 1 = Saturday/Sunday are weekends
                // 2 = Sunday/Monday
                // ...
                // 7 = Friday/Saturday.
                return [weekend - 2 === -1 ? 6 : weekend - 2, weekend - 1];
            }
            // case 11 <= weekend <= 17
            // 11 = Sunday is the only weekend
            // 12 = Monday is the only weekend
            // ...
            // 17 = Saturday is the only weekend.
            return [weekend - 11];
        }
        throw Error(_lt("The weekend (%s) must be a number or a string.", weekend.toString()));
    }
    const NETWORKDAYS_INTL = {
        description: _lt("Net working days between two dates (specifying weekends)."),
        args: args(`
      start_date (date) ${_lt("The start date of the period from which to calculate the number of net working days.")}
      end_date (date) ${_lt("The end date of the period from which to calculate the number of net working days.")}
      weekend (any, default=${DEFAULT_WEEKEND}) ${_lt("A number or string representing which days of the week are considered weekends.")}
      holidays (date, range<date>, optional) ${_lt("A range or array constant containing the dates to consider as holidays.")}
    `),
        returns: ["NUMBER"],
        compute: function (startDate, endDate, weekend = DEFAULT_WEEKEND, holidays = undefined) {
            const _startDate = toJsDate(startDate);
            const _endDate = toJsDate(endDate);
            const daysWeekend = weekendToDayNumber(weekend);
            let timesHoliday = new Set();
            if (holidays !== undefined) {
                visitAny([holidays], (h) => {
                    const holiday = toJsDate(h);
                    timesHoliday.add(holiday.getTime());
                });
            }
            const invertDate = _startDate.getTime() > _endDate.getTime();
            const stopDate = new Date((invertDate ? _startDate : _endDate).getTime());
            let stepDate = new Date((invertDate ? _endDate : _startDate).getTime());
            const timeStopDate = stopDate.getTime();
            let timeStepDate = stepDate.getTime();
            let netWorkingDay = 0;
            while (timeStepDate <= timeStopDate) {
                if (!daysWeekend.includes(stepDate.getDay()) && !timesHoliday.has(timeStepDate)) {
                    netWorkingDay += 1;
                }
                stepDate.setDate(stepDate.getDate() + 1);
                timeStepDate = stepDate.getTime();
            }
            return invertDate ? -netWorkingDay : netWorkingDay;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // NOW
    // -----------------------------------------------------------------------------
    const NOW = {
        description: _lt("Current date and time as a date value."),
        args: [],
        returns: ["DATE"],
        returnFormat: { specificFormat: "m/d/yyyy hh:mm:ss" },
        compute: function () {
            let today = new Date();
            today.setMilliseconds(0);
            const delta = today.getTime() - INITIAL_1900_DAY.getTime();
            const time = today.getHours() / 24 + today.getMinutes() / 1440 + today.getSeconds() / 86400;
            return Math.floor(delta / 86400000) + time;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // SECOND
    // -----------------------------------------------------------------------------
    const SECOND = {
        description: _lt("Minute component of a specific time."),
        args: args(`
      time (date) ${_lt("The time from which to calculate the second component.")}
    `),
        returns: ["NUMBER"],
        compute: function (date) {
            return toJsDate(date).getSeconds();
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // TIME
    // -----------------------------------------------------------------------------
    const TIME = {
        description: _lt("Converts hour/minute/second into a time."),
        args: args(`
    hour (number) ${_lt("The hour component of the time.")}
    minute (number) ${_lt("The minute component of the time.")}
    second (number) ${_lt("The second component of the time.")}
    `),
        returns: ["DATE"],
        returnFormat: { specificFormat: "hh:mm:ss a" },
        compute: function (hour, minute, second) {
            let _hour = Math.trunc(toNumber(hour));
            let _minute = Math.trunc(toNumber(minute));
            let _second = Math.trunc(toNumber(second));
            _minute += Math.floor(_second / 60);
            _second = (_second % 60) + (_second < 0 ? 60 : 0);
            _hour += Math.floor(_minute / 60);
            _minute = (_minute % 60) + (_minute < 0 ? 60 : 0);
            _hour %= 24;
            assert(() => _hour >= 0, _lt(`The function [[FUNCTION_NAME]] result cannot be negative`));
            return _hour / 24 + _minute / (24 * 60) + _second / (24 * 60 * 60);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // TIMEVALUE
    // -----------------------------------------------------------------------------
    const TIMEVALUE = {
        description: _lt("Converts a time string into its serial number representation."),
        args: args(`
      time_string (string) ${_lt("The string that holds the time representation.")}
    `),
        returns: ["NUMBER"],
        compute: function (timeString) {
            const _timeString = toString(timeString);
            const internalDate = parseDateTime(_timeString);
            assert(() => internalDate !== null, _lt("The time_string (%s) cannot be parsed to date/time.", _timeString));
            const result = internalDate.value - Math.trunc(internalDate.value);
            return result < 0 ? 1 + result : result;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // TODAY
    // -----------------------------------------------------------------------------
    const TODAY = {
        description: _lt("Current date as a date value."),
        args: [],
        returns: ["DATE"],
        returnFormat: { specificFormat: "m/d/yyyy" },
        compute: function () {
            const today = new Date();
            const jsDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            const delta = jsDate.getTime() - INITIAL_1900_DAY.getTime();
            return Math.round(delta / 86400000);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // WEEKDAY
    // -----------------------------------------------------------------------------
    const WEEKDAY = {
        description: _lt("Day of the week of the date provided (as number)."),
        args: args(`
    date (date) ${_lt("The date for which to determine the day of the week. Must be a reference to a cell containing a date, a function returning a date type, or a number.")}
    type (number, default=${DEFAULT_TYPE}) ${_lt("A number indicating which numbering system to use to represent weekdays. By default, counts starting with Sunday = 1.")}
  `),
        returns: ["NUMBER"],
        compute: function (date, type = DEFAULT_TYPE) {
            const _date = toJsDate(date);
            const _type = Math.round(toNumber(type));
            const m = _date.getDay();
            assert(() => [1, 2, 3].includes(_type), _lt("The type (%s) must be 1, 2 or 3.", _type.toString()));
            if (_type === 1)
                return m + 1;
            if (_type === 2)
                return m === 0 ? 7 : m;
            return m === 0 ? 6 : m - 1;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // WEEKNUM
    // -----------------------------------------------------------------------------
    const WEEKNUM = {
        description: _lt("Week number of the year."),
        args: args(`
    date (date) ${_lt("The date for which to determine the week number. Must be a reference to a cell containing a date, a function returning a date type, or a number.")}
    type (number, default=${DEFAULT_TYPE}) ${_lt("A number representing the day that a week starts on. Sunday = 1.")}
    `),
        returns: ["NUMBER"],
        compute: function (date, type = DEFAULT_TYPE) {
            const _date = toJsDate(date);
            const _type = Math.round(toNumber(type));
            assert(() => _type === 1 || _type === 2 || (11 <= _type && _type <= 17) || _type === 21, _lt("The type (%s) is out of range.", _type.toString()));
            if (_type === 21) {
                return ISOWEEKNUM.compute(date);
            }
            let startDayOfWeek;
            if (_type === 1 || _type === 2) {
                startDayOfWeek = _type - 1;
            }
            else {
                // case 11 <= _type <= 17
                startDayOfWeek = _type - 10 === 7 ? 0 : _type - 10;
            }
            const y = _date.getFullYear();
            let dayStart = 1;
            let startDayOfFirstWeek = new Date(y, 0, dayStart);
            while (startDayOfFirstWeek.getDay() !== startDayOfWeek) {
                dayStart += 1;
                startDayOfFirstWeek = new Date(y, 0, dayStart);
            }
            const dif = (_date.getTime() - startDayOfFirstWeek.getTime()) / 86400000;
            if (dif < 0) {
                return 1;
            }
            return Math.floor(dif / 7) + (dayStart === 1 ? 1 : 2);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // WORKDAY
    // -----------------------------------------------------------------------------
    const WORKDAY = {
        description: _lt("Number of working days from start date."),
        args: args(`
      start_date (date) ${_lt("The date from which to begin counting.")}
      num_days (number) ${_lt("The number of working days to advance from start_date. If negative, counts backwards.")}
      holidays (date, range<date>, optional) ${_lt("A range or array constant containing the dates to consider holidays.")}
      `),
        returns: ["NUMBER"],
        returnFormat: { specificFormat: "m/d/yyyy" },
        compute: function (startDate, numDays, holidays = undefined) {
            return WORKDAY_INTL.compute(startDate, numDays, 1, holidays);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // WORKDAY.INTL
    // -----------------------------------------------------------------------------
    const WORKDAY_INTL = {
        description: _lt("Net working days between two dates (specifying weekends)."),
        args: args(`
      start_date (date) ${_lt("The date from which to begin counting.")}
      num_days (number) ${_lt("The number of working days to advance from start_date. If negative, counts backwards.")}
      weekend (any, default=${DEFAULT_WEEKEND}) ${_lt("A number or string representing which days of the week are considered weekends.")}
      holidays (date, range<date>, optional) ${_lt("A range or array constant containing the dates to consider holidays.")}
    `),
        returns: ["DATE"],
        returnFormat: { specificFormat: "m/d/yyyy" },
        compute: function (startDate, numDays, weekend = DEFAULT_WEEKEND, holidays = undefined) {
            let _startDate = toJsDate(startDate);
            let _numDays = Math.trunc(toNumber(numDays));
            if (typeof weekend === "string") {
                assert(() => weekend !== "1111111", _lt("The weekend (%s) must be different from '1111111'.", weekend));
            }
            const daysWeekend = weekendToDayNumber(weekend);
            let timesHoliday = new Set();
            if (holidays !== undefined) {
                visitAny([holidays], (h) => {
                    const holiday = toJsDate(h);
                    timesHoliday.add(holiday.getTime());
                });
            }
            let stepDate = new Date(_startDate.getTime());
            let timeStepDate = stepDate.getTime();
            const unitDay = Math.sign(_numDays);
            let stepDay = Math.abs(_numDays);
            while (stepDay > 0) {
                stepDate.setDate(stepDate.getDate() + unitDay);
                timeStepDate = stepDate.getTime();
                if (!daysWeekend.includes(stepDate.getDay()) && !timesHoliday.has(timeStepDate)) {
                    stepDay -= 1;
                }
            }
            const delta = timeStepDate - INITIAL_1900_DAY.getTime();
            return Math.round(delta / 86400000);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // YEAR
    // -----------------------------------------------------------------------------
    const YEAR = {
        description: _lt("Year specified by a given date."),
        args: args(`
    date (date) ${_lt("The date from which to extract the year.")}
    `),
        returns: ["NUMBER"],
        compute: function (date) {
            return toJsDate(date).getFullYear();
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // YEARFRAC
    // -----------------------------------------------------------------------------
    const DEFAULT_DAY_COUNT_CONVENTION$1 = 0;
    const YEARFRAC = {
        description: _lt("Exact number of years between two dates."),
        args: args(`
    start_date (date) ${_lt("The start date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type, or a number.")}
    end_date (date) ${_lt("The end date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type, or a number.")}
    day_count_convention (number, default=${DEFAULT_DAY_COUNT_CONVENTION$1}) ${_lt("An indicator of what day count method to use.")}
    `),
        returns: ["NUMBER"],
        compute: function (startDate, endDate, dayCountConvention = DEFAULT_DAY_COUNT_CONVENTION$1) {
            let _startDate = Math.trunc(toNumber(startDate));
            let _endDate = Math.trunc(toNumber(endDate));
            const _dayCountConvention = Math.trunc(toNumber(dayCountConvention));
            assert(() => _startDate >= 0, _lt("The start_date (%s) must be positive or null.", _startDate.toString()));
            assert(() => _endDate >= 0, _lt("The end_date (%s) must be positive or null.", _endDate.toString()));
            assert(() => 0 <= _dayCountConvention && _dayCountConvention <= 4, _lt("The day_count_convention (%s) must be between 0 and 4 inclusive.", _dayCountConvention.toString()));
            if (_startDate === _endDate) {
                return 0;
            }
            if (_startDate > _endDate) {
                const stack = _endDate;
                _endDate = _startDate;
                _startDate = stack;
            }
            const jsStartDate = toJsDate(_startDate);
            const jsEndDate = toJsDate(_endDate);
            let dayStart = jsStartDate.getDate();
            let dayEnd = jsEndDate.getDate();
            const monthStart = jsStartDate.getMonth(); // january is 0
            const monthEnd = jsEndDate.getMonth(); // january is 0
            const yearStart = jsStartDate.getFullYear();
            const yearEnd = jsEndDate.getFullYear();
            let yearsStart = 0;
            let yearsEnd = 0;
            switch (_dayCountConvention) {
                // 30/360 US convention --------------------------------------------------
                case 0:
                    if (dayStart === 31)
                        dayStart = 30;
                    if (dayStart === 30 && dayEnd === 31)
                        dayEnd = 30;
                    // If jsStartDate is the last day of February
                    if (monthStart === 1 && dayStart === (isLeapYear(yearStart) ? 29 : 28)) {
                        dayStart = 30;
                        // If jsEndDate is the last day of February
                        if (monthEnd === 1 && dayEnd === (isLeapYear(yearEnd) ? 29 : 28)) {
                            dayEnd = 30;
                        }
                    }
                    yearsStart = yearStart + (monthStart * 30 + dayStart) / 360;
                    yearsEnd = yearEnd + (monthEnd * 30 + dayEnd) / 360;
                    break;
                // actual/actual convention ----------------------------------------------
                case 1:
                    let daysInYear = 365;
                    const isSameYear = yearStart === yearEnd;
                    const isOneDeltaYear = yearStart + 1 === yearEnd;
                    const isMonthEndBigger = monthStart < monthEnd;
                    const isSameMonth = monthStart === monthEnd;
                    const isDayEndBigger = dayStart < dayEnd;
                    // |-----|  <-- one Year
                    // 'A' is start date
                    // 'B' is end date
                    if ((!isSameYear && !isOneDeltaYear) ||
                        (!isSameYear && isMonthEndBigger) ||
                        (!isSameYear && isSameMonth && isDayEndBigger)) {
                        // |---A-|-----|-B---|  <-- !isSameYear && !isOneDeltaYear
                        // |---A-|----B|-----|  <-- !isSameYear && isMonthEndBigger
                        // |---A-|---B-|-----|  <-- !isSameYear && isSameMonth && isDayEndBigger
                        let countYears = 0;
                        let countDaysInYears = 0;
                        for (let y = yearStart; y <= yearEnd; y++) {
                            countYears++;
                            countDaysInYears += isLeapYear(y) ? 366 : 365;
                        }
                        daysInYear = countDaysInYears / countYears;
                    }
                    else if (!isSameYear) {
                        // |-AF--|B----|-----|
                        if (isLeapYear(yearStart) && monthStart < 2) {
                            daysInYear = 366;
                        }
                        // |--A--|FB---|-----|
                        if (isLeapYear(yearEnd) && (monthEnd > 1 || (monthEnd === 1 && dayEnd === 29))) {
                            daysInYear = 366;
                        }
                    }
                    else {
                        // remaining cases:
                        //
                        // |-F-AB|-----|-----|
                        // |AB-F-|-----|-----|
                        // |A-F-B|-----|-----|
                        // if February 29 occurs between date1 (exclusive) and date2 (inclusive)
                        // daysInYear --> 366
                        if (isLeapYear(yearStart)) {
                            daysInYear = 366;
                        }
                    }
                    yearsStart = _startDate / daysInYear;
                    yearsEnd = _endDate / daysInYear;
                    break;
                // actual/360 convention -------------------------------------------------
                case 2:
                    yearsStart = _startDate / 360;
                    yearsEnd = _endDate / 360;
                    break;
                // actual/365 convention -------------------------------------------------
                case 3:
                    yearsStart = _startDate / 365;
                    yearsEnd = _endDate / 365;
                    break;
                // 30/360 European convention --------------------------------------------
                case 4:
                    if (dayStart === 31)
                        dayStart = 30;
                    if (dayEnd === 31)
                        dayEnd = 30;
                    yearsStart = yearStart + (monthStart * 30 + dayStart) / 360;
                    yearsEnd = yearEnd + (monthEnd * 30 + dayEnd) / 360;
                    break;
            }
            return yearsEnd - yearsStart;
        },
    };

    var date = /*#__PURE__*/Object.freeze({
        __proto__: null,
        DATE: DATE,
        DATEVALUE: DATEVALUE,
        DAY: DAY,
        DAYS: DAYS,
        EDATE: EDATE,
        EOMONTH: EOMONTH,
        HOUR: HOUR,
        ISOWEEKNUM: ISOWEEKNUM,
        MINUTE: MINUTE,
        MONTH: MONTH,
        NETWORKDAYS: NETWORKDAYS,
        NETWORKDAYS_INTL: NETWORKDAYS_INTL,
        NOW: NOW,
        SECOND: SECOND,
        TIME: TIME,
        TIMEVALUE: TIMEVALUE,
        TODAY: TODAY,
        WEEKDAY: WEEKDAY,
        WEEKNUM: WEEKNUM,
        WORKDAY: WORKDAY,
        WORKDAY_INTL: WORKDAY_INTL,
        YEAR: YEAR,
        YEARFRAC: YEARFRAC
    });

    const DEFAULT_DAY_COUNT_CONVENTION = 0;
    const DEFAULT_END_OR_BEGINNING = 0;
    function newtonMethod(func, derivFunc, startValue, interMax, epsMax = 1e-10) {
        let x = startValue;
        let newX;
        let xDelta;
        let y;
        let yEqual0 = false;
        let count = 0;
        do {
            y = func(x);
            newX = x - y / derivFunc(x);
            xDelta = Math.abs(newX - x);
            x = newX;
            yEqual0 = xDelta < epsMax || Math.abs(y) < epsMax;
            assert(() => count < interMax, _lt(`Function [[FUNCTION_NAME]] didn't find any result`));
            count++;
        } while (!yEqual0);
        return x;
    }
    // -----------------------------------------------------------------------------
    // DB
    // -----------------------------------------------------------------------------
    const DB = {
        description: _lt("Depreciation via declining balance method."),
        args: args(`
        cost (number) ${_lt("The initial cost of the asset.")}
        salvage (number) ${_lt("The value of the asset at the end of depreciation.")}
        life (number) ${_lt("The number of periods over which the asset is depreciated.")}
        period (number) ${_lt("The single period within life for which to calculate depreciation.")}
        month (number, optional) ${_lt("The number of months in the first year of depreciation.")}
    `),
        returns: ["NUMBER"],
        // to do: replace by dollar format
        returnFormat: { specificFormat: "#,##0.00" },
        compute: function (cost, salvage, life, period, ...args) {
            const _cost = toNumber(cost);
            const _salvage = toNumber(salvage);
            const _life = toNumber(life);
            const _period = Math.trunc(toNumber(period));
            const _month = args.length ? Math.trunc(toNumber(args[0])) : 12;
            const lifeLimit = _life + (_month === 12 ? 0 : 1);
            assert(() => _cost > 0, _lt("The cost (%s) must be strictly positive.", _cost.toString()));
            assert(() => _salvage >= 0, _lt("The salvage (%s) must be positive or null.", _salvage.toString()));
            assert(() => _life > 0, _lt("The life (%s) must be strictly positive.", _life.toString()));
            assert(() => _period > 0, _lt("The period (%s) must be strictly positive.", _period.toString()));
            assert(() => 1 <= _month && _month <= 12, _lt("The month (%s) must be between 1 and 12 inclusive.", _month.toString()));
            assert(() => _period <= lifeLimit, _lt("The period (%s) must be less than or equal to %s.", _period.toString(), lifeLimit.toString()));
            const monthPart = _month / 12;
            let rate = 1 - Math.pow(_salvage / _cost, 1 / _life);
            // round to 3 decimal places
            rate = Math.round(rate * 1000) / 1000;
            let before = _cost;
            let after = _cost * (1 - rate * monthPart);
            for (let i = 1; i < _period; i++) {
                before = after;
                after = before * (1 - rate);
                if (i === _life) {
                    after = before * (1 - rate * (1 - monthPart));
                }
            }
            return before - after;
        },
    };
    // -----------------------------------------------------------------------------
    // DURATION
    // -----------------------------------------------------------------------------
    const DURATION = {
        description: _lt("Number of periods for an investment to reach a value."),
        args: args(`
        settlement (date) ${_lt("The settlement date of the security, the date after issuance when the security is delivered to the buyer.")}
        maturity (date) ${_lt("The maturity or end date of the security, when it can be redeemed at face, or par value.")}
        rate (number) ${_lt("The annualized rate of interest.")}
        yield (number) ${_lt("The expected annual yield of the security.")}
        frequency (number) ${_lt("The number of interest or coupon payments per year (1, 2, or 4).")}
        day_count_convention (number, default=${DEFAULT_DAY_COUNT_CONVENTION} ) ${_lt("An indicator of what day count method to use.")}
    `),
        returns: ["NUMBER"],
        compute: function (settlement, maturity, rate, securityYield, frequency, dayCountConvention = DEFAULT_DAY_COUNT_CONVENTION) {
            dayCountConvention = dayCountConvention || 0;
            const start = Math.trunc(toNumber(settlement));
            const end = Math.trunc(toNumber(maturity));
            const _rate = toNumber(rate);
            const _yield = toNumber(securityYield);
            const _frequency = Math.trunc(toNumber(frequency));
            const _dayCountConvention = Math.trunc(toNumber(dayCountConvention));
            assert(() => start < end, _lt("The maturity (%s) must be strictly greater than the settlement (%s).", end.toString(), start.toString()));
            assert(() => _rate >= 0, _lt("The rate (%s) must be positive or null.", _rate.toString()));
            assert(() => _yield >= 0, _lt("The yield (%s) must be positive or null.", _yield.toString()));
            assert(() => [1, 2, 4].includes(_frequency), _lt("The frequency (%s) must be one of %s", _frequency.toString(), [1, 2, 4].toString()));
            assert(() => 0 <= _dayCountConvention && _dayCountConvention <= 4, _lt("The day_count_convention (%s) must be between 0 and 4 inclusive.", _dayCountConvention.toString()));
            const years = YEARFRAC.compute(start, end, _dayCountConvention);
            const timeFirstYear = years - Math.trunc(years) || 1 / _frequency;
            const nbrCoupons = Math.ceil(years * _frequency);
            // The DURATION function return the Macaulay duration
            // See example: https://en.wikipedia.org/wiki/Bond_duration#Formulas
            const cashFlowFromCoupon = _rate / _frequency;
            const yieldPerPeriod = _yield / _frequency;
            let count = 0;
            let sum = 0;
            for (let i = 1; i <= nbrCoupons; i++) {
                const cashFlowPerPeriod = cashFlowFromCoupon + (i === nbrCoupons ? 1 : 0);
                const presentValuePerPeriod = cashFlowPerPeriod / (1 + yieldPerPeriod) ** i;
                sum += (timeFirstYear + (i - 1) / _frequency) * presentValuePerPeriod;
                count += presentValuePerPeriod;
            }
            return count === 0 ? 0 : sum / count;
        },
    };
    // -----------------------------------------------------------------------------
    // FV
    // -----------------------------------------------------------------------------
    const DEFAULT_PRESENT_VALUE = 0;
    const FV = {
        description: _lt("Future value of an annuity investment."),
        args: args(`
  rate (number) ${_lt("The interest rate.")}
  number_of_periods (number) ${_lt("The number of payments to be made.")}
  payment_amount (number) ${_lt("The amount per period to be paid.")}
  present_value (number, default=${DEFAULT_PRESENT_VALUE}) ${_lt("The current value of the annuity.")}
  end_or_beginning (number, default=${DEFAULT_END_OR_BEGINNING}) ${_lt("Whether payments are due at the end (0) or beginning (1) of each period.")}
  `),
        returns: ["NUMBER"],
        // to do: replace by dollar format
        returnFormat: { specificFormat: "#,##0.00" },
        compute: function (rate, numberOfPeriods, paymentAmount, presentValue = DEFAULT_PRESENT_VALUE, endOrBeginning = DEFAULT_END_OR_BEGINNING) {
            presentValue = presentValue || 0;
            endOrBeginning = endOrBeginning || 0;
            const r = toNumber(rate);
            const n = toNumber(numberOfPeriods);
            const p = toNumber(paymentAmount);
            const pv = toNumber(presentValue);
            const type = toBoolean(endOrBeginning) ? 1 : 0;
            return r ? -pv * (1 + r) ** n - (p * (1 + r * type) * ((1 + r) ** n - 1)) / r : -(pv + p * n);
        },
    };
    // -----------------------------------------------------------------------------
    // IRR
    // -----------------------------------------------------------------------------
    const DEFAULT_RATE_GUESS = 0.1;
    const IRR = {
        description: _lt("Internal rate of return given periodic cashflows."),
        args: args(`
  cashflow_amounts (number, range<number>) ${_lt("An array or range containing the income or payments associated with the investment.")}
  rate_guess (number, default=${DEFAULT_RATE_GUESS}) ${_lt("An estimate for what the internal rate of return will be.")}
  `),
        returns: ["NUMBER"],
        returnFormat: { specificFormat: "0%" },
        compute: function (cashFlowAmounts, rateGuess = DEFAULT_RATE_GUESS) {
            const _rateGuess = toNumber(rateGuess);
            assert(() => _rateGuess > -1, _lt("The rate_guess (%s) must be strictly greater than -1.", _rateGuess.toString()));
            // check that values contains at least one positive value and one negative value
            // and extract number present in the cashFlowAmount argument
            let positive = false;
            let negative = false;
            let amounts = [];
            visitNumbers([cashFlowAmounts], (amount) => {
                if (amount > 0)
                    positive = true;
                if (amount < 0)
                    negative = true;
                amounts.push(amount);
            });
            assert(() => positive && negative, _lt("The cashflow_amounts must include negative and positive values."));
            const firstAmount = amounts.shift();
            // The result of IRR is the rate at which the NPV() function will return zero with the given values.
            // This algorithm uses the Newton's method on the NPV function to determine the result
            // Newton's method: https://en.wikipedia.org/wiki/Newton%27s_method
            // As the NPV function isn't continuous, we apply the Newton's method on the numerator of the NPV formula.
            function npvNumerator(rate, startValue, values) {
                const nbrValue = values.length;
                let i = 0;
                return values.reduce((acc, v) => {
                    i++;
                    return acc + v * rate ** (nbrValue - i);
                }, startValue * rate ** nbrValue);
            }
            function npvNumeratorDeriv(rate, startValue, values) {
                const nbrValue = values.length;
                let i = 0;
                return values.reduce((acc, v) => {
                    i++;
                    return acc + v * (nbrValue - i) * rate ** (nbrValue - i - 1);
                }, startValue * nbrValue * rate ** (nbrValue - 1));
            }
            function func(x) {
                return npvNumerator(x, firstAmount, amounts);
            }
            function derivFunc(x) {
                return npvNumeratorDeriv(x, firstAmount, amounts);
            }
            return newtonMethod(func, derivFunc, _rateGuess + 1, 20, 1e-5) - 1;
        },
    };
    // -----------------------------------------------------------------------------
    // MDURATION
    // -----------------------------------------------------------------------------
    const MDURATION = {
        description: _lt("Modified Macaulay duration."),
        args: args(`
        settlement (date) ${_lt("The settlement date of the security, the date after issuance when the security is delivered to the buyer.")}
        maturity (date) ${_lt("The maturity or end date of the security, when it can be redeemed at face, or par value.")}
        rate (number) ${_lt("The annualized rate of interest.")}
        yield (number) ${_lt("The expected annual yield of the security.")}
        frequency (number) ${_lt("The number of interest or coupon payments per year (1, 2, or 4).")}
        day_count_convention (number, default=${DEFAULT_DAY_COUNT_CONVENTION} ) ${_lt("An indicator of what day count method to use.")}
    `),
        returns: ["NUMBER"],
        compute: function (settlement, maturity, rate, securityYield, frequency, dayCountConvention = DEFAULT_DAY_COUNT_CONVENTION) {
            const duration = DURATION.compute(settlement, maturity, rate, securityYield, frequency, dayCountConvention);
            const y = toNumber(securityYield);
            const k = Math.trunc(toNumber(frequency));
            return duration / (1 + y / k);
        },
    };
    // -----------------------------------------------------------------------------
    // NPV
    // -----------------------------------------------------------------------------
    function npvResult(r, startValue, values) {
        let i = 0;
        return reduceNumbers(values, (acc, v) => {
            i++;
            return acc + v / (1 + r) ** i;
        }, startValue);
    }
    const NPV = {
        description: _lt("The net present value of an investment based on a series of periodic cash flows and a discount rate."),
        args: args(`
  discount (number) ${_lt("The discount rate of the investment over one period.")}
  cashflow1 (number, range<number>) ${_lt("The first future cash flow.")}
  cashflow2 (number, range<number>, repeating) ${_lt("Additional future cash flows.")}
  `),
        returns: ["NUMBER"],
        // to do: replace by dollar format
        returnFormat: { specificFormat: "#,##0.00" },
        compute: function (discount, ...values) {
            const _discount = toNumber(discount);
            assert(() => _discount !== -1, _lt("The discount (%s) must be different from -1.", _discount.toString()));
            return npvResult(_discount, 0, values);
        },
    };
    // -----------------------------------------------------------------------------
    // PDURATION
    // -----------------------------------------------------------------------------
    const PDURATION = {
        description: _lt("Computes the number of periods needed for an investment to reach a value."),
        args: args(`
  rate (number) ${_lt("The rate at which the investment grows each period.")}
  present_value (number) ${_lt("The investment's current value.")}
  future_value (number) ${_lt("The investment's desired future value.")}
  `),
        returns: ["NUMBER"],
        compute: function (rate, presentValue, futureValue) {
            const _rate = toNumber(rate);
            const _presentValue = toNumber(presentValue);
            const _futureValue = toNumber(futureValue);
            assert(() => _rate > 0, _lt("The rate (%s) must be strictly positive.", _rate.toString()));
            assert(() => _presentValue > 0, _lt("The present_value (%s) must be strictly positive.", _presentValue.toString()));
            assert(() => _futureValue > 0, _lt("The future_value (%s) must be strictly positive.", _futureValue.toString()));
            return (Math.log(_futureValue) - Math.log(_presentValue)) / Math.log(1 + _rate);
        },
    };
    // -----------------------------------------------------------------------------
    // PV
    // -----------------------------------------------------------------------------
    const DEFAULT_FUTURE_VALUE = 0;
    const PV = {
        description: _lt("Present value of an annuity investment."),
        args: args(`
  rate (number) ${_lt("The interest rate.")}
  number_of_periods (number) ${_lt("The number of payments to be made.")}
  payment_amount (number) ${_lt("The amount per period to be paid.")}
  future_value (number, default=${DEFAULT_FUTURE_VALUE}) ${_lt("The future value remaining after the final payment has been made.")}
  end_or_beginning (number, default=${DEFAULT_END_OR_BEGINNING}) ${_lt("Whether payments are due at the end (0) or beginning (1) of each period.")}
  `),
        returns: ["NUMBER"],
        // to do: replace by dollar format
        returnFormat: { specificFormat: "#,##0.00" },
        compute: function (rate, numberOfPeriods, paymentAmount, futureValue = DEFAULT_FUTURE_VALUE, endOrBeginning = DEFAULT_END_OR_BEGINNING) {
            futureValue = futureValue || 0;
            endOrBeginning = endOrBeginning || 0;
            const r = toNumber(rate);
            const n = toNumber(numberOfPeriods);
            const p = toNumber(paymentAmount);
            const fv = toNumber(futureValue);
            const type = toBoolean(endOrBeginning) ? 1 : 0;
            return r ? -((p * (1 + r * type) * ((1 + r) ** n - 1)) / r + fv) / (1 + r) ** n : -(fv + p * n);
        },
    };
    // -----------------------------------------------------------------------------
    // PRICE
    // -----------------------------------------------------------------------------
    const PRICE = {
        description: _lt("Price of a security paying periodic interest."),
        args: args(`
      settlement (date) ${_lt("The settlement date of the security, the date after issuance when the security is delivered to the buyer.")}
      maturity (date) ${_lt("The maturity or end date of the security, when it can be redeemed at face, or par value.")}
      rate (number) ${_lt("The annualized rate of interest.")}
      yield (number) ${_lt("The expected annual yield of the security.")}
      redemption (number) ${_lt("The redemption amount per 100 face value, or par.")}
      frequency (number) ${_lt("The number of interest or coupon payments per year (1, 2, or 4).")}
      day_count_convention (number, default=${DEFAULT_DAY_COUNT_CONVENTION} ) ${_lt("An indicator of what day count method to use.")}
    `),
        returns: ["NUMBER"],
        compute: function (settlement, maturity, rate, securityYield, redemption, frequency, dayCountConvention = DEFAULT_DAY_COUNT_CONVENTION) {
            dayCountConvention = dayCountConvention || 0;
            const _settlement = Math.trunc(toNumber(settlement));
            const _maturity = Math.trunc(toNumber(maturity));
            const _rate = toNumber(rate);
            const _yield = toNumber(securityYield);
            const _redemption = toNumber(redemption);
            const _frequency = Math.trunc(toNumber(frequency));
            const _dayCountConvention = Math.trunc(toNumber(dayCountConvention));
            assert(() => _maturity > _settlement, _lt("The maturity (%s) must be strictly greater than the settlement (%s).", _maturity.toString(), _settlement.toString()));
            assert(() => _rate >= 0, _lt("The rate (%s) must be positive or null.", _rate.toString()));
            assert(() => _yield >= 0, _lt("The yield (%s) must be positive or null.", _yield.toString()));
            assert(() => _redemption > 0, _lt("The redemption (%s) must be strictly positive.", _redemption.toString()));
            assert(() => [1, 2, 4].includes(_frequency), _lt("The frequency (%s) must be one of %s.", _frequency.toString(), [1, 2, 4].toString()));
            assert(() => 0 <= _dayCountConvention && _dayCountConvention <= 4, _lt("The day_count_convention (%s) must be between 0 and 4 inclusive.", _dayCountConvention.toString()));
            const years = YEARFRAC.compute(_settlement, _maturity, _dayCountConvention);
            const nbrRealCoupons = years * _frequency;
            const nbrFullCoupons = Math.ceil(nbrRealCoupons);
            const timeFirstCoupon = nbrRealCoupons - Math.floor(nbrRealCoupons) || 1;
            const yieldFactorPerPeriod = 1 + _yield / _frequency;
            const cashFlowFromCoupon = (100 * _rate) / _frequency;
            if (nbrFullCoupons === 1) {
                return ((cashFlowFromCoupon + _redemption) / ((timeFirstCoupon * _yield) / _frequency + 1) -
                    cashFlowFromCoupon * (1 - timeFirstCoupon));
            }
            let cashFlowsPresentValue = 0;
            for (let i = 1; i <= nbrFullCoupons; i++) {
                cashFlowsPresentValue +=
                    cashFlowFromCoupon / yieldFactorPerPeriod ** (i - 1 + timeFirstCoupon);
            }
            const redemptionPresentValue = _redemption / yieldFactorPerPeriod ** (nbrFullCoupons - 1 + timeFirstCoupon);
            return (redemptionPresentValue + cashFlowsPresentValue - cashFlowFromCoupon * (1 - timeFirstCoupon));
        },
    };
    // -----------------------------------------------------------------------------
    // YIELD
    // -----------------------------------------------------------------------------
    const YIELD = {
        description: _lt("Annual yield of a security paying periodic interest."),
        args: args(`
        settlement (date) ${_lt("The settlement date of the security, the date after issuance when the security is delivered to the buyer.")}
        maturity (date) ${_lt("The maturity or end date of the security, when it can be redeemed at face, or par value.")}
        rate (number) ${_lt("The annualized rate of interest.")}
        price (number) ${_lt("The price at which the security is bought per 100 face value.")}
        redemption (number) ${_lt("The redemption amount per 100 face value, or par.")}
        frequency (number) ${_lt("The number of interest or coupon payments per year (1, 2, or 4).")}
        day_count_convention (number, default=${DEFAULT_DAY_COUNT_CONVENTION} ) ${_lt("An indicator of what day count method to use.")}
    `),
        returns: ["NUMBER"],
        compute: function (settlement, maturity, rate, price, redemption, frequency, dayCountConvention = DEFAULT_DAY_COUNT_CONVENTION) {
            dayCountConvention = dayCountConvention || 0;
            const _settlement = Math.trunc(toNumber(settlement));
            const _maturity = Math.trunc(toNumber(maturity));
            const _rate = toNumber(rate);
            const _price = toNumber(price);
            const _redemption = toNumber(redemption);
            const _frequency = Math.trunc(toNumber(frequency));
            const _dayCountConvention = Math.trunc(toNumber(dayCountConvention));
            assert(() => _maturity > _settlement, _lt("The maturity (%s) must be strictly greater than the settlement (%s).", _maturity.toString(), _settlement.toString()));
            assert(() => _rate >= 0, _lt("The rate (%s) must be positive or null.", _rate.toString()));
            assert(() => _price > 0, _lt("The price (%s) must be strictly positive.", _price.toString()));
            assert(() => _redemption > 0, _lt("The redemption (%s) must be strictly positive.", _redemption.toString()));
            assert(() => [1, 2, 4].includes(_frequency), _lt("The frequency (%s) must be one of %s.", _frequency.toString(), [1, 2, 4].toString()));
            assert(() => 0 <= _dayCountConvention && _dayCountConvention <= 4, _lt("The day_count_convention (%s) must between 0 and 4 inclusive.", _dayCountConvention.toString()));
            const years = YEARFRAC.compute(_settlement, _maturity, _dayCountConvention);
            const nbrRealCoupons = years * _frequency;
            const nbrFullCoupons = Math.ceil(nbrRealCoupons);
            const timeFirstCoupon = nbrRealCoupons - Math.floor(nbrRealCoupons) || 1;
            const cashFlowFromCoupon = (100 * _rate) / _frequency;
            if (nbrFullCoupons === 1) {
                const subPart = _price + cashFlowFromCoupon * (1 - timeFirstCoupon);
                return (((_redemption + cashFlowFromCoupon - subPart) * _frequency * (1 / timeFirstCoupon)) /
                    subPart);
            }
            // The result of YIELD function is the yield at which the PRICE function will return the given price.
            // This algorithm uses the Newton's method on the PRICE function to determine the result.
            // Newton's method: https://en.wikipedia.org/wiki/Newton%27s_method
            // As the PRICE function isn't continuous, we apply the Newton's method on the numerator of the PRICE formula.
            // For simplicity, it is not yield but yieldFactorPerPeriod (= 1 + yield / frequency) which will be calibrated in Newton's method.
            // yield can be deduced from yieldFactorPerPeriod in sequence.
            function priceNumerator(price, timeFirstCoupon, nbrFullCoupons, yieldFactorPerPeriod, cashFlowFromCoupon, redemption) {
                let result = redemption -
                    (price + cashFlowFromCoupon * (1 - timeFirstCoupon)) *
                        yieldFactorPerPeriod ** (nbrFullCoupons - 1 + timeFirstCoupon);
                for (let i = 1; i <= nbrFullCoupons; i++) {
                    result += cashFlowFromCoupon * yieldFactorPerPeriod ** (i - 1);
                }
                return result;
            }
            function priceNumeratorDeriv(price, timeFirstCoupon, nbrFullCoupons, yieldFactorPerPeriod, cashFlowFromCoupon) {
                let result = -(price + cashFlowFromCoupon * (1 - timeFirstCoupon)) *
                    (nbrFullCoupons - 1 + timeFirstCoupon) *
                    yieldFactorPerPeriod ** (nbrFullCoupons - 2 + timeFirstCoupon);
                for (let i = 1; i <= nbrFullCoupons; i++) {
                    result += cashFlowFromCoupon * (i - 1) * yieldFactorPerPeriod ** (i - 2);
                }
                return result;
            }
            function func(x) {
                return priceNumerator(_price, timeFirstCoupon, nbrFullCoupons, x, cashFlowFromCoupon, _redemption);
            }
            function derivFunc(x) {
                return priceNumeratorDeriv(_price, timeFirstCoupon, nbrFullCoupons, x, cashFlowFromCoupon);
            }
            const initYield = _rate + 1;
            const initYieldFactorPerPeriod = 1 + initYield / _frequency;
            const methodResult = newtonMethod(func, derivFunc, initYieldFactorPerPeriod, 100, 1e-5);
            return (methodResult - 1) * _frequency;
        },
    };
    // -----------------------------------------------------------------------------
    // YIELDMAT
    // -----------------------------------------------------------------------------
    const YIELDMAT = {
        description: _lt("Annual yield of a security paying interest at maturity."),
        args: args(`
        settlement (date) ${_lt("The settlement date of the security, the date after issuance when the security is delivered to the buyer.")}
        maturity (date) ${_lt("The maturity or end date of the security, when it can be redeemed at face, or par value.")}
        issue (date) ${_lt("The date the security was initially issued.")}
        rate (number) ${_lt("The annualized rate of interest.")}
        price (number) ${_lt("The price at which the security is bought.")}
        day_count_convention (number, default=${DEFAULT_DAY_COUNT_CONVENTION} ) ${_lt("An indicator of what day count method to use.")}
    `),
        returns: ["NUMBER"],
        compute: function (settlement, maturity, issue, rate, price, dayCountConvention = DEFAULT_DAY_COUNT_CONVENTION) {
            dayCountConvention = dayCountConvention || 0;
            const _settlement = Math.trunc(toNumber(settlement));
            const _maturity = Math.trunc(toNumber(maturity));
            const _issue = Math.trunc(toNumber(issue));
            const _rate = toNumber(rate);
            const _price = toNumber(price);
            const _dayCountConvention = Math.trunc(toNumber(dayCountConvention));
            assert(() => _settlement >= _issue, _lt("The settlement (%s) must be greater than or equal to the issue (%s).", _settlement.toString(), _issue.toString()));
            assert(() => _maturity > _settlement, _lt("The maturity (%s) must be strictly greater than the settlement (%s).", _maturity.toString(), _settlement.toString()));
            assert(() => _rate >= 0, _lt("The rate (%s) must be positive or null.", _rate.toString()));
            assert(() => _price > 0, _lt("The price (%s) must be strictly positive.", _price.toString()));
            assert(() => 0 <= _dayCountConvention && _dayCountConvention <= 4, _lt("The day_count_convention (%s) must be between 0 and 4 inclusive.", _dayCountConvention.toString()));
            const issueToMaturity = YEARFRAC.compute(_issue, _maturity, _dayCountConvention);
            const issueToSettlement = YEARFRAC.compute(_issue, _settlement, _dayCountConvention);
            const settlementToMaturity = YEARFRAC.compute(_settlement, _maturity, _dayCountConvention);
            const numerator = (100 * (1 + _rate * issueToMaturity)) / (_price + 100 * _rate * issueToSettlement) - 1;
            return numerator / settlementToMaturity;
        },
    };

    var financial = /*#__PURE__*/Object.freeze({
        __proto__: null,
        DB: DB,
        DURATION: DURATION,
        FV: FV,
        IRR: IRR,
        MDURATION: MDURATION,
        NPV: NPV,
        PDURATION: PDURATION,
        PV: PV,
        PRICE: PRICE,
        YIELD: YIELD,
        YIELDMAT: YIELDMAT
    });

    // -----------------------------------------------------------------------------
    // ISERROR
    // -----------------------------------------------------------------------------
    const ISERROR = {
        description: _lt("Whether a value is an error."),
        args: args(`value (any, lazy) ${_lt("The value to be verified as an error type.")}`),
        returns: ["BOOLEAN"],
        compute: function (value) {
            try {
                value();
                return false;
            }
            catch (e) {
                return true;
            }
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ISLOGICAL
    // -----------------------------------------------------------------------------
    const ISLOGICAL = {
        description: _lt("Whether a value is `true` or `false`."),
        args: args(`value (any) ${_lt("The value to be verified as a logical TRUE or FALSE.")}`),
        returns: ["BOOLEAN"],
        compute: function (value) {
            return typeof value === "boolean";
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ISNONTEXT
    // -----------------------------------------------------------------------------
    const ISNONTEXT = {
        description: _lt("Whether a value is non-textual."),
        args: args(`value (any) ${_lt("The value to be checked.")}`),
        returns: ["BOOLEAN"],
        compute: function (value) {
            return typeof value !== "string";
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ISNUMBER
    // -----------------------------------------------------------------------------
    const ISNUMBER = {
        description: _lt("Whether a value is a number."),
        args: args(`value (any) ${_lt("The value to be verified as a number.")}`),
        returns: ["BOOLEAN"],
        compute: function (value) {
            return typeof value === "number";
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ISTEXT
    // -----------------------------------------------------------------------------
    const ISTEXT = {
        description: _lt("Whether a value is text."),
        args: args(`value (any) ${_lt("The value to be verified as text.")}`),
        returns: ["BOOLEAN"],
        compute: function (value) {
            return typeof value === "string";
        },
        isExported: true,
    };

    var info = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ISERROR: ISERROR,
        ISLOGICAL: ISLOGICAL,
        ISNONTEXT: ISNONTEXT,
        ISNUMBER: ISNUMBER,
        ISTEXT: ISTEXT
    });

    // -----------------------------------------------------------------------------
    // AND
    // -----------------------------------------------------------------------------
    const AND = {
        description: _lt("Logical `and` operator."),
        args: args(`
      logical_expression1 (boolean, range<boolean>) ${_lt("An expression or reference to a cell containing an expression that represents some logical value, i.e. TRUE or FALSE, or an expression that can be coerced to a logical value.")}
      logical_expression2 (boolean, range<boolean>, repeating) ${_lt("More expressions that represent logical values.")}
    `),
        returns: ["BOOLEAN"],
        compute: function (...logicalExpressions) {
            let foundBoolean = false;
            let acc = true;
            conditionalVisitBoolean(logicalExpressions, (arg) => {
                foundBoolean = true;
                acc = acc && arg;
                return acc;
            });
            assert(() => foundBoolean, _lt(`[[FUNCTION_NAME]] has no valid input data.`));
            return acc;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // IF
    // -----------------------------------------------------------------------------
    const IF = {
        description: _lt("Returns value depending on logical expression."),
        args: args(`
      logical_expression (boolean) ${_lt("An expression or reference to a cell containing an expression that represents some logical value, i.e. TRUE or FALSE.")}
      value_if_true (any, lazy) ${_lt("The value the function returns if logical_expression is TRUE.")}
      value_if_false (any, lazy, default=FALSE) ${_lt("The value the function returns if logical_expression is FALSE.")}
    `),
        returns: ["ANY"],
        compute: function (logicalExpression, valueIfTrue, valueIfFalse = () => false) {
            const result = toBoolean(logicalExpression) ? valueIfTrue() : valueIfFalse();
            return result === null || result === undefined ? "" : result;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // IFERROR
    // -----------------------------------------------------------------------------
    const IFERROR = {
        description: _lt("Value if it is not an error, otherwise 2nd argument."),
        args: args(`
    value (any, lazy) ${_lt("The value to return if value itself is not an error.")}
    value_if_error (any, lazy, default=${_lt("An empty value")}) ${_lt("The value the function returns if value is an error.")}
  `),
        returns: ["ANY"],
        compute: function (value, valueIfError = () => "") {
            let result;
            try {
                result = value();
            }
            catch (e) {
                result = valueIfError();
            }
            return result === null || result === undefined ? "" : result;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // IFS
    // -----------------------------------------------------------------------------
    const IFS = {
        description: _lt("Returns a value depending on multiple logical expressions."),
        args: args(`
      condition1 (boolean, lazy) ${_lt("The first condition to be evaluated. This can be a boolean, a number, an array, or a reference to any of those.")}
      value1 (any, lazy) ${_lt("The returned value if condition1 is TRUE.")}
      condition2 (boolean, lazy, repeating) ${_lt("Additional conditions to be evaluated if the previous ones are FALSE.")}
      value2 (any, lazy, repeating) ${_lt("Additional values to be returned if their corresponding conditions are TRUE.")}
  `),
        returns: ["ANY"],
        compute: function (...values) {
            assert(() => values.length % 2 === 0, _lt(`Wrong number of arguments. Expected an even number of arguments.`));
            for (let n = 0; n < values.length - 1; n += 2) {
                if (toBoolean(values[n]())) {
                    return values[n + 1]();
                }
            }
            throw new Error(_lt(`No match.`));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // NOT
    // -----------------------------------------------------------------------------
    const NOT = {
        description: _lt("Returns opposite of provided logical value."),
        args: args(`logical_expression (boolean) ${_lt("An expression or reference to a cell holding an expression that represents some logical value.")}
    `),
        returns: ["BOOLEAN"],
        compute: function (logicalExpression) {
            return !toBoolean(logicalExpression);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // OR
    // -----------------------------------------------------------------------------
    const OR = {
        description: _lt("Logical `or` operator."),
        args: args(`
      logical_expression1 (boolean, range<boolean>) ${_lt("An expression or reference to a cell containing an expression that represents some logical value, i.e. TRUE or FALSE, or an expression that can be coerced to a logical value.")}
      logical_expression2 (boolean, range<boolean>, repeating) ${_lt("More expressions that evaluate to logical values.")}
    `),
        returns: ["BOOLEAN"],
        compute: function (...logicalExpressions) {
            let foundBoolean = false;
            let acc = false;
            conditionalVisitBoolean(logicalExpressions, (arg) => {
                foundBoolean = true;
                acc = acc || arg;
                return !acc;
            });
            assert(() => foundBoolean, _lt(`[[FUNCTION_NAME]] has no valid input data.`));
            return acc;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // XOR
    // -----------------------------------------------------------------------------
    const XOR = {
        description: _lt("Logical `xor` operator."),
        args: args(`
      logical_expression1 (boolean, range<boolean>) ${_lt("An expression or reference to a cell containing an expression that represents some logical value, i.e. TRUE or FALSE, or an expression that can be coerced to a logical value.")}
      logical_expression2 (boolean, range<boolean>, repeating) ${_lt("More expressions that evaluate to logical values.")}
    `),
        returns: ["BOOLEAN"],
        compute: function (...logicalExpressions) {
            let foundBoolean = false;
            let acc = false;
            conditionalVisitBoolean(logicalExpressions, (arg) => {
                foundBoolean = true;
                acc = acc ? !arg : arg;
                return true; // no stop condition
            });
            assert(() => foundBoolean, _lt(`[[FUNCTION_NAME]] has no valid input data.`));
            return acc;
        },
        isExported: true,
    };

    var logical = /*#__PURE__*/Object.freeze({
        __proto__: null,
        AND: AND,
        IF: IF,
        IFERROR: IFERROR,
        IFS: IFS,
        NOT: NOT,
        OR: OR,
        XOR: XOR
    });

    const DEFAULT_IS_SORTED = true;
    /**
     * Perform a linear search and return the index of the perfect match.
     * -1 is returned if no value is found.
     *
     * Example:
     * - [3, 6, 10], 3 => 0
     * - [3, 6, 10], 6 => 1
     * - [3, 6, 10], 9 => -1
     * - [3, 6, 10], 2 => -1
     */
    function linearSearch(range, target) {
        for (let i = 0; i < range.length; i++) {
            if (range[i] === target) {
                return i;
            }
        }
        // no value is found, -1 is returned
        return -1;
    }
    // -----------------------------------------------------------------------------
    // COLUMN
    // -----------------------------------------------------------------------------
    const COLUMN = {
        description: _lt("Column number of a specified cell."),
        args: args(`cell_reference (meta, default=${_lt("The cell in which the formula is entered")}) ${_lt("The cell whose column number will be returned. Column A corresponds to 1.")}
    `),
        returns: ["NUMBER"],
        compute: function (cellReference) {
            var _a;
            cellReference = cellReference || ((_a = this.__originCellXC) === null || _a === void 0 ? void 0 : _a.call(this));
            assert(() => !!cellReference, "In this context, the function [[FUNCTION_NAME]] needs to have a cell or range in parameter.");
            const zone = toZone(cellReference);
            return zone.left + 1;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // COLUMNS
    // -----------------------------------------------------------------------------
    const COLUMNS = {
        description: _lt("Number of columns in a specified array or range."),
        args: args(`range (meta) ${_lt("The range whose column count will be returned.")}`),
        returns: ["NUMBER"],
        compute: function (range) {
            const zone = toZone(range);
            return zone.right - zone.left + 1;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // HLOOKUP
    // -----------------------------------------------------------------------------
    const HLOOKUP = {
        description: _lt(`Horizontal lookup`),
        args: args(`
      search_key (any) ${_lt("The value to search for. For example, 42, 'Cats', or I24.")}
      range (range) ${_lt("The range to consider for the search. The first row in the range is searched for the key specified in search_key.")}
      index (number) ${_lt("The row index of the value to be returned, where the first row in range is numbered 1.")}
      is_sorted (boolean, default=${DEFAULT_IS_SORTED}) ${_lt("Indicates whether the row to be searched (the first row of the specified range) is sorted, in which case the closest match for search_key will be returned.")}
  `),
        returns: ["ANY"],
        compute: function (searchKey, range, index, isSorted = DEFAULT_IS_SORTED) {
            const _index = Math.trunc(toNumber(index));
            assert(() => 1 <= _index && _index <= range[0].length, _lt("[[FUNCTION_NAME]] evaluates to an out of bounds range."));
            const _isSorted = toBoolean(isSorted);
            const firstRow = range.map((col) => col[0]);
            let colIndex;
            if (_isSorted) {
                colIndex = dichotomicPredecessorSearch(firstRow, searchKey);
            }
            else {
                colIndex = linearSearch(firstRow, searchKey);
            }
            assert(() => colIndex > -1, _lt("Did not find value '%s' in [[FUNCTION_NAME]] evaluation.", toString(searchKey)));
            return range[colIndex][_index - 1];
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // LOOKUP
    // -----------------------------------------------------------------------------
    const LOOKUP = {
        description: _lt(`Look up a value.`),
        args: args(`
      search_key (any) ${_lt("The value to search for. For example, 42, 'Cats', or I24.")}
      search_array (range) ${_lt("One method of using this function is to provide a single sorted row or column search_array to look through for the search_key with a second argument result_range. The other way is to combine these two arguments into one search_array where the first row or column is searched and a value is returned from the last row or column in the array. If search_key is not found, a non-exact match may be returned.")}
      result_range (range, optional) ${_lt("The range from which to return a result. The value returned corresponds to the location where search_key is found in search_range. This range must be only a single row or column and should not be used if using the search_result_array method.")}
  `),
        returns: ["ANY"],
        compute: function (searchKey, searchArray, resultRange) {
            let nbCol = searchArray.length;
            let nbRow = searchArray[0].length;
            const verticalSearch = nbRow >= nbCol;
            const searchRange = verticalSearch ? searchArray[0] : searchArray.map((c) => c[0]);
            const index = dichotomicPredecessorSearch(searchRange, searchKey);
            assert(() => index >= 0, _lt("Did not find value '%s' in [[FUNCTION_NAME]] evaluation.", toString(searchKey)));
            if (resultRange === undefined) {
                return verticalSearch ? searchArray[nbCol - 1][index] : searchArray[index][nbRow - 1];
            }
            nbCol = resultRange.length;
            nbRow = resultRange[0].length;
            assert(() => nbCol === 1 || nbRow === 1, _lt("The result_range must be a single row or a single column."));
            if (nbCol > 1) {
                assert(() => index <= nbCol - 1, _lt("[[FUNCTION_NAME]] evaluates to an out of range row value %s.", (index + 1).toString()));
                return resultRange[index][0];
            }
            assert(() => index <= nbRow - 1, _lt("[[FUNCTION_NAME]] evaluates to an out of range column value %s.", (index + 1).toString()));
            return resultRange[0][index];
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // MATCH
    // -----------------------------------------------------------------------------
    const DEFAULT_SEARCH_TYPE = 1;
    const MATCH = {
        description: _lt(`Position of item in range that matches value.`),
        args: args(`
      search_key (any) ${_lt("The value to search for. For example, 42, 'Cats', or I24.")}
      range (any, range) ${_lt("The one-dimensional array to be searched.")}
      search_type (number, default=${DEFAULT_SEARCH_TYPE}) ${_lt("The search method. 1 (default) finds the largest value less than or equal to search_key when range is sorted in ascending order. 0 finds the exact value when range is unsorted. -1 finds the smallest value greater than or equal to search_key when range is sorted in descending order.")}
  `),
        returns: ["NUMBER"],
        compute: function (searchKey, range, searchType = DEFAULT_SEARCH_TYPE) {
            let _searchType = toNumber(searchType);
            const nbCol = range.length;
            const nbRow = range[0].length;
            assert(() => nbCol === 1 || nbRow === 1, _lt("The range must be a single row or a single column."));
            let index = -1;
            const _range = range.flat();
            _searchType = Math.sign(_searchType);
            switch (_searchType) {
                case 1:
                    index = dichotomicPredecessorSearch(_range, searchKey);
                    break;
                case 0:
                    index = linearSearch(_range, searchKey);
                    break;
                case -1:
                    index = dichotomicSuccessorSearch(_range, searchKey);
                    break;
            }
            assert(() => index >= 0, _lt("Did not find value '%s' in [[FUNCTION_NAME]] evaluation.", toString(searchKey)));
            return index + 1;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ROW
    // -----------------------------------------------------------------------------
    const ROW = {
        description: _lt("Row number of a specified cell."),
        args: args(`cell_reference (meta, default=${_lt("The cell in which the formula is entered by default")}) ${_lt("The cell whose row number will be returned.")}`),
        returns: ["NUMBER"],
        compute: function (cellReference) {
            var _a;
            cellReference = cellReference || ((_a = this.__originCellXC) === null || _a === void 0 ? void 0 : _a.call(this));
            assert(() => !!cellReference, "In this context, the function [[FUNCTION_NAME]] needs to have a cell or range in parameter.");
            const zone = toZone(cellReference);
            return zone.top + 1;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // ROWS
    // -----------------------------------------------------------------------------
    const ROWS = {
        description: _lt("Number of rows in a specified array or range."),
        args: args(`range (meta) ${_lt("The range whose row count will be returned.")}`),
        returns: ["NUMBER"],
        compute: function (range) {
            const zone = toZone(range);
            return zone.bottom - zone.top + 1;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // VLOOKUP
    // -----------------------------------------------------------------------------
    const VLOOKUP = {
        description: _lt(`Vertical lookup.`),
        args: args(`
      search_key (any) ${_lt("The value to search for. For example, 42, 'Cats', or I24.")}
      range (any, range) ${_lt("The range to consider for the search. The first column in the range is searched for the key specified in search_key.")}
      index (number) ${_lt("The column index of the value to be returned, where the first column in range is numbered 1.")}
      is_sorted (boolean, default=${DEFAULT_IS_SORTED}) ${_lt("Indicates whether the column to be searched (the first column of the specified range) is sorted, in which case the closest match for search_key will be returned.")}
  `),
        returns: ["ANY"],
        compute: function (searchKey, range, index, isSorted = DEFAULT_IS_SORTED) {
            const _index = Math.trunc(toNumber(index));
            assert(() => 1 <= _index && _index <= range.length, _lt("[[FUNCTION_NAME]] evaluates to an out of bounds range."));
            const _isSorted = toBoolean(isSorted);
            const firstCol = range[0];
            let rowIndex;
            if (_isSorted) {
                rowIndex = dichotomicPredecessorSearch(firstCol, searchKey);
            }
            else {
                rowIndex = linearSearch(firstCol, searchKey);
            }
            assert(() => rowIndex > -1, _lt("Did not find value '%s' in [[FUNCTION_NAME]] evaluation.", toString(searchKey)));
            return range[_index - 1][rowIndex];
        },
        isExported: true,
    };

    var lookup = /*#__PURE__*/Object.freeze({
        __proto__: null,
        COLUMN: COLUMN,
        COLUMNS: COLUMNS,
        HLOOKUP: HLOOKUP,
        LOOKUP: LOOKUP,
        MATCH: MATCH,
        ROW: ROW,
        ROWS: ROWS,
        VLOOKUP: VLOOKUP
    });

    // -----------------------------------------------------------------------------
    // ADD
    // -----------------------------------------------------------------------------
    const ADD = {
        description: _lt(`Sum of two numbers.`),
        args: args(`
      value1 (number) ${_lt("The first addend.")}
      value2 (number) ${_lt("The second addend.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (value1, value2) {
            return toNumber(value1) + toNumber(value2);
        },
    };
    // -----------------------------------------------------------------------------
    // CONCAT
    // -----------------------------------------------------------------------------
    const CONCAT = {
        description: _lt(`Concatenation of two values.`),
        args: args(`
      value1 (string) ${_lt("The value to which value2 will be appended.")}
      value2 (string) ${_lt("The value to append to value1.")}
    `),
        returns: ["STRING"],
        compute: function (value1, value2) {
            return toString(value1) + toString(value2);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // DIVIDE
    // -----------------------------------------------------------------------------
    const DIVIDE = {
        description: _lt(`One number divided by another.`),
        args: args(`
      dividend (number) ${_lt("The number to be divided.")}
      divisor (number) ${_lt("The number to divide by.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (dividend, divisor) {
            const _divisor = toNumber(divisor);
            assert(() => _divisor !== 0, _lt("The divisor must be different from zero."));
            return toNumber(dividend) / _divisor;
        },
    };
    // -----------------------------------------------------------------------------
    // EQ
    // -----------------------------------------------------------------------------
    function isEmpty(value) {
        return value === null || value === undefined;
    }
    const getNeutral = { number: 0, string: "", boolean: false };
    const EQ = {
        description: _lt(`Equal.`),
        args: args(`
      value1 (any) ${_lt("The first value.")}
      value2 (any) ${_lt("The value to test against value1 for equality.")}
    `),
        returns: ["BOOLEAN"],
        compute: function (value1, value2) {
            value1 = isEmpty(value1) ? getNeutral[typeof value2] : value1;
            value2 = isEmpty(value2) ? getNeutral[typeof value1] : value2;
            if (typeof value1 === "string") {
                value1 = value1.toUpperCase();
            }
            if (typeof value2 === "string") {
                value2 = value2.toUpperCase();
            }
            return value1 === value2;
        },
    };
    // -----------------------------------------------------------------------------
    // GT
    // -----------------------------------------------------------------------------
    function applyRelationalOperator(value1, value2, cb) {
        value1 = isEmpty(value1) ? getNeutral[typeof value2] : value1;
        value2 = isEmpty(value2) ? getNeutral[typeof value1] : value2;
        if (typeof value1 !== "number") {
            value1 = toString(value1).toUpperCase();
        }
        if (typeof value2 !== "number") {
            value2 = toString(value2).toUpperCase();
        }
        const tV1 = typeof value1;
        const tV2 = typeof value2;
        if (tV1 === "string" && tV2 === "number") {
            return true;
        }
        if (tV2 === "string" && tV1 === "number") {
            return false;
        }
        return cb(value1, value2);
    }
    const GT = {
        description: _lt(`Strictly greater than.`),
        args: args(`
      value1 (any) ${_lt("The value to test as being greater than value2.")}
      value2 (any) ${_lt("The second value.")}
    `),
        returns: ["BOOLEAN"],
        compute: function (value1, value2) {
            return applyRelationalOperator(value1, value2, (v1, v2) => {
                return v1 > v2;
            });
        },
    };
    // -----------------------------------------------------------------------------
    // GTE
    // -----------------------------------------------------------------------------
    const GTE = {
        description: _lt(`Greater than or equal to.`),
        args: args(`
      value1 (any) ${_lt("The value to test as being greater than or equal to value2.")}
      value2 (any) ${_lt("The second value.")}
    `),
        returns: ["BOOLEAN"],
        compute: function (value1, value2) {
            return applyRelationalOperator(value1, value2, (v1, v2) => {
                return v1 >= v2;
            });
        },
    };
    // -----------------------------------------------------------------------------
    // LT
    // -----------------------------------------------------------------------------
    const LT = {
        description: _lt(`Less than.`),
        args: args(`
      value1 (any) ${_lt("The value to test as being less than value2.")}
      value2 (any) ${_lt("The second value.")}
    `),
        returns: ["BOOLEAN"],
        compute: function (value1, value2) {
            return !GTE.compute(value1, value2);
        },
    };
    // -----------------------------------------------------------------------------
    // LTE
    // -----------------------------------------------------------------------------
    const LTE = {
        description: _lt(`Less than or equal to.`),
        args: args(`
      value1 (any) ${_lt("The value to test as being less than or equal to value2.")}
      value2 (any) ${_lt("The second value.")}
    `),
        returns: ["BOOLEAN"],
        compute: function (value1, value2) {
            return !GT.compute(value1, value2);
        },
    };
    // -----------------------------------------------------------------------------
    // MINUS
    // -----------------------------------------------------------------------------
    const MINUS = {
        description: _lt(`Difference of two numbers.`),
        args: args(`
      value1 (number) ${_lt("The minuend, or number to be subtracted from.")}
      value2 (number) ${_lt("The subtrahend, or number to subtract from value1.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (value1, value2) {
            return toNumber(value1) - toNumber(value2);
        },
    };
    // -----------------------------------------------------------------------------
    // MULTIPLY
    // -----------------------------------------------------------------------------
    const MULTIPLY = {
        description: _lt(`Product of two numbers`),
        args: args(`
      factor1 (number) ${_lt("The first multiplicand.")}
      factor2 (number) ${_lt("The second multiplicand.")}
    `),
        returns: ["NUMBER"],
        returnFormat: ReturnFormatType.FormatFromArgument,
        compute: function (factor1, factor2) {
            return toNumber(factor1) * toNumber(factor2);
        },
    };
    // -----------------------------------------------------------------------------
    // NE
    // -----------------------------------------------------------------------------
    const NE = {
        description: _lt(`Not equal.`),
        args: args(`
      value1 (any) ${_lt("The first value.")}
      value2 (any) ${_lt("The value to test against value1 for inequality.")}
    `),
        returns: ["BOOLEAN"],
        compute: function (value1, value2) {
            return !EQ.compute(value1, value2);
        },
    };
    // -----------------------------------------------------------------------------
    // POW
    // -----------------------------------------------------------------------------
    const POW = {
        description: _lt(`A number raised to a power.`),
        args: args(`
      base (number) ${_lt("The number to raise to the exponent power.")}
      exponent (number) ${_lt("The exponent to raise base to.")}
    `),
        returns: ["BOOLEAN"],
        compute: function (base, exponent) {
            return POWER.compute(base, exponent);
        },
    };
    // -----------------------------------------------------------------------------
    // UMINUS
    // -----------------------------------------------------------------------------
    const UMINUS = {
        description: _lt(`A number with the sign reversed.`),
        args: args(`
      value (number) ${_lt("The number to have its sign reversed. Equivalently, the number to multiply by -1.")}
    `),
        returnFormat: ReturnFormatType.FormatFromArgument,
        returns: ["NUMBER"],
        compute: function (value) {
            return -toNumber(value);
        },
    };
    // -----------------------------------------------------------------------------
    // UNARY_PERCENT
    // -----------------------------------------------------------------------------
    const UNARY_PERCENT = {
        description: _lt(`Value interpreted as a percentage.`),
        args: args(`
      percentage (number) ${_lt("The value to interpret as a percentage.")}
    `),
        returns: ["NUMBER"],
        compute: function (percentage) {
            return toNumber(percentage) / 100;
        },
    };
    // -----------------------------------------------------------------------------
    // UPLUS
    // -----------------------------------------------------------------------------
    const UPLUS = {
        description: _lt(`A specified number, unchanged.`),
        args: args(`
      value (any) ${_lt("The number to return.")}
    `),
        returnFormat: ReturnFormatType.FormatFromArgument,
        returns: ["ANY"],
        compute: function (value) {
            return value;
        },
    };

    var operators = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ADD: ADD,
        CONCAT: CONCAT,
        DIVIDE: DIVIDE,
        EQ: EQ,
        GT: GT,
        GTE: GTE,
        LT: LT,
        LTE: LTE,
        MINUS: MINUS,
        MULTIPLY: MULTIPLY,
        NE: NE,
        POW: POW,
        UMINUS: UMINUS,
        UNARY_PERCENT: UNARY_PERCENT,
        UPLUS: UPLUS
    });

    const DEFAULT_STARTING_AT = 1;
    // -----------------------------------------------------------------------------
    // CHAR
    // -----------------------------------------------------------------------------
    const CHAR = {
        description: _lt("Gets character associated with number."),
        args: args(`
      table_number (number) ${_lt("The number of the character to look up from the current Unicode table in decimal format.")}
  `),
        returns: ["STRING"],
        compute: function (tableNumber) {
            const _tableNumber = Math.trunc(toNumber(tableNumber));
            assert(() => _tableNumber >= 1, _lt("The table_number (%s) is out of range.", _tableNumber.toString()));
            return String.fromCharCode(_tableNumber);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // CONCATENATE
    // -----------------------------------------------------------------------------
    const CONCATENATE = {
        description: _lt("Appends strings to one another."),
        args: args(`
      string1 (string, range<string>) ${_lt("The initial string.")}
      string2 (string, range<string>, repeating) ${_lt("More strings to append in sequence.")}
  `),
        returns: ["STRING"],
        compute: function (...values) {
            return reduceAny(values, (acc, a) => acc + toString(a), "");
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // EXACT
    // -----------------------------------------------------------------------------
    const EXACT = {
        description: _lt("Tests whether two strings are identical."),
        args: args(`
      string1 (string) ${_lt("The first string to compare.")}
      string2 (string) ${_lt("The second string to compare.")}
  `),
        returns: ["BOOLEAN"],
        compute: function (string1, string2) {
            return toString(string1) === toString(string2);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // FIND
    // -----------------------------------------------------------------------------
    const FIND = {
        description: _lt("First position of string found in text, case-sensitive."),
        args: args(`
      search_for (string) ${_lt("The string to look for within text_to_search.")}
      text_to_search (string) ${_lt("The text to search for the first occurrence of search_for.")}
      starting_at (number, default=${DEFAULT_STARTING_AT}) ${_lt("The character within text_to_search at which to start the search.")}
  `),
        returns: ["NUMBER"],
        compute: function (searchFor, textToSearch, startingAt = DEFAULT_STARTING_AT) {
            const _searchFor = toString(searchFor);
            const _textToSearch = toString(textToSearch);
            const _startingAt = toNumber(startingAt);
            assert(() => _textToSearch !== "", _lt(`The text_to_search must be non-empty.`));
            assert(() => _startingAt >= 1, _lt("The starting_at (%s) must be greater than or equal to 1.", _startingAt.toString()));
            const result = _textToSearch.indexOf(_searchFor, _startingAt - 1);
            assert(() => result >= 0, _lt("In [[FUNCTION_NAME]] evaluation, cannot find '%s' within '%s'.", _searchFor.toString(), _textToSearch));
            return result + 1;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // JOIN
    // -----------------------------------------------------------------------------
    const JOIN = {
        description: _lt("Concatenates elements of arrays with delimiter."),
        args: args(`
      delimiter (string) ${_lt("The character or string to place between each concatenated value.")}
      value_or_array1 (string, range<string>) ${_lt("The value or values to be appended using delimiter.")}
      value_or_array2 (string, range<string>, repeating) ${_lt("More values to be appended using delimiter.")}
  `),
        returns: ["STRING"],
        compute: function (delimiter, ...valuesOrArrays) {
            const _delimiter = toString(delimiter);
            return reduceAny(valuesOrArrays, (acc, a) => (acc ? acc + _delimiter : "") + toString(a), "");
        },
    };
    // -----------------------------------------------------------------------------
    // LEFT
    // -----------------------------------------------------------------------------
    const LEFT = {
        description: _lt("Substring from beginning of specified string."),
        args: args(`
      text (string) ${_lt("The string from which the left portion will be returned.")}
      number_of_characters (number, optional) ${_lt("The number of characters to return from the left side of string.")}
  `),
        returns: ["STRING"],
        compute: function (text, ...args) {
            const _numberOfCharacters = args.length ? toNumber(args[0]) : 1;
            assert(() => _numberOfCharacters >= 0, _lt("The number_of_characters (%s) must be positive or null.", _numberOfCharacters.toString()));
            return toString(text).substring(0, _numberOfCharacters);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // LEN
    // -----------------------------------------------------------------------------
    const LEN = {
        description: _lt("Length of a string."),
        args: args(`
      text (string) ${_lt("The string whose length will be returned.")}
  `),
        returns: ["NUMBER"],
        compute: function (text) {
            return toString(text).length;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // LOWER
    // -----------------------------------------------------------------------------
    const LOWER = {
        description: _lt("Converts a specified string to lowercase."),
        args: args(`
      text (string) ${_lt("The string to convert to lowercase.")}
  `),
        returns: ["STRING"],
        compute: function (text) {
            return toString(text).toLowerCase();
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // REPLACE
    // -----------------------------------------------------------------------------
    const REPLACE = {
        description: _lt("Replaces part of a text string with different text."),
        args: args(`
      text (string) ${_lt("The text, a part of which will be replaced.")}
      position (number) ${_lt("The position where the replacement will begin (starting from 1).")}
      length (number) ${_lt("The number of characters in the text to be replaced.")}
      new_text (string) ${_lt("The text which will be inserted into the original text.")}
  `),
        returns: ["STRING"],
        compute: function (text, position, length, newText) {
            const _position = toNumber(position);
            assert(() => _position >= 1, _lt("The position (%s) must be greater than or equal to 1.", _position.toString()));
            const _text = toString(text);
            const _length = toNumber(length);
            const _newText = toString(newText);
            return _text.substring(0, _position - 1) + _newText + _text.substring(_position - 1 + _length);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // RIGHT
    // -----------------------------------------------------------------------------
    const RIGHT = {
        description: _lt("A substring from the end of a specified string."),
        args: args(`
      text (string) ${_lt("The string from which the right portion will be returned.")}
      number_of_characters (number, optional) ${_lt("The number of characters to return from the right side of string.")}
  `),
        returns: ["STRING"],
        compute: function (text, ...args) {
            const _numberOfCharacters = args.length ? toNumber(args[0]) : 1;
            assert(() => _numberOfCharacters >= 0, _lt("The number_of_characters (%s) must be positive or null.", _numberOfCharacters.toString()));
            const _text = toString(text);
            const stringLength = _text.length;
            return _text.substring(stringLength - _numberOfCharacters, stringLength);
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // SEARCH
    // -----------------------------------------------------------------------------
    const SEARCH = {
        description: _lt("First position of string found in text, ignoring case."),
        args: args(`
      search_for (string) ${_lt("The string to look for within text_to_search.")}
      text_to_search (string) ${_lt("The text to search for the first occurrence of search_for.")}
      starting_at (number, default=${DEFAULT_STARTING_AT}) ${_lt("The character within text_to_search at which to start the search.")}
  `),
        returns: ["NUMBER"],
        compute: function (searchFor, textToSearch, startingAt = DEFAULT_STARTING_AT) {
            const _searchFor = toString(searchFor).toLowerCase();
            const _textToSearch = toString(textToSearch).toLowerCase();
            const _startingAt = toNumber(startingAt);
            assert(() => _textToSearch !== "", _lt(`The text_to_search must be non-empty.`));
            assert(() => _startingAt >= 1, _lt("The starting_at (%s) must be greater than or equal to 1.", _startingAt.toString()));
            const result = _textToSearch.indexOf(_searchFor, _startingAt - 1);
            assert(() => result >= 0, _lt("In [[FUNCTION_NAME]] evaluation, cannot find '%s' within '%s'.", _searchFor, _textToSearch));
            return result + 1;
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // SUBSTITUTE
    // -----------------------------------------------------------------------------
    const SUBSTITUTE = {
        description: _lt("Replaces existing text with new text in a string."),
        args: args(`
      text_to_search (string) ${_lt("The text within which to search and replace.")}
      search_for (string) ${_lt("The string to search for within text_to_search.")}
      replace_with (string) ${_lt("The string that will replace search_for.")}
      occurrence_number (number, optional) ${_lt("The instance of search_for within text_to_search to replace with replace_with. By default, all occurrences of search_for are replaced; however, if occurrence_number is specified, only the indicated instance of search_for is replaced.")}
  `),
        returns: ["NUMBER"],
        compute: function (textToSearch, searchFor, replaceWith, occurrenceNumber = undefined) {
            const _occurrenceNumber = toNumber(occurrenceNumber);
            assert(() => _occurrenceNumber >= 0, _lt("The occurrenceNumber (%s) must be positive or null.", _occurrenceNumber.toString()));
            const _textToSearch = toString(textToSearch);
            const _searchFor = toString(searchFor);
            if (_searchFor === "") {
                return _textToSearch;
            }
            const _replaceWith = toString(replaceWith);
            const reg = new RegExp(_searchFor, "g");
            if (_occurrenceNumber === 0) {
                return _textToSearch.replace(reg, _replaceWith);
            }
            let n = 0;
            return _textToSearch.replace(reg, (text) => (++n === _occurrenceNumber ? _replaceWith : text));
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // TEXTJOIN
    // -----------------------------------------------------------------------------
    const TEXTJOIN = {
        description: _lt("Combines text from multiple strings and/or arrays."),
        args: args(`
      delimiter (string) ${_lt(" A string, possible empty, or a reference to a valid string. If empty, the text will be simply concatenated.")}
      ignore_empty (boolean) ${_lt("A boolean; if TRUE, empty cells selected in the text arguments won't be included in the result.")}
      text1 (string, range<string>) ${_lt("Any text item. This could be a string, or an array of strings in a range.")}
      text2 (string, range<string>, repeating) ${_lt("Additional text item(s).")}
  `),
        returns: ["STRING"],
        compute: function (delimiter, ignoreEmpty, ...textsOrArrays) {
            const _delimiter = toString(delimiter);
            const _ignoreEmpty = toBoolean(ignoreEmpty);
            let n = 0;
            return reduceAny(textsOrArrays, (acc, a) => !(_ignoreEmpty && toString(a) === "") ? (n++ ? acc + _delimiter : "") + toString(a) : acc, "");
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // TRIM
    // -----------------------------------------------------------------------------
    const TRIM = {
        description: _lt("Removes space characters."),
        args: args(`
      text (string) ${_lt("The text or reference to a cell containing text to be trimmed.")}
  `),
        returns: ["STRING"],
        compute: function (text) {
            return toString(text).trim();
        },
        isExported: true,
    };
    // -----------------------------------------------------------------------------
    // UPPER
    // -----------------------------------------------------------------------------
    const UPPER = {
        description: _lt("Converts a specified string to uppercase."),
        args: args(`
      text (string) ${_lt("The string to convert to uppercase.")}
  `),
        returns: ["STRING"],
        compute: function (text) {
            return toString(text).toUpperCase();
        },
        isExported: true,
    };

    var text = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CHAR: CHAR,
        CONCATENATE: CONCATENATE,
        EXACT: EXACT,
        FIND: FIND,
        JOIN: JOIN,
        LEFT: LEFT,
        LEN: LEN,
        LOWER: LOWER,
        REPLACE: REPLACE,
        RIGHT: RIGHT,
        SEARCH: SEARCH,
        SUBSTITUTE: SUBSTITUTE,
        TEXTJOIN: TEXTJOIN,
        TRIM: TRIM,
        UPPER: UPPER
    });

    const functions$4 = {
        database,
        date,
        financial,
        info,
        lookup,
        logical,
        math,
        operators,
        statistical,
        text,
    };
    //------------------------------------------------------------------------------
    // Function registry
    //------------------------------------------------------------------------------
    class FunctionRegistry extends Registry {
        constructor() {
            super(...arguments);
            this.mapping = {};
        }
        add(name, addDescr) {
            name = name.toUpperCase().replace("_", ".");
            const descr = addMetaInfoFromArg(addDescr);
            validateArguments(descr.args);
            this.mapping[name] = descr.compute;
            super.add(name, descr);
            return this;
        }
    }
    const functionRegistry = new FunctionRegistry();
    for (let category in functions$4) {
        const fns = functions$4[category];
        for (let name in fns) {
            const addDescr = fns[name];
            addDescr.category = category;
            functionRegistry.add(name, { isExported: false, ...addDescr });
        }
    }

    /**
     * Tokenizer
     *
     * A tokenizer is a piece of code whose job is to transform a string into a list
     * of "tokens". For example, "(12+" is converted into:
     *   [{type: "LEFT_PAREN", value: "("},
     *    {type: "NUMBER", value: "12"},
     *    {type: "OPERATOR", value: "+"}]
     *
     * As the example shows, a tokenizer does not care about the meaning behind those
     * tokens. It only cares about the structure.
     *
     * The tokenizer is usually the first step in a compilation pipeline.  Also, it
     * is useful for the composer, which needs to be able to work with incomplete
     * formulas.
     */
    const dependencyIdentifierRegex = /^[S|N]?\d+/;
    const functions$3 = functionRegistry.content;
    const OPERATORS = "+,-,*,/,:,=,<>,>=,>,<=,<,%,^,&".split(",");
    function tokenize(str) {
        const chars = str.split("");
        const result = [];
        let tokenCount = 0;
        while (chars.length) {
            tokenCount++;
            if (tokenCount > 100) {
                throw new Error(_lt("This formula has over 100 parts. It can't be processed properly, consider splitting it into multiple cells"));
            }
            let token = tokenizeSpace(chars) ||
                tokenizeMisc(chars) ||
                tokenizeOperator(chars) ||
                tokenizeString(chars) ||
                tokenizeDebugger(chars) ||
                tokenizeNormalizedReferences(chars) ||
                tokenizeInvalidRange(chars) ||
                tokenizeNumber(chars) ||
                tokenizeSymbol(chars);
            if (!token) {
                token = { type: "UNKNOWN", value: chars.shift() };
            }
            result.push(token);
        }
        return result;
    }
    function tokenizeNormalizedReferences(chars) {
        if (chars[0] === FORMULA_REF_IDENTIFIER) {
            chars.shift(); // consume the | even if it is incorrect
            const match = chars.join("").match(dependencyIdentifierRegex);
            if (match) {
                chars.splice(0, match[0].length);
            }
            else {
                return null;
            }
            if (chars[0] === FORMULA_REF_IDENTIFIER) {
                chars.shift();
            }
            const value = match[0];
            switch (value[0]) {
                case "S":
                    return { type: "NORMALIZED_STRING", value: value.substring(1) };
                case "N":
                    return { type: "NORMALIZED_NUMBER", value: value.substring(1) };
                default:
                    return { type: "REFERENCE", value };
            }
        }
        return null;
    }
    function tokenizeDebugger(chars) {
        if (chars[0] === "?") {
            chars.shift();
            return { type: "DEBUGGER", value: "?" };
        }
        return null;
    }
    const misc = {
        ",": "COMMA",
        "(": "LEFT_PAREN",
        ")": "RIGHT_PAREN",
    };
    function tokenizeMisc(chars) {
        if (chars[0] in misc) {
            const value = chars.shift();
            const type = misc[value];
            return { type, value };
        }
        return null;
    }
    function startsWith(chars, op) {
        for (let i = 0; i < op.length; i++) {
            if (op[i] !== chars[i]) {
                return false;
            }
        }
        return true;
    }
    function tokenizeOperator(chars) {
        for (let op of OPERATORS) {
            if (startsWith(chars, op)) {
                chars.splice(0, op.length);
                return { type: "OPERATOR", value: op };
            }
        }
        return null;
    }
    function tokenizeNumber(chars) {
        const match = chars.join("").match(formulaNumberRegexp);
        if (match) {
            chars.splice(0, match[0].length);
            return { type: "NUMBER", value: match[0] };
        }
        return null;
    }
    function tokenizeString(chars) {
        if (chars[0] === '"') {
            const startChar = chars.shift();
            const letters = [startChar];
            while (chars[0] && (chars[0] !== startChar || letters[letters.length - 1] === "\\")) {
                letters.push(chars.shift());
            }
            if (chars[0] === '"') {
                letters.push(chars.shift());
            }
            return {
                type: "STRING",
                value: letters.join(""),
            };
        }
        return null;
    }
    const separatorRegexp = /\w|\.|!|\$/;
    /**
     * A "Symbol" is just basically any word-like element that can appear in a
     * formula, which is not a string. So:
     *   A1
     *   SUM
     *   CEILING.MATH
     *   A$1
     *   Sheet2!A2
     *   'Sheet 2'!A2
     *
     * are examples of symbols
     */
    function tokenizeSymbol(chars) {
        const result = [];
        // there are two main cases to manage: either something which starts with
        // a ', like 'Sheet 2'A2, or a word-like element.
        if (chars[0] === "'") {
            let lastChar = chars.shift();
            result.push(lastChar);
            while (chars[0]) {
                lastChar = chars.shift();
                result.push(lastChar);
                if (lastChar === "'") {
                    if (chars[0] && chars[0] === "'") {
                        lastChar = chars.shift();
                        result.push(lastChar);
                    }
                    else {
                        break;
                    }
                }
            }
            if (lastChar !== "'") {
                return {
                    type: "UNKNOWN",
                    value: result.join(""),
                };
            }
        }
        while (chars[0] && chars[0].match(separatorRegexp)) {
            result.push(chars.shift());
        }
        if (result.length) {
            const value = result.join("");
            const isFunction = value.toUpperCase() in functions$3;
            const type = isFunction ? "FUNCTION" : "SYMBOL";
            return { type, value };
        }
        return null;
    }
    const whiteSpaceRegexp = /\s/;
    function tokenizeSpace(chars) {
        let length = 0;
        while (chars[0] && chars[0].match(whiteSpaceRegexp)) {
            length++;
            chars.shift();
        }
        if (length) {
            return { type: "SPACE", value: " ".repeat(length) };
        }
        return null;
    }
    function tokenizeInvalidRange(chars) {
        if (startsWith(chars, INCORRECT_RANGE_STRING)) {
            chars.splice(0, INCORRECT_RANGE_STRING.length);
            return { type: "INVALID_REFERENCE", value: INCORRECT_RANGE_STRING };
        }
        return null;
    }

    const UNARY_OPERATORS = ["-", "+"];
    const ASSOCIATIVE_OPERATORS = ["*", "+", "&"];
    const OP_PRIORITY = {
        "^": 30,
        "*": 20,
        "/": 20,
        "+": 15,
        "-": 15,
        "&": 13,
        ">": 10,
        "<>": 10,
        ">=": 10,
        "<": 10,
        "<=": 10,
        "=": 10,
    };
    const FUNCTION_BP = 6;
    function bindingPower(token) {
        switch (token.type) {
            case "NUMBER":
            case "SYMBOL":
                return 0;
            case "COMMA":
                return 3;
            case "LEFT_PAREN":
                return 5;
            case "RIGHT_PAREN":
                return 5;
            case "OPERATOR":
                return OP_PRIORITY[token.value] || 15;
        }
        throw new Error(_lt("Unknown token: %s", token.value));
    }
    function parsePrefix(current, tokens) {
        var _a;
        switch (current.type) {
            case "DEBUGGER":
                const next = parseExpression(tokens, 1000);
                next.debug = true;
                return next;
            case "NUMBER":
                return { type: "NUMBER", value: parseNumber(current.value) };
            case "NORMALIZED_NUMBER":
                return { type: "NORMALIZED_NUMBER", value: parseInt(current.value, 10) };
            case "STRING":
                return { type: "STRING", value: current.value };
            case "NORMALIZED_STRING":
                return { type: "NORMALIZED_STRING", value: parseInt(current.value, 10) };
            case "FUNCTION":
                if (tokens.shift().type !== "LEFT_PAREN") {
                    throw new Error(_lt("Wrong function call"));
                }
                else {
                    const args = [];
                    if (tokens[0] && tokens[0].type !== "RIGHT_PAREN") {
                        if (tokens[0].type === "COMMA") {
                            args.push({ type: "UNKNOWN", value: "" });
                        }
                        else {
                            args.push(parseExpression(tokens, FUNCTION_BP));
                        }
                        while (((_a = tokens[0]) === null || _a === void 0 ? void 0 : _a.type) === "COMMA") {
                            tokens.shift();
                            const token = tokens[0];
                            if ((token === null || token === void 0 ? void 0 : token.type) === "RIGHT_PAREN") {
                                args.push({ type: "UNKNOWN", value: "" });
                                break;
                            }
                            else if ((token === null || token === void 0 ? void 0 : token.type) === "COMMA") {
                                args.push({ type: "UNKNOWN", value: "" });
                            }
                            else {
                                args.push(parseExpression(tokens, FUNCTION_BP));
                            }
                        }
                    }
                    const closingToken = tokens.shift();
                    if (!closingToken || closingToken.type !== "RIGHT_PAREN") {
                        throw new Error(_lt("Wrong function call"));
                    }
                    return { type: "FUNCALL", value: current.value, args };
                }
            case "REFERENCE":
                return {
                    type: "NORMALIZED_REFERENCE",
                    value: parseInt(current.value, 10),
                };
            case "INVALID_REFERENCE":
                throw new Error(_lt("Invalid reference"));
            case "SYMBOL":
                if (cellReference.test(current.value)) {
                    return {
                        type: "REFERENCE",
                        value: current.value,
                    };
                }
                else {
                    if (["TRUE", "FALSE"].includes(current.value.toUpperCase())) {
                        return { type: "BOOLEAN", value: current.value.toUpperCase() === "TRUE" };
                    }
                    else {
                        if (current.value) {
                            throw new Error(_lt("Invalid formula"));
                        }
                        return { type: "STRING", value: current.value };
                    }
                }
            case "LEFT_PAREN":
                const result = parseExpression(tokens, 5);
                if (!tokens.length || tokens[0].type !== "RIGHT_PAREN") {
                    throw new Error(_lt("Unmatched left parenthesis"));
                }
                tokens.shift();
                return result;
            default:
                if (current.type === "OPERATOR" && UNARY_OPERATORS.includes(current.value)) {
                    return {
                        type: "UNARY_OPERATION",
                        value: current.value,
                        right: parseExpression(tokens, OP_PRIORITY[current.value]),
                    };
                }
                throw new Error(_lt("Unexpected token: %s", current.value));
        }
    }
    function parseInfix(left, current, tokens) {
        if (current.type === "OPERATOR") {
            const bp = bindingPower(current);
            const right = parseExpression(tokens, bp);
            return {
                type: "BIN_OPERATION",
                value: current.value,
                left,
                right,
            };
        }
        throw new Error(DEFAULT_ERROR_MESSAGE);
    }
    function parseExpression(tokens, bp) {
        const token = tokens.shift();
        if (!token) {
            throw new Error(DEFAULT_ERROR_MESSAGE);
        }
        let expr = parsePrefix(token, tokens);
        while (tokens[0] && bindingPower(tokens[0]) > bp) {
            expr = parseInfix(expr, tokens.shift(), tokens);
        }
        return expr;
    }
    /**
     * Parse an expression (as a string) into an AST.
     */
    function parse(str) {
        const tokens = tokenize(str).filter((x) => x.type !== "SPACE");
        if (tokens[0].type === "OPERATOR" && tokens[0].value === "=") {
            tokens.splice(0, 1);
        }
        const result = parseExpression(tokens, 0);
        if (tokens.length) {
            throw new Error(DEFAULT_ERROR_MESSAGE);
        }
        return result;
    }
    /**
     * Allows to visit all nodes of an AST and apply a mapping function
     * to nodes of a specific type.
     * Useful if you want to convert some part of a formula.
     *
     * e.g.
     * ```ts
     * convertAstNodes(ast, "FUNCALL", convertFormulaToExcel)
     *
     * function convertFormulaToExcel(ast: ASTFuncall) {
     *   // ...
     *   return modifiedAst
     * }
     * ```
     */
    function convertAstNodes(ast, type, fn) {
        if (type === ast.type) {
            ast = fn(ast);
        }
        switch (ast.type) {
            case "FUNCALL":
                return {
                    ...ast,
                    args: ast.args.map((child) => convertAstNodes(child, type, fn)),
                };
            case "UNARY_OPERATION":
                return {
                    ...ast,
                    right: convertAstNodes(ast.right, type, fn),
                };
            case "BIN_OPERATION":
                return {
                    ...ast,
                    right: convertAstNodes(ast.right, type, fn),
                    left: convertAstNodes(ast.left, type, fn),
                };
            default:
                return ast;
        }
    }
    /**
     * Converts an ast formula to the corresponding string
     */
    function astToFormula(ast, dependencies = { references: [], numbers: [], strings: [] }) {
        switch (ast.type) {
            case "FUNCALL":
                const args = ast.args.map((arg) => astToFormula(arg, dependencies));
                return `${ast.value}(${args.join(",")})`;
            case "NUMBER":
                return ast.value.toString();
            case "NORMALIZED_STRING":
                return `"${dependencies.strings[ast.value]}"`;
            case "NORMALIZED_NUMBER":
                return dependencies.numbers[ast.value].toString();
            case "NORMALIZED_REFERENCE":
                return dependencies.references[ast.value].toString();
            case "REFERENCE":
            case "STRING":
                return ast.value;
            case "BOOLEAN":
                return ast.value ? "TRUE" : "FALSE";
            case "UNARY_OPERATION":
                return ast.value + rightOperandToFormula(ast, dependencies);
            case "BIN_OPERATION":
                return (leftOperandToFormula(ast, dependencies) +
                    ast.value +
                    rightOperandToFormula(ast, dependencies));
            default:
                return ast.value;
        }
    }
    /**
     * Convert the left operand of a binary operation to the corresponding string
     * and enclose the result inside parenthesis if necessary.
     */
    function leftOperandToFormula(binaryOperationAST, dependencies) {
        const mainOperator = binaryOperationAST.value;
        const leftOperation = binaryOperationAST.left;
        const leftOperator = leftOperation.value;
        const needParenthesis = leftOperation.type === "BIN_OPERATION" && OP_PRIORITY[leftOperator] < OP_PRIORITY[mainOperator];
        return needParenthesis
            ? `(${astToFormula(leftOperation, dependencies)})`
            : astToFormula(leftOperation, dependencies);
    }
    /**
     * Convert the right operand of a binary or unary operation to the corresponding string
     * and enclose the result inside parenthesis if necessary.
     */
    function rightOperandToFormula(binaryOperationAST, dependencies) {
        const mainOperator = binaryOperationAST.value;
        const rightOperation = binaryOperationAST.right;
        const rightPriority = OP_PRIORITY[rightOperation.value];
        const mainPriority = OP_PRIORITY[mainOperator];
        let needParenthesis = false;
        if (rightOperation.type !== "BIN_OPERATION") {
            needParenthesis = false;
        }
        else if (rightPriority < mainPriority) {
            needParenthesis = true;
        }
        else if (rightPriority === mainPriority && !ASSOCIATIVE_OPERATORS.includes(mainOperator)) {
            needParenthesis = true;
        }
        return needParenthesis
            ? `(${astToFormula(rightOperation, dependencies)})`
            : astToFormula(rightOperation, dependencies);
    }

    const functions$2 = functionRegistry.content;
    const OPERATOR_MAP = {
        "=": "EQ",
        "+": "ADD",
        "-": "MINUS",
        "*": "MULTIPLY",
        "/": "DIVIDE",
        ">=": "GTE",
        "<>": "NE",
        ">": "GT",
        "<=": "LTE",
        "<": "LT",
        "^": "POWER",
        "&": "CONCATENATE",
    };
    const UNARY_OPERATOR_MAP = {
        "-": "UMINUS",
        "+": "UPLUS",
    };
    /**
     * Takes a list of strings that might be single or multiline
     * and maps them in a list of single line strings.
     */
    function splitCodeLines(codeBlocks) {
        return codeBlocks
            .map((code) => code.split("\n"))
            .flat()
            .filter((line) => line.trim() !== "");
    }
    // this cache contains all compiled function code, grouped by "structure". For
    // example, "=2*sum(A1:A4)" and "=2*sum(B1:B4)" are compiled into the same
    // structural function.
    // It is only exported for testing purposes
    const functionCache = {};
    // -----------------------------------------------------------------------------
    // COMPILER
    // -----------------------------------------------------------------------------
    function compile(formula) {
        if (!functionCache[formula.text]) {
            const ast = parse(formula.text);
            let nextId = 1;
            if (ast.type === "BIN_OPERATION" && ast.value === ":") {
                throw new Error(_lt("Invalid formula"));
            }
            if (ast.type === "UNKNOWN") {
                throw new Error(_lt("Invalid formula"));
            }
            const compiledAST = compileAST(ast);
            const code = splitCodeLines([
                `// ${formula.text}`,
                compiledAST.code,
                `return ${compiledAST.id};`,
            ]).join("\n");
            let baseFunction = new Function("deps", // the dependencies in the current formula
            "sheetId", // the sheet the formula is currently evaluating
            "ref", // a function to access a certain dependency at a given index
            "range", // same as above, but guarantee that the result is in the form of a range
            "ctx", code);
            //@ts-ignore
            functionCache[formula.text] = baseFunction;
            functionCache[formula.text].dependenciesFormat = formatAST(ast);
            /**
             * This function compile the function arguments. It is mostly straightforward,
             * except that there is a non trivial transformation in one situation:
             *
             * If a function argument is asking for a range, and get a cell, we transform
             * the cell value into a range. This allow the grid model to differentiate
             * between a cell value and a non cell value.
             */
            function compileFunctionArgs(ast) {
                const functionDefinition = functions$2[ast.value.toUpperCase()];
                const currentFunctionArguments = ast.args;
                // check if arguments are supplied in the correct quantities
                const nbrArg = currentFunctionArguments.length;
                if (nbrArg < functionDefinition.minArgRequired) {
                    throw new Error(_lt("Invalid number of arguments for the %s function. Expected %s minimum, but got %s instead.", ast.value.toUpperCase(), functionDefinition.minArgRequired.toString(), nbrArg.toString()));
                }
                if (nbrArg > functionDefinition.maxArgPossible) {
                    throw new Error(_lt("Invalid number of arguments for the %s function. Expected %s maximum, but got %s instead.", ast.value.toUpperCase(), functionDefinition.maxArgPossible.toString(), nbrArg.toString()));
                }
                const repeatingArg = functionDefinition.nbrArgRepeating;
                if (repeatingArg > 1) {
                    const argBeforeRepeat = functionDefinition.args.length - repeatingArg;
                    const nbrRepeatingArg = nbrArg - argBeforeRepeat;
                    if (nbrRepeatingArg % repeatingArg !== 0) {
                        throw new Error(_lt("Invalid number of arguments for the %s function. Expected all arguments after position %s to be supplied by groups of %s arguments", ast.value.toUpperCase(), argBeforeRepeat.toString(), repeatingArg.toString()));
                    }
                }
                let listArgs = [];
                for (let i = 0; i < nbrArg; i++) {
                    const argPosition = functionDefinition.getArgToFocus(i + 1) - 1;
                    if (0 <= argPosition && argPosition < functionDefinition.args.length) {
                        const currentArg = currentFunctionArguments[i];
                        const argDefinition = functionDefinition.args[argPosition];
                        const argTypes = argDefinition.type || [];
                        // detect when an argument need to be evaluated as a meta argument
                        const isMeta = argTypes.includes("META");
                        // detect when an argument need to be evaluated as a lazy argument
                        const isLazy = argDefinition.lazy;
                        const hasRange = argTypes.some((t) => t === "RANGE" ||
                            t === "RANGE<BOOLEAN>" ||
                            t === "RANGE<DATE>" ||
                            t === "RANGE<NUMBER>" ||
                            t === "RANGE<STRING>");
                        const isRangeOnly = argTypes.every((t) => t === "RANGE" ||
                            t === "RANGE<BOOLEAN>" ||
                            t === "RANGE<DATE>" ||
                            t === "RANGE<NUMBER>" ||
                            t === "RANGE<STRING>");
                        if (isRangeOnly) {
                            if (currentArg.type !== "NORMALIZED_REFERENCE") {
                                throw new Error(_lt("Function %s expects the parameter %s to be reference to a cell or range, not a %s.", ast.value.toUpperCase(), (i + 1).toString(), currentArg.type.toLowerCase().replace("normalized_", "")));
                            }
                        }
                        const compiledAST = compileAST(currentArg, isLazy, isMeta, hasRange, {
                            functionName: ast.value.toUpperCase(),
                            paramIndex: i + 1,
                        });
                        listArgs.push(compiledAST);
                    }
                }
                return listArgs;
            }
            /**
             * This function compiles all the information extracted by the parser into an
             * executable code for the evaluation of the cells content. It uses a cash to
             * not reevaluate identical code structures.
             *
             * The function is sensitive to two parameters “isLazy” and “isMeta”. These
             * parameters may vary when compiling function arguments:
             *
             * - isLazy: In some cases the function arguments does not need to be
             * evaluated before entering the functions. For example the IF function might
             * take invalid arguments that do not need to be evaluate and thus should not
             * create an error. For this we have lazy arguments.
             *
             * - isMeta: In some cases the function arguments expects information on the
             * cell/range other than the associated value(s). For example the COLUMN
             * function needs to receive as argument the coordinates of a cell rather
             * than its value. For this we have meta arguments.
             */
            function compileAST(ast, isLazy = false, isMeta = false, hasRange = false, referenceVerification = {}) {
                const codeBlocks = [];
                let id, fnName, statement;
                if (ast.type !== "NORMALIZED_REFERENCE" &&
                    !(ast.type === "BIN_OPERATION" && ast.value === ":")) {
                    if (isMeta) {
                        throw new Error(_lt(`Argument must be a reference to a cell or range.`));
                    }
                }
                if (ast.debug) {
                    codeBlocks.push("debugger;");
                }
                switch (ast.type) {
                    case "BOOLEAN":
                    case "NUMBER": // probably dead case
                    case "STRING": // probably dead case
                        if (!isLazy) {
                            return { id: ast.value, code: "" };
                        }
                        id = nextId++;
                        statement = `${ast.value}`;
                        break;
                    case "NORMALIZED_NUMBER":
                        id = nextId++;
                        statement = `deps.numbers[${ast.value}]`;
                        break;
                    case "NORMALIZED_STRING":
                        id = nextId++;
                        statement = `deps.strings[${ast.value}]`;
                        break;
                    case "REFERENCE":
                        throw new Error(`Only normalized references can be compiled: ${ast.value}`);
                    case "NORMALIZED_REFERENCE":
                        const referenceIndex = formula.dependencies.references[ast.value];
                        if (!referenceIndex) {
                            id = nextId++;
                            statement = `null`;
                            break;
                        }
                        id = nextId++;
                        if (hasRange) {
                            statement = `range(${ast.value}, deps.references, sheetId)`;
                        }
                        else {
                            statement = `ref(${ast.value}, deps.references, sheetId, ${isMeta ? "true" : "false"}, "${referenceVerification.functionName || OPERATOR_MAP["="]}",  ${referenceVerification.paramIndex})`;
                        }
                        break;
                    case "FUNCALL":
                        id = nextId++;
                        const args = compileFunctionArgs(ast);
                        codeBlocks.push(splitCodeLines(args.map((arg) => arg.code)).join("\n"));
                        fnName = ast.value.toUpperCase();
                        codeBlocks.push(`ctx.__lastFnCalled = '${fnName}';`);
                        statement = `ctx['${fnName}'](${args.map((arg) => arg.id)})`;
                        break;
                    case "UNARY_OPERATION": {
                        id = nextId++;
                        fnName = UNARY_OPERATOR_MAP[ast.value];
                        const right = compileAST(ast.right, false, false, false, {
                            functionName: fnName,
                        });
                        codeBlocks.push(right.code);
                        codeBlocks.push(`ctx.__lastFnCalled = '${fnName}';`);
                        statement = `ctx['${fnName}']( ${right.id})`;
                        break;
                    }
                    case "BIN_OPERATION": {
                        id = nextId++;
                        fnName = OPERATOR_MAP[ast.value];
                        const left = compileAST(ast.left, false, false, false, {
                            functionName: fnName,
                        });
                        const right = compileAST(ast.right, false, false, false, {
                            functionName: fnName,
                        });
                        codeBlocks.push(left.code);
                        codeBlocks.push(right.code);
                        codeBlocks.push(`ctx.__lastFnCalled = '${fnName}';`);
                        statement = `ctx['${fnName}'](${left.id}, ${right.id})`;
                        break;
                    }
                    case "UNKNOWN":
                        if (!isLazy) {
                            return { id: "undefined", code: "" };
                        }
                        id = nextId++;
                        statement = `undefined`;
                        break;
                }
                if (isLazy) {
                    const lazyFunction = `const _${id} = () => {\n` +
                        `\t${splitCodeLines(codeBlocks).join("\n\t")}\n` +
                        `\treturn ${statement};\n` +
                        "}";
                    return { id: `_${id}`, code: lazyFunction };
                }
                else {
                    codeBlocks.push(`let _${id} = ${statement};`);
                    return { id: `_${id}`, code: splitCodeLines(codeBlocks).join("\n") };
                }
            }
            /** Return a stack of formats corresponding to the priorities in which
             * formats should be tested.
             *
             * If the value of the stack is a number it corresponds to a dependency from
             * which the format can be inferred.
             *
             * If the value is a string it corresponds to a literal format which can be
             * applied directly.
             * */
            function formatAST(ast) {
                let fnDef;
                switch (ast.type) {
                    case "NORMALIZED_REFERENCE":
                        const referenceIndex = formula.dependencies.references[ast.value];
                        if (referenceIndex) {
                            return [ast.value];
                        }
                        break;
                    case "FUNCALL":
                        fnDef = functions$2[ast.value.toUpperCase()];
                        if (fnDef.returnFormat) {
                            if (fnDef.returnFormat === "FormatFromArgument") {
                                if (ast.args.length > 0) {
                                    const argPosition = 0;
                                    const argType = fnDef.args[argPosition].type;
                                    if (!argType.includes("META")) {
                                        return formatAST(ast.args[argPosition]);
                                    }
                                }
                            }
                            else {
                                return [fnDef.returnFormat.specificFormat];
                            }
                        }
                        break;
                    case "UNARY_OPERATION":
                        return formatAST(ast.right);
                    case "BIN_OPERATION":
                        // the BIN_OPERATION ast is the only function case where we will look
                        // at the following argument when the current argument has't format.
                        // So this is the only place where the stack can grow.
                        fnDef = functions$2[OPERATOR_MAP[ast.value]];
                        if (fnDef.returnFormat) {
                            if (fnDef.returnFormat === "FormatFromArgument") {
                                const left = formatAST(ast.left);
                                // as a string represents a safe format, we don't need to know the
                                // format of the following arguments.
                                if (typeof left[left.length - 1] === "string") {
                                    return left;
                                }
                                const right = formatAST(ast.right);
                                return left.concat(right);
                            }
                            else {
                                return [fnDef.returnFormat.specificFormat];
                            }
                        }
                        break;
                }
                return [];
            }
        }
        return functionCache[formula.text];
    }

    /**
     * finds a sequence of token that represent a range and replace them with a single token
     * The range can be
     *  ?spaces symbol ?spaces operator: ?spaces symbol ?spaces
     */
    function mergeSymbolsIntoRanges(result, removeSpace = false) {
        let operator = undefined;
        let refStart = undefined;
        let refEnd = undefined;
        let startIncludingSpaces = undefined;
        const reset = () => {
            startIncludingSpaces = undefined;
            refStart = undefined;
            operator = undefined;
            refEnd = undefined;
        };
        for (let i = 0; i < result.length; i++) {
            const token = result[i];
            if (startIncludingSpaces) {
                if (refStart) {
                    if (token.type === "SPACE") {
                        continue;
                    }
                    else if (token.type === "OPERATOR" && token.value === ":") {
                        operator = i;
                    }
                    else if (operator && token.type === "SYMBOL") {
                        refEnd = i;
                    }
                    else {
                        if (startIncludingSpaces && refStart && operator && refEnd) {
                            const newToken = {
                                type: "SYMBOL",
                                value: result
                                    .slice(startIncludingSpaces, i)
                                    .filter((x) => !removeSpace || x.type !== "SPACE")
                                    .map((x) => x.value)
                                    .join(""),
                            };
                            result.splice(startIncludingSpaces, i - startIncludingSpaces, newToken);
                            i = startIncludingSpaces + 1;
                            reset();
                        }
                        else {
                            if (token.type === "SYMBOL") {
                                startIncludingSpaces = i;
                                refStart = i;
                                operator = undefined;
                            }
                            else {
                                reset();
                            }
                        }
                    }
                }
                else {
                    if (token.type === "SYMBOL") {
                        refStart = i;
                        operator = refEnd = undefined;
                    }
                    else {
                        reset();
                    }
                }
            }
            else {
                if (["SPACE", "SYMBOL"].includes(token.type)) {
                    startIncludingSpaces = i;
                    refStart = token.type === "SYMBOL" ? i : undefined;
                    operator = refEnd = undefined;
                }
                else {
                    reset();
                }
            }
        }
        const i = result.length - 1;
        if (startIncludingSpaces && refStart && operator && refEnd) {
            const newToken = {
                type: "SYMBOL",
                value: result
                    .slice(startIncludingSpaces, i + 1)
                    .filter((x) => !removeSpace || x.type !== "SPACE")
                    .map((x) => x.value)
                    .join(""),
            };
            result.splice(startIncludingSpaces, i - startIncludingSpaces + 1, newToken);
        }
        return result;
    }
    /**
     * Take the result of the tokenizer and transform it to be usable in the
     * manipulations of range
     *
     * @param formula
     */
    function rangeTokenize(formula) {
        const tokens = tokenize(formula);
        return mergeSymbolsIntoRanges(tokens, true);
    }

    /**
     * Add the following information on tokens:
     * - length
     * - start
     * - end
     */
    function enrichTokens(tokens) {
        let current = 0;
        return tokens.map((x) => {
            const len = x.value.toString().length;
            const token = Object.assign({}, x, {
                start: current,
                end: current + len,
                length: len,
            });
            current = token.end;
            return token;
        });
    }
    /**
     * add on each token the length, start and end
     * also matches the opening to its closing parenthesis (using the same number)
     */
    function mapParenthesis(tokens) {
        let maxParen = 1;
        const stack = [];
        return tokens.map((token) => {
            if (token.type === "LEFT_PAREN") {
                stack.push(maxParen);
                token.parenIndex = maxParen;
                maxParen++;
            }
            else if (token.type === "RIGHT_PAREN") {
                token.parenIndex = stack.pop();
            }
            return token;
        });
    }
    /**
     * add on each token its parent function and the index corresponding to
     * its position as an argument of the function.
     * In this example "=MIN(42,SUM(MAX(1,2),3))":
     * - the parent function of the token correspond to number 42 is the MIN function
     * - the argument position of the token correspond to number 42 is 0
     * - the parent function of the token correspond to number 3 is the SUM function
     * - the argument position of the token correspond to number 3 is 1
     */
    function mapParentFunction(tokens) {
        let stack = [];
        let functionStarted = "";
        const res = tokens.map((token, i) => {
            if (!["SPACE", "LEFT_PAREN"].includes(token.type)) {
                functionStarted = "";
            }
            switch (token.type) {
                case "FUNCTION":
                    functionStarted = token.value;
                    break;
                case "LEFT_PAREN":
                    stack.push({ parent: functionStarted, argPosition: 0 });
                    functionStarted = "";
                    break;
                case "RIGHT_PAREN":
                    stack.pop();
                    break;
                case "COMMA":
                    if (stack.length) {
                        // increment position on current function
                        stack[stack.length - 1].argPosition++;
                    }
                    break;
            }
            if (stack.length) {
                const functionContext = stack[stack.length - 1];
                if (functionContext.parent) {
                    token.functionContext = Object.assign({}, functionContext);
                }
            }
            return token;
        });
        return res;
    }
    /**
     * Take the result of the tokenizer and transform it to be usable in the composer.
     *
     * @param formula
     */
    function composerTokenize(formula) {
        const tokens = tokenize(formula);
        return mapParentFunction(mapParenthesis(enrichTokens(mergeSymbolsIntoRanges(tokens))));
    }

    /**
     * parses a formula (as a string) into the same formula,
     * but with the references to other cells as well as strings and numbers extracted
     *
     * =sum(a3:b1) + c3 --> =sum(|0|) + |1|
     *
     * = sum(a3, 5) --> =sum(|0|, |N1|)
     *
     * =CONCAT(CONCAT(1, "beta"), A1) --> =CONCAT(CONCAT(|N0|, |S1|), |2|)
     *
     * Strings and Numbers are marked with a prefix of their type (S and N) to be detected
     * as their normalized form by the parser as they won't be processed like the references by the compiler.
     *
     * @param formula
     */
    function normalize(formula) {
        const tokens = rangeTokenize(formula);
        let dependencies = {
            numbers: [],
            strings: [],
            references: [],
        };
        let noRefFormula = "".concat(...tokens.map((token) => {
            if (token.type === "SYMBOL" && cellReference.test(token.value)) {
                const value = token.value.trim();
                if (!dependencies.references.includes(value)) {
                    dependencies.references.push(value);
                }
                const index = dependencies.references.indexOf(value).toString();
                return formatIndex(index);
            }
            else if ("STRING" === token.type) {
                const value = token.value.slice(1).slice(0, token.value.length - 2);
                if (!dependencies.strings.includes(value)) {
                    dependencies.strings.push(value);
                }
                const index = dependencies.strings.indexOf(value);
                return formatIndex(`${token.type[0]}${index}`);
            }
            else if (token.type === "NUMBER") {
                const value = parseNumber(token.value);
                if (!dependencies.numbers.includes(value)) {
                    dependencies.numbers.push(value);
                }
                const index = dependencies.numbers.indexOf(value);
                return formatIndex(`${token.type[0]}${index}`);
            }
            else {
                return token.value;
            }
        }));
        return { text: noRefFormula, dependencies };
    }
    /**
     * Enclose an index between normalization identifiers
     */
    function formatIndex(index) {
        return `${FORMULA_REF_IDENTIFIER}${index}${FORMULA_REF_IDENTIFIER}`;
    }

    /**
     * This registry is intended to map a cell content (raw string) to
     * an instance of a cell.
     */
    const cellRegistry = new Registry();

    /**
     * Format a cell value with its format.
     */
    function formatValue(value, format) {
        switch (typeof value) {
            case "string":
                return value;
            case "boolean":
                return value ? "TRUE" : "FALSE";
            case "number":
                if (format === null || format === void 0 ? void 0 : format.match(DATETIME_FORMAT)) {
                    return formatDateTime({ value, format: format });
                }
                return format ? formatNumber(value, format) : formatStandardNumber(value);
            case "object":
                return "0";
        }
    }
    /**
     * Parse a string representing a primitive cell value
     */
    function parsePrimitiveContent(content) {
        if (content === "") {
            return "";
        }
        else if (isNumber(content)) {
            return parseNumber(content);
        }
        else if (isBoolean(content)) {
            return content.toUpperCase() === "TRUE" ? true : false;
        }
        else if (isDateTime(content)) {
            return parseDateTime(content).value;
        }
        else {
            return content;
        }
    }
    /**
     * Try to infer the cell format based on the formula dependencies.
     * e.g. if the formula is `=A1` and A1 has a given format, the
     * same format will be used.
     */
    function computeFormulaFormat(sheets, compiledFormula, dependencies) {
        var _a;
        const dependenciesFormat = compiledFormula.dependenciesFormat;
        for (let dependencyFormat of dependenciesFormat) {
            switch (typeof dependencyFormat) {
                case "string":
                    // dependencyFormat corresponds to a literal format which can be applied
                    // directly.
                    return dependencyFormat;
                case "number":
                    // dependencyFormat corresponds to a dependency cell from which we must
                    // find the cell and extract the associated format
                    const ref = dependencies[dependencyFormat];
                    const s = sheets[ref.sheetId];
                    if (s) {
                        // if the reference is a range --> the first cell in the range
                        // determines the format
                        const cellRef = (_a = s.rows[ref.zone.top]) === null || _a === void 0 ? void 0 : _a.cells[ref.zone.left];
                        if (cellRef && cellRef.format) {
                            return cellRef.format;
                        }
                    }
                    break;
            }
        }
        return NULL_FORMAT;
    }

    /**
     * Abstract base implementation of a cell.
     * Concrete cell classes are responsible to build the raw cell `content` based on
     * whatever data they have (formula, string, ...).
     */
    class AbstractCell {
        constructor(id, evaluated, properties) {
            this.id = id;
            this.evaluated = evaluated;
            this.style = properties.style;
            this.format = properties.format;
        }
        isFormula() {
            return false;
        }
        isLink() {
            return false;
        }
        isEmpty() {
            return false;
        }
        get formattedValue() {
            return formatValue(this.evaluated.value, this.format);
        }
        get composerContent() {
            return this.content;
        }
        get defaultAlign() {
            switch (this.evaluated.type) {
                case CellValueType.number:
                    return "right";
                case CellValueType.boolean:
                case CellValueType.error:
                    return "center";
                case CellValueType.text:
                case CellValueType.empty:
                    return "left";
            }
        }
        /**
         * Only empty cells, text cells and numbers are valid
         */
        get isAutoSummable() {
            var _a;
            switch (this.evaluated.type) {
                case CellValueType.empty:
                case CellValueType.text:
                    return true;
                case CellValueType.number:
                    return !((_a = this.format) === null || _a === void 0 ? void 0 : _a.match(DATETIME_FORMAT));
                case CellValueType.error:
                case CellValueType.boolean:
                    return false;
            }
        }
    }
    class EmptyCell extends AbstractCell {
        constructor(id, properties = {}) {
            super(id, { value: "", type: CellValueType.empty }, properties);
            this.content = "";
        }
        isEmpty() {
            return true;
        }
    }
    class NumberCell extends AbstractCell {
        constructor(id, value, properties = {}) {
            super(id, { value: value, type: CellValueType.number }, properties);
            this.content = formatStandardNumber(this.evaluated.value);
        }
    }
    class BooleanCell extends AbstractCell {
        constructor(id, value, properties = {}) {
            super(id, { value: value, type: CellValueType.boolean }, properties);
            this.content = this.evaluated.value ? "TRUE" : "FALSE";
        }
    }
    class TextCell extends AbstractCell {
        constructor(id, value, properties = {}) {
            super(id, { value: value, type: CellValueType.text }, properties);
            this.content = this.evaluated.value;
        }
    }
    /**
     * A date time cell is a number cell with a required
     * date time format.
     */
    class DateTimeCell extends NumberCell {
        constructor(id, value, properties) {
            super(id, value, properties);
            this.format = properties.format;
        }
        get composerContent() {
            return formatValue(this.evaluated.value, this.format);
        }
    }
    class LinkCell extends AbstractCell {
        constructor(id, content, properties = {}) {
            var _a;
            const link = parseMarkdownLink(content);
            properties = {
                ...properties,
                style: {
                    ...properties.style,
                    textColor: ((_a = properties.style) === null || _a === void 0 ? void 0 : _a.textColor) || LINK_COLOR,
                    underline: true,
                },
            };
            super(id, { value: link.label, type: CellValueType.text }, properties);
            this.link = link;
            this.content = content;
        }
        isLink() {
            return true;
        }
        get composerContent() {
            return this.link.label;
        }
    }
    /**
     * Simple web link cell
     */
    class WebLinkCell extends LinkCell {
        constructor(id, content, properties = {}) {
            super(id, content, properties);
            this.link.url = this.withHttp(this.link.url);
            this.link.isExternal = true;
            this.content = markdownLink(this.link.label, this.link.url);
            this.urlRepresentation = this.link.url;
            this.isUrlEditable = true;
        }
        action(env) {
            window.open(this.link.url, "_blank");
        }
        /**
         * Add the `https` prefix to the url if it's missing
         */
        withHttp(url) {
            return !/^https?:\/\//i.test(url) ? `https://${url}` : url;
        }
    }
    /**
     * Link redirecting to a given sheet in the workbook.
     */
    class SheetLinkCell extends LinkCell {
        constructor(id, content, properties = {}, sheetName) {
            super(id, content, properties);
            this.sheetName = sheetName;
            this.sheetId = parseSheetLink(this.link.url);
            this.isUrlEditable = false;
        }
        action(env) {
            env.dispatch("ACTIVATE_SHEET", {
                sheetIdFrom: env.getters.getActiveSheetId(),
                sheetIdTo: this.sheetId,
            });
        }
        get urlRepresentation() {
            return this.sheetName(this.sheetId) || _lt("Invalid sheet");
        }
    }
    class FormulaCell extends AbstractCell {
        constructor(buildFormulaString, id, normalizedText, compiledFormula, dependencies, properties) {
            super(id, { value: LOADING, type: CellValueType.text }, properties);
            this.buildFormulaString = buildFormulaString;
            this.normalizedText = normalizedText;
            this.compiledFormula = compiledFormula;
            this.dependencies = dependencies;
        }
        get content() {
            return this.buildFormulaString(this.normalizedText, this.dependencies);
        }
        isFormula() {
            return true;
        }
        assignValue(value) {
            switch (typeof value) {
                case "number":
                    this.evaluated = {
                        value,
                        type: CellValueType.number,
                    };
                    break;
                case "boolean":
                    this.evaluated = {
                        value,
                        type: CellValueType.boolean,
                    };
                    break;
                case "string":
                    this.evaluated = {
                        value,
                        type: CellValueType.text,
                    };
                    break;
                // `null` and `undefined` values are not allowed according to `CellValue`
                // but it actually happens with empty evaluated cells.
                // TODO fix `CellValue`
                case "object": // null
                    this.evaluated = {
                        value,
                        type: CellValueType.empty,
                    };
                    break;
                case "undefined":
                    this.evaluated = {
                        value,
                        type: CellValueType.empty,
                    };
                    break;
            }
        }
        assignError(value, errorMessage) {
            this.evaluated = {
                value,
                error: errorMessage,
                type: CellValueType.error,
            };
        }
    }
    /**
     * Cell containing a formula which could not be compiled
     * or a content which could not be parsed.
     */
    class BadExpressionCell extends AbstractCell {
        /**
         * @param id
         * @param content Invalid formula string
         * @param error Compilation or parsing error
         * @param properties
         */
        constructor(id, content, error, properties) {
            super(id, { value: "#BAD_EXPR", type: CellValueType.error, error }, properties);
            this.content = content;
        }
    }

    cellRegistry
        .add("Formula", {
        sequence: 10,
        match: (content) => content.startsWith("="),
        createCell: (id, content, properties, sheetId, getters) => {
            const formula = normalize(content);
            const normalizedText = formula.text;
            const compiledFormula = compile(formula);
            const ranges = formula.dependencies.references.map((xc) => getters.getRangeFromSheetXC(sheetId, xc));
            const format = properties.format ||
                computeFormulaFormat(getters.getEvaluationSheets(), compiledFormula, ranges);
            return new FormulaCell((normalizedText, dependencies) => getters.buildFormulaContent(sheetId, normalizedText, dependencies), id, normalizedText, compiledFormula, { ...formula.dependencies, references: ranges }, {
                ...properties,
                format,
            });
        },
    })
        .add("Empty", {
        sequence: 20,
        match: (content) => content === "",
        createCell: (id, content, properties) => new EmptyCell(id, properties),
    })
        .add("Number", {
        sequence: 30,
        match: (content) => isNumber(content),
        createCell: (id, content, properties) => {
            if (!properties.format && content.includes("%")) {
                properties.format = content.includes(".") ? "0.00%" : "0%";
            }
            return new NumberCell(id, parseNumber(content), properties);
        },
    })
        .add("Boolean", {
        sequence: 40,
        match: (content) => isBoolean(content),
        createCell: (id, content, properties) => {
            return new BooleanCell(id, content.toUpperCase() === "TRUE" ? true : false, properties);
        },
    })
        .add("DateTime", {
        sequence: 50,
        match: (content) => isDateTime(content),
        createCell: (id, content, properties) => {
            const internalDate = parseDateTime(content);
            const format = properties.format || internalDate.format;
            return new DateTimeCell(id, internalDate.value, { ...properties, format });
        },
    })
        .add("MarkdownSheetLink", {
        sequence: 60,
        match: (content) => isMarkdownSheetLink(content),
        createCell: (id, content, properties, sheetId, getters) => {
            return new SheetLinkCell(id, content, properties, (sheetId) => getters.tryGetSheetName(sheetId));
        },
    })
        .add("MarkdownLink", {
        sequence: 70,
        match: (content) => isMarkdownLink(content),
        createCell: (id, content, properties) => {
            return new WebLinkCell(id, content, properties);
        },
    })
        .add("WebLink", {
        sequence: 80,
        match: (content) => isWebLink(content),
        createCell: (id, content, properties) => {
            return new WebLinkCell(id, markdownLink(content, content), properties);
        },
    });
    /**
     * Return a factory function which can instantiate cells of
     * different types, based on a raw content.
     *
     * ```
     * // the createCell function can be used to instantiate new cells
     * const createCell = cellFactory(getters);
     * const cell = createCell(id, cellContent, cellProperties, sheetId)
     * ```
     */
    function cellFactory(getters) {
        const builders = cellRegistry.getAll().sort((a, b) => a.sequence - b.sequence);
        return function createCell(id, content, properties, sheetId) {
            const builder = builders.find((factory) => factory.match(content));
            if (!builder) {
                return new TextCell(id, content, properties);
            }
            try {
                return builder.createCell(id, content, properties, sheetId, getters);
            }
            catch (error) {
                return new BadExpressionCell(id, content, error.message || DEFAULT_ERROR_MESSAGE, properties);
            }
        };
    }

    /**
     * parses a formula (as a string) into the same formula,
     * but with the references to other cells extracted
     *
     * =sum(a3:b1) + c3 --> =sum(|0|) + |1|
     *
     * @param formula
     */
    function normalizeV9(formula) {
        const tokens = rangeTokenize(formula);
        let dependencies = [];
        let noRefFormula = "".concat(...tokens.map((token) => {
            if (token.type === "SYMBOL" && cellReference.test(token.value)) {
                const value = token.value.trim();
                if (!dependencies.includes(value)) {
                    dependencies.push(value);
                }
                return `${FORMULA_REF_IDENTIFIER}${dependencies.indexOf(value)}${FORMULA_REF_IDENTIFIER}`;
            }
            else {
                return token.value;
            }
        }));
        return { text: noRefFormula, dependencies };
    }

    /**
     * This is the current state version number. It should be incremented each time
     * a breaking change is made in the way the state is handled, and an upgrade
     * function should be defined
     */
    const CURRENT_VERSION = 10;
    const INITIAL_SHEET_ID = "Sheet1";
    /**
     * This function tries to load anything that could look like a valid
     * workbookData object. It applies any migrations, if needed, and return a
     * current, complete workbookData object.
     *
     * It also ensures that there is at least one sheet.
     */
    function load(data) {
        if (!data) {
            return createEmptyWorkbookData();
        }
        data = JSON.parse(JSON.stringify(data));
        // apply migrations, if needed
        if ("version" in data) {
            if (data.version < CURRENT_VERSION) {
                data = migrate(data);
            }
        }
        // sanity check: try to fix missing fields/corrupted state by providing
        // sensible default values
        data = Object.assign(createEmptyWorkbookData(), data, { version: CURRENT_VERSION });
        data.sheets = data.sheets.map((s, i) => Object.assign(createEmptySheet(`Sheet${i + 1}`, `Sheet${i + 1}`), s));
        if (data.sheets.length === 0) {
            data.sheets.push(createEmptySheet(INITIAL_SHEET_ID, "Sheet1"));
        }
        return data;
    }
    function migrate(data) {
        const index = MIGRATIONS.findIndex((m) => m.from === data.version);
        for (let i = index; i < MIGRATIONS.length; i++) {
            data = MIGRATIONS[i].applyMigration(data);
        }
        return data;
    }
    const MIGRATIONS = [
        {
            description: "add the `activeSheet` field on data",
            from: 1,
            to: 2,
            applyMigration(data) {
                if (data.sheets && data.sheets[0]) {
                    data.activeSheet = data.sheets[0].name;
                }
                return data;
            },
        },
        {
            description: "add an id field in each sheet",
            from: 2,
            to: 3,
            applyMigration(data) {
                if (data.sheets && data.sheets.length) {
                    for (let sheet of data.sheets) {
                        sheet.id = sheet.id || sheet.name;
                    }
                }
                return data;
            },
        },
        {
            description: "activeSheet is now an id, not the name of a sheet",
            from: 3,
            to: 4,
            applyMigration(data) {
                if (data.sheets && data.activeSheet) {
                    const activeSheet = data.sheets.find((s) => s.name === data.activeSheet);
                    data.activeSheet = activeSheet.id;
                }
                return data;
            },
        },
        {
            description: "add figures object in each sheets",
            from: 4,
            to: 5,
            applyMigration(data) {
                for (let sheet of data.sheets || []) {
                    sheet.figures = sheet.figures || [];
                }
                return data;
            },
        },
        {
            description: "normalize the content of the cell if it is a formula to avoid parsing all the formula that vary only by the cells they use",
            from: 5,
            to: 6,
            applyMigration(data) {
                for (let sheet of data.sheets || []) {
                    for (let xc in sheet.cells || []) {
                        const cell = sheet.cells[xc];
                        if (cell.content && cell.content.startsWith("=")) {
                            cell.formula = normalizeV9(cell.content);
                        }
                    }
                }
                return data;
            },
        },
        {
            description: "transform chart data structure",
            from: 6,
            to: 7,
            applyMigration(data) {
                for (let sheet of data.sheets || []) {
                    for (let f in sheet.figures || []) {
                        const { dataSets, ...newData } = sheet.figures[f].data;
                        const newDataSets = [];
                        for (let ds of dataSets) {
                            if (ds.labelCell) {
                                const dataRange = toZone(ds.dataRange);
                                const newRange = ds.labelCell + ":" + toXC(dataRange.right, dataRange.bottom);
                                newDataSets.push(newRange);
                            }
                            else {
                                newDataSets.push(ds.dataRange);
                            }
                        }
                        newData.dataSetsHaveTitle = Boolean(dataSets[0].labelCell);
                        newData.dataSets = newDataSets;
                        sheet.figures[f].data = newData;
                    }
                }
                return data;
            },
        },
        {
            description: "remove single quotes in sheet names",
            from: 7,
            to: 8,
            applyMigration(data) {
                var _a;
                const namesTaken = [];
                const globalForbiddenInExcel = new RegExp(FORBIDDEN_IN_EXCEL_REGEX, "g");
                for (let sheet of data.sheets || []) {
                    if (!sheet.name) {
                        continue;
                    }
                    const oldName = sheet.name;
                    const escapedName = oldName.replace(globalForbiddenInExcel, "_");
                    let i = 1;
                    let newName = escapedName;
                    while (namesTaken.includes(newName)) {
                        newName = `${escapedName}${i}`;
                        i++;
                    }
                    sheet.name = newName;
                    namesTaken.push(newName);
                    const replaceName = (str) => {
                        if (str === undefined) {
                            return str;
                        }
                        // replaceAll is only available in next Typescript version
                        let newString = str.replace(oldName, newName);
                        let currentString = str;
                        while (currentString !== newString) {
                            currentString = newString;
                            newString = currentString.replace(oldName, newName);
                        }
                        return currentString;
                    };
                    //cells
                    for (let xc in sheet.cells) {
                        const cell = sheet.cells[xc];
                        if (cell.formula) {
                            cell.formula.dependencies = cell.formula.dependencies.map(replaceName);
                        }
                    }
                    //charts
                    for (let figure of sheet.figures || []) {
                        if (figure.type === "chart") {
                            const dataSets = figure.data.dataSets.map(replaceName);
                            const labelRange = replaceName(figure.data.labelRange);
                            figure.data = { ...figure.data, dataSets, labelRange };
                        }
                    }
                    //ConditionalFormats
                    for (let cf of sheet.conditionalFormats || []) {
                        cf.ranges = cf.ranges.map(replaceName);
                        for (const thresholdName of [
                            "minimum",
                            "maximum",
                            "midpoint",
                            "upperInflectionPoint",
                            "lowerInflectionPoint",
                        ]) {
                            if (((_a = cf.rule[thresholdName]) === null || _a === void 0 ? void 0 : _a.type) === "formula") {
                                cf.rule[thresholdName].value = replaceName(cf.rule[thresholdName].value);
                            }
                        }
                    }
                }
                return data;
            },
        },
        {
            description: "transform chart data structure with design attributes",
            from: 8,
            to: 9,
            applyMigration(data) {
                for (const sheet of data.sheets || []) {
                    for (const chart of sheet.figures || []) {
                        chart.data.background = BACKGROUND_CHART_COLOR;
                        chart.data.verticalAxisPosition = "left";
                        chart.data.legendPosition = "top";
                        chart.data.stackedBar = false;
                    }
                }
                return data;
            },
        },
        {
            description: "de-normalize formula to reduce exported json size (~30%)",
            from: 9,
            to: 10,
            applyMigration(data) {
                for (let sheet of data.sheets || []) {
                    for (let xc in sheet.cells || []) {
                        const cell = sheet.cells[xc];
                        if (cell.formula) {
                            let { text, dependencies } = cell.formula;
                            for (let [index, d] of Object.entries(dependencies)) {
                                const stringPosition = `\\${FORMULA_REF_IDENTIFIER}${index}\\${FORMULA_REF_IDENTIFIER}`;
                                text = text.replace(new RegExp(stringPosition, "g"), d);
                            }
                            cell.content = text;
                            delete cell.formula;
                        }
                    }
                }
                return data;
            },
        },
    ];
    /**
     * The goal of this function is to repair corrupted/wrong initial messages caused by
     * a bug.
     * The bug should obviously be fixed, but it's too late for existing spreadsheet.
     */
    function repairInitialMessages(data, initialMessages) {
        initialMessages = fixTranslatedSheetIds(data, initialMessages);
        initialMessages = dropSortCommands(data, initialMessages);
        return initialMessages;
    }
    /**
     * When the workbook data is originally empty, a new one is generated on-the-fly.
     * A bug caused the sheet id to be non-deterministic. The sheet id was propagated in
     * commands.
     * This function repairs initial commands with a wrong sheetId.
     */
    function fixTranslatedSheetIds(data, initialMessages) {
        // the fix is only needed when the workbook is generated on-the-fly
        if (Object.keys(data).length !== 0) {
            return initialMessages;
        }
        const sheetIds = [];
        const messages = [];
        const fixSheetId = (cmd) => {
            if (cmd.type === "CREATE_SHEET") {
                sheetIds.push(cmd.sheetId);
            }
            else if ("sheetId" in cmd && !sheetIds.includes(cmd.sheetId)) {
                return { ...cmd, sheetId: INITIAL_SHEET_ID };
            }
            return cmd;
        };
        for (const message of initialMessages) {
            if (message.type === "REMOTE_REVISION") {
                messages.push({
                    ...message,
                    commands: message.commands.map(fixSheetId),
                });
            }
            else {
                messages.push(message);
            }
        }
        return messages;
    }
    function dropSortCommands(data, initialMessages) {
        const messages = [];
        for (const message of initialMessages) {
            if (message.type === "REMOTE_REVISION") {
                messages.push({
                    ...message,
                    // @ts-ignore
                    commands: message.commands.filter((command) => command.type !== "SORT_CELLS"),
                });
            }
            else {
                messages.push(message);
            }
        }
        return messages;
    }
    // -----------------------------------------------------------------------------
    // Helpers
    // -----------------------------------------------------------------------------
    function createEmptySheet(sheetId, name) {
        return {
            id: sheetId,
            name,
            colNumber: 26,
            rowNumber: 100,
            cells: {},
            cols: {},
            rows: {},
            merges: [],
            conditionalFormats: [],
            figures: [],
        };
    }
    function createEmptyWorkbookData(sheetName = "Sheet1") {
        const data = {
            version: CURRENT_VERSION,
            sheets: [createEmptySheet(INITIAL_SHEET_ID, sheetName)],
            entities: {},
            styles: {},
            borders: {},
            revisionId: DEFAULT_REVISION_ID,
        };
        return data;
    }
    function createEmptyExcelSheet(sheetId, name) {
        return {
            ...createEmptySheet(sheetId, name),
            charts: [],
        };
    }
    function createEmptyExcelWorkbookData() {
        return {
            ...createEmptyWorkbookData(),
            sheets: [createEmptyExcelSheet(INITIAL_SHEET_ID, "Sheet1")],
        };
    }

    /**
     * BasePlugin
     *
     * Since the spreadsheet internal state is quite complex, it is split into
     * multiple parts, each managing a specific concern.
     *
     * This file introduce the BasePlugin, which is the common class that defines
     * how each of these model sub parts should interact with each other.
     * There are two kind of plugins: core plugins handling persistent data
     * and UI plugins handling transient data.
     */
    class BasePlugin {
        constructor(stateObserver, dispatch, config) {
            this.history = Object.assign(Object.create(stateObserver), {
                update: stateObserver.addChange.bind(stateObserver, this),
                selectCell: () => { },
            });
            this.dispatch = dispatch;
            this.currentMode = config.mode;
        }
        // ---------------------------------------------------------------------------
        // Command handling
        // ---------------------------------------------------------------------------
        /**
         * Before a command is accepted, the model will ask each plugin if the command
         * is allowed.  If all of then return true, then we can proceed. Otherwise,
         * the command is cancelled.
         *
         * There should not be any side effects in this method.
         */
        allowDispatch(command) {
            return 0 /* Success */;
        }
        /**
         * This method is useful when a plugin need to perform some action before a
         * command is handled in another plugin. This should only be used if it is not
         * possible to do the work in the handle method.
         */
        beforeHandle(command) { }
        /**
         * This is the standard place to handle any command. Most of the plugin
         * command handling work should take place here.
         */
        handle(command) { }
        /**
         * Sometimes, it is useful to perform some work after a command (and all its
         * subcommands) has been completely handled.  For example, when we paste
         * multiple cells, we only want to reevaluate the cell values once at the end.
         */
        finalize() { }
        /**
         * Combine multiple validation functions into a single function
         * returning the list of result of every validation.
         */
        batchValidations(...validations) {
            return (toValidate) => validations.map((validation) => validation.call(this, toValidate)).flat();
        }
        /**
         * Combine multiple validation functions. Every validation is executed one after
         * the other. As soon as one validation fails, it stops and the cancelled reason
         * is returned.
         */
        chainValidations(...validations) {
            return (toValidate) => {
                for (const validation of validations) {
                    let results = validation.call(this, toValidate);
                    if (!Array.isArray(results)) {
                        results = [results];
                    }
                    const cancelledReasons = results.filter((result) => result !== 0 /* Success */);
                    if (cancelledReasons.length) {
                        return cancelledReasons;
                    }
                }
                return 0 /* Success */;
            };
        }
        checkValidations(command, ...validations) {
            return this.batchValidations(...validations)(command);
        }
    }
    BasePlugin.getters = [];
    BasePlugin.modes = ["headless", "normal"];

    /**
     * Core plugins handle spreadsheet data.
     * They are responsible to import, export and maintain the spreadsheet
     * persisted state.
     * They should not be concerned about UI parts or transient state.
     */
    class CorePlugin extends BasePlugin {
        constructor(getters, stateObserver, range, dispatch, config, uuidGenerator) {
            super(stateObserver, dispatch, config);
            this.dispatch = dispatch;
            this.range = range;
            range.addRangeProvider(this.adaptRanges.bind(this));
            this.getters = getters;
            this.uuidGenerator = uuidGenerator;
        }
        // ---------------------------------------------------------------------------
        // Import/Export
        // ---------------------------------------------------------------------------
        import(data) { }
        export(data) { }
        exportForExcel(data) { }
        /**
         * This method can be implemented in any plugin, to loop over the plugin's data structure and adapt the plugin's ranges.
         * To adapt them, the implementation of the function must have a perfect knowledge of the data structure, thus
         * implementing the loops over it makes sense in the plugin itself.
         * When calling the method applyChange, the range will be adapted if necessary, then a copy will be returned along with
         * the type of change that occurred.
         *
         * @param applyChange a function that, when called, will adapt the range according to the change on the grid
         * @param sheetId an optional sheetId to adapt either range of that sheet specifically, or ranges pointing to that sheet
         */
        adaptRanges(applyChange, sheetId) { }
    }

    /**
     * Formatting plugin.
     *
     * This plugin manages all things related to a cell look:
     * - borders
     */
    class BordersPlugin extends CorePlugin {
        constructor() {
            super(...arguments);
            this.borders = {};
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        handle(cmd) {
            switch (cmd.type) {
                case "ADD_MERGE":
                    if (!cmd.interactive) {
                        for (const zone of cmd.target) {
                            this.addBordersToMerge(cmd.sheetId, zone);
                        }
                    }
                    break;
                case "DUPLICATE_SHEET":
                    const borders = this.borders[cmd.sheetId];
                    if (borders) {
                        // borders is a sparse 2D array.
                        // map and slice preserve empty values and do not set `undefined` instead
                        const bordersCopy = borders
                            .slice()
                            .map((col) => col === null || col === void 0 ? void 0 : col.slice().map((border) => ({ ...border })));
                        this.history.update("borders", cmd.sheetIdTo, bordersCopy);
                    }
                    break;
                case "DELETE_SHEET":
                    const allBorders = { ...this.borders };
                    delete allBorders[cmd.sheetId];
                    this.history.update("borders", allBorders);
                    break;
                case "SET_BORDER":
                    this.setBorder(cmd.sheetId, cmd.col, cmd.row, cmd.border);
                    break;
                case "SET_FORMATTING":
                    if (cmd.border) {
                        const sheet = this.getters.getSheet(cmd.sheetId);
                        const target = cmd.target.map((zone) => this.getters.expandZone(cmd.sheetId, zone));
                        this.setBorders(sheet, target, cmd.border);
                    }
                    break;
                case "CLEAR_FORMATTING":
                    this.clearBorders(cmd.sheetId, cmd.target);
                    break;
                case "REMOVE_COLUMNS_ROWS":
                    for (let el of cmd.elements) {
                        if (cmd.dimension === "COL") {
                            this.shiftBordersHorizontally(cmd.sheetId, el + 1, -1);
                        }
                        else {
                            this.shiftBordersVertically(cmd.sheetId, el + 1, -1);
                        }
                    }
                    break;
                case "ADD_COLUMNS_ROWS":
                    if (cmd.dimension === "COL") {
                        this.handleAddColumns(cmd);
                    }
                    else {
                        this.handleAddRows(cmd);
                    }
                    break;
            }
        }
        /**
         * Move borders according to the inserted columns.
         * Ensure borders continuity.
         */
        handleAddColumns(cmd) {
            // The new columns have already been inserted in the sheet at this point.
            const sheet = this.getters.getSheet(cmd.sheetId);
            let colLeftOfInsertion;
            let colRightOfInsertion;
            if (cmd.position === "before") {
                this.shiftBordersHorizontally(cmd.sheetId, cmd.base, cmd.quantity, {
                    moveFirstLeftBorder: true,
                });
                colLeftOfInsertion = cmd.base - 1;
                colRightOfInsertion = cmd.base + cmd.quantity;
            }
            else {
                this.shiftBordersHorizontally(cmd.sheetId, cmd.base + 1, cmd.quantity, {
                    moveFirstLeftBorder: false,
                });
                colLeftOfInsertion = cmd.base;
                colRightOfInsertion = cmd.base + cmd.quantity + 1;
            }
            this.ensureColumnBorderContinuity(sheet, colLeftOfInsertion, colRightOfInsertion);
        }
        /**
         * Move borders according to the inserted rows.
         * Ensure borders continuity.
         */
        handleAddRows(cmd) {
            // The new rows have already been inserted at this point.
            const sheet = this.getters.getSheet(cmd.sheetId);
            let rowAboveInsertion;
            let rowBelowInsertion;
            if (cmd.position === "before") {
                this.shiftBordersVertically(sheet.id, cmd.base, cmd.quantity, { moveFirstTopBorder: true });
                rowAboveInsertion = cmd.base - 1;
                rowBelowInsertion = cmd.base + cmd.quantity;
            }
            else {
                this.shiftBordersVertically(sheet.id, cmd.base + 1, cmd.quantity, {
                    moveFirstTopBorder: false,
                });
                rowAboveInsertion = cmd.base;
                rowBelowInsertion = cmd.base + cmd.quantity + 1;
            }
            this.ensureRowBorderContinuity(sheet, rowAboveInsertion, rowBelowInsertion);
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        getCellBorder(sheetId, col, row) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            const border = {
                top: (_c = (_b = (_a = this.borders[sheetId]) === null || _a === void 0 ? void 0 : _a[col]) === null || _b === void 0 ? void 0 : _b[row]) === null || _c === void 0 ? void 0 : _c.horizontal,
                bottom: (_f = (_e = (_d = this.borders[sheetId]) === null || _d === void 0 ? void 0 : _d[col]) === null || _e === void 0 ? void 0 : _e[row + 1]) === null || _f === void 0 ? void 0 : _f.horizontal,
                left: (_j = (_h = (_g = this.borders[sheetId]) === null || _g === void 0 ? void 0 : _g[col]) === null || _h === void 0 ? void 0 : _h[row]) === null || _j === void 0 ? void 0 : _j.vertical,
                right: (_m = (_l = (_k = this.borders[sheetId]) === null || _k === void 0 ? void 0 : _k[col + 1]) === null || _l === void 0 ? void 0 : _l[row]) === null || _m === void 0 ? void 0 : _m.vertical,
            };
            if (!border.bottom && !border.left && !border.right && !border.top) {
                return null;
            }
            return border;
        }
        // ---------------------------------------------------------------------------
        // Private
        // ---------------------------------------------------------------------------
        /**
         * Ensure border continuity between two columns.
         * If the two columns have the same borders (at each row respectively),
         * the same borders are applied to each cell in between.
         */
        ensureColumnBorderContinuity(sheet, leftColumn, rightColumn) {
            const targetCols = range(leftColumn + 1, rightColumn);
            for (let row = 0; row < sheet.rows.length; row++) {
                const leftBorder = this.getCellBorder(sheet.id, leftColumn, row);
                const rightBorder = this.getCellBorder(sheet.id, rightColumn, row);
                if (leftBorder && rightBorder) {
                    const commonSides = this.getCommonSides(leftBorder, rightBorder);
                    for (let col of targetCols) {
                        this.addBorder(sheet.id, col, row, commonSides);
                    }
                }
            }
        }
        /**
         * Ensure border continuity between two rows.
         * If the two rows have the same borders (at each column respectively),
         * the same borders are applied to each cell in between.
         */
        ensureRowBorderContinuity(sheet, topRow, bottomRow) {
            const targetRows = range(topRow + 1, bottomRow);
            for (let col = 0; col < sheet.cols.length; col++) {
                const aboveBorder = this.getCellBorder(sheet.id, col, topRow);
                const belowBorder = this.getCellBorder(sheet.id, col, bottomRow);
                if (aboveBorder && belowBorder) {
                    const commonSides = this.getCommonSides(aboveBorder, belowBorder);
                    for (let row of targetRows) {
                        this.addBorder(sheet.id, col, row, commonSides);
                    }
                }
            }
        }
        /**
         * From two borders, return a new border with sides defined in both borders.
         * i.e. the intersection of two borders.
         */
        getCommonSides(border1, border2) {
            const commonBorder = {};
            for (let side of ["top", "bottom", "left", "right"]) {
                if (border1[side] && border1[side] === border2[side]) {
                    commonBorder[side] = border1[side];
                }
            }
            return commonBorder;
        }
        /**
         * Get all the columns which contains at least a border
         */
        getColumnsWithBorders(sheetId) {
            const sheetBorders = this.borders[sheetId];
            if (!sheetBorders)
                return [];
            return Object.keys(sheetBorders).map((index) => parseInt(index, 10));
        }
        /**
         * Get the range of all the rows in the sheet
         */
        getRowsRange(sheetId) {
            const sheetBorders = this.borders[sheetId];
            if (!sheetBorders)
                return [];
            const sheet = this.getters.getSheet(sheetId);
            return range(0, sheet.rows.length + 1);
        }
        /**
         * Move borders of a sheet horizontally.
         * @param sheetId
         * @param start starting column (included)
         * @param delta how much borders will be moved (negative if moved to the left)
         */
        shiftBordersHorizontally(sheetId, start, delta, { moveFirstLeftBorder } = {}) {
            const borders = this.borders[sheetId];
            if (!borders)
                return;
            if (delta < 0) {
                this.moveBordersOfColumn(sheetId, start, delta, "vertical", {
                    destructive: false,
                });
            }
            this.getColumnsWithBorders(sheetId)
                .filter((col) => col >= start)
                .sort((a, b) => (delta < 0 ? a - b : b - a)) // start by the end when moving up
                .forEach((col) => {
                if ((col === start && moveFirstLeftBorder) || col !== start) {
                    this.moveBordersOfColumn(sheetId, col, delta, "vertical");
                }
                this.moveBordersOfColumn(sheetId, col, delta, "horizontal");
            });
        }
        /**
         * Move borders of a sheet vertically.
         * @param sheetId
         * @param start starting row (included)
         * @param delta how much borders will be moved (negative if moved to the above)
         */
        shiftBordersVertically(sheetId, start, delta, { moveFirstTopBorder } = {}) {
            const borders = this.borders[sheetId];
            if (!borders)
                return;
            if (delta < 0) {
                this.moveBordersOfRow(sheetId, start, delta, "horizontal", {
                    destructive: false,
                });
            }
            this.getRowsRange(sheetId)
                .filter((row) => row >= start)
                .sort((a, b) => (delta < 0 ? a - b : b - a)) // start by the end when moving up
                .forEach((row) => {
                if ((row === start && moveFirstTopBorder) || row !== start) {
                    this.moveBordersOfRow(sheetId, row, delta, "horizontal");
                }
                this.moveBordersOfRow(sheetId, row, delta, "vertical");
            });
        }
        /**
         * Moves the borders (left if `vertical` or top if `horizontal` depending on
         * `borderDirection`) of all cells in an entire row `delta` rows to the right
         * (`delta` > 0) or to the left (`delta` < 0).
         * Note that as the left of a cell is the right of the cell-1, if the left is
         * moved the right is also moved. However, if `horizontal`, the bottom border
         * is not moved.
         * It does it by replacing the target border by the moved border. If the
         * argument `destructive` is given false, the target border is preserved if
         * the moved border is empty
         */
        moveBordersOfRow(sheetId, row, delta, borderDirection, { destructive } = { destructive: true }) {
            const borders = this.borders[sheetId];
            if (!borders)
                return;
            this.getColumnsWithBorders(sheetId).forEach((col) => {
                var _a, _b, _c, _d;
                const targetBorder = (_b = (_a = borders[col]) === null || _a === void 0 ? void 0 : _a[row + delta]) === null || _b === void 0 ? void 0 : _b[borderDirection];
                const movedBorder = (_d = (_c = borders[col]) === null || _c === void 0 ? void 0 : _c[row]) === null || _d === void 0 ? void 0 : _d[borderDirection];
                this.history.update("borders", sheetId, col, row + delta, borderDirection, destructive ? movedBorder : movedBorder || targetBorder);
                this.history.update("borders", sheetId, col, row, borderDirection, undefined);
            });
        }
        /**
         * Moves the borders (left if `vertical` or top if `horizontal` depending on
         * `borderDirection`) of all cells in an entire column `delta` columns below
         * (`delta` > 0) or above (`delta` < 0).
         * Note that as the top of a cell is the bottom of the cell-1, if the top is
         * moved the bottom is also moved. However, if `vertical`, the right border
         * is not moved.
         * It does it by replacing the target border by the moved border. If the
         * argument `destructive` is given false, the target border is preserved if
         * the moved border is empty
         */
        moveBordersOfColumn(sheetId, col, delta, borderDirection, { destructive } = { destructive: true }) {
            const borders = this.borders[sheetId];
            if (!borders)
                return;
            this.getRowsRange(sheetId).forEach((row) => {
                var _a, _b, _c, _d;
                const targetBorder = (_b = (_a = borders[col + delta]) === null || _a === void 0 ? void 0 : _a[row]) === null || _b === void 0 ? void 0 : _b[borderDirection];
                const movedBorder = (_d = (_c = borders[col]) === null || _c === void 0 ? void 0 : _c[row]) === null || _d === void 0 ? void 0 : _d[borderDirection];
                this.history.update("borders", sheetId, col + delta, row, borderDirection, destructive ? movedBorder : movedBorder || targetBorder);
                this.history.update("borders", sheetId, col, row, borderDirection, undefined);
            });
        }
        /**
         * Set the borders of a cell.
         * Note that it override the current border
         */
        setBorder(sheetId, col, row, border) {
            this.history.update("borders", sheetId, col, row, {
                vertical: border === null || border === void 0 ? void 0 : border.left,
                horizontal: border === null || border === void 0 ? void 0 : border.top,
            });
            this.history.update("borders", sheetId, col + 1, row, "vertical", border === null || border === void 0 ? void 0 : border.right);
            this.history.update("borders", sheetId, col, row + 1, "horizontal", border === null || border === void 0 ? void 0 : border.bottom);
        }
        /**
         * Remove the borders of a zone
         */
        clearBorders(sheetId, zones) {
            for (let zone of zones) {
                for (let row = zone.top; row <= zone.bottom; row++) {
                    this.history.update("borders", sheetId, zone.right + 1, row, "vertical", undefined);
                    for (let col = zone.left; col <= zone.right; col++) {
                        this.history.update("borders", sheetId, col, row, undefined);
                    }
                }
                for (let col = zone.left; col <= zone.right; col++) {
                    this.history.update("borders", sheetId, col, zone.bottom + 1, "horizontal", undefined);
                }
            }
        }
        /**
         * Add a border to the existing one to a cell
         */
        addBorder(sheetId, col, row, border) {
            this.setBorder(sheetId, col, row, {
                ...this.getCellBorder(sheetId, col, row),
                ...border,
            });
        }
        /**
         * Set the borders of a zone by computing the borders to add from the given
         * command
         */
        setBorders(sheet, zones, command) {
            const sheetId = sheet.id;
            if (command === "clear") {
                return this.clearBorders(sheetId, zones);
            }
            for (let zone of zones) {
                if (command === "h" || command === "hv" || command === "all") {
                    for (let row = zone.top + 1; row <= zone.bottom; row++) {
                        for (let col = zone.left; col <= zone.right; col++) {
                            this.addBorder(sheetId, col, row, { top: DEFAULT_BORDER_DESC });
                        }
                    }
                }
                if (command === "v" || command === "hv" || command === "all") {
                    for (let row = zone.top; row <= zone.bottom; row++) {
                        for (let col = zone.left + 1; col <= zone.right; col++) {
                            this.addBorder(sheetId, col, row, { left: DEFAULT_BORDER_DESC });
                        }
                    }
                }
                if (command === "left" || command === "all" || command === "external") {
                    for (let row = zone.top; row <= zone.bottom; row++) {
                        this.addBorder(sheetId, zone.left, row, { left: DEFAULT_BORDER_DESC });
                    }
                }
                if (command === "right" || command === "all" || command === "external") {
                    for (let row = zone.top; row <= zone.bottom; row++) {
                        this.addBorder(sheetId, zone.right + 1, row, { left: DEFAULT_BORDER_DESC });
                    }
                }
                if (command === "top" || command === "all" || command === "external") {
                    for (let col = zone.left; col <= zone.right; col++) {
                        this.addBorder(sheetId, col, zone.top, { top: DEFAULT_BORDER_DESC });
                    }
                }
                if (command === "bottom" || command === "all" || command === "external") {
                    for (let col = zone.left; col <= zone.right; col++) {
                        this.addBorder(sheetId, col, zone.bottom + 1, { top: DEFAULT_BORDER_DESC });
                    }
                }
            }
        }
        /**
         * Compute the borders to add to the given zone merged.
         */
        addBordersToMerge(sheetId, zone) {
            const sheet = this.getters.getSheet(sheetId);
            const { left, right, top, bottom } = zone;
            const bordersTopLeft = this.getCellBorder(sheet.id, left, top);
            const bordersBottomRight = this.getCellBorder(sheet.id, right, bottom);
            this.clearBorders(sheetId, [zone]);
            if (bordersTopLeft === null || bordersTopLeft === void 0 ? void 0 : bordersTopLeft.top) {
                this.setBorders(sheet, [{ ...zone, bottom: top }], "top");
            }
            if (bordersTopLeft === null || bordersTopLeft === void 0 ? void 0 : bordersTopLeft.left) {
                this.setBorders(sheet, [{ ...zone, right: left }], "left");
            }
            if ((bordersBottomRight === null || bordersBottomRight === void 0 ? void 0 : bordersBottomRight.bottom) || (bordersTopLeft === null || bordersTopLeft === void 0 ? void 0 : bordersTopLeft.bottom)) {
                this.setBorders(sheet, [{ ...zone, top: bottom }], "bottom");
            }
            if ((bordersBottomRight === null || bordersBottomRight === void 0 ? void 0 : bordersBottomRight.right) || (bordersTopLeft === null || bordersTopLeft === void 0 ? void 0 : bordersTopLeft.right)) {
                this.setBorders(sheet, [{ ...zone, left: right }], "right");
            }
        }
        // ---------------------------------------------------------------------------
        // Import/Export
        // ---------------------------------------------------------------------------
        import(data) {
            // Borders
            if (data.borders) {
                for (let sheet of data.sheets) {
                    for (let [xc, cell] of Object.entries(sheet.cells)) {
                        if (cell === null || cell === void 0 ? void 0 : cell.border) {
                            const border = data.borders[cell.border];
                            const [col, row] = toCartesian(xc);
                            this.setBorder(sheet.id, col, row, border);
                        }
                    }
                }
            }
            // Merges
            for (let sheetData of data.sheets) {
                if (sheetData.merges) {
                    for (let merge of sheetData.merges) {
                        this.addBordersToMerge(sheetData.id, toZone(merge));
                    }
                }
            }
        }
        export(data) {
            // Borders
            let borderId = 0;
            const borders = {};
            /**
             * Get the id of the given border. If the border does not exist, it creates
             * one.
             */
            function getBorderId(border) {
                for (let [key, value] of Object.entries(borders)) {
                    if (stringify(value) === stringify(border)) {
                        return parseInt(key, 10);
                    }
                }
                borders[++borderId] = border;
                return borderId;
            }
            for (let sheet of data.sheets) {
                for (let col = 0; col < sheet.colNumber; col++) {
                    for (let row = 0; row < sheet.rowNumber; row++) {
                        const border = this.getCellBorder(sheet.id, col, row);
                        if (border) {
                            const xc = toXC(col, row);
                            const cell = sheet.cells[xc];
                            const borderId = getBorderId(border);
                            if (cell) {
                                cell.border = borderId;
                            }
                            else {
                                sheet.cells[xc] = { border: borderId };
                            }
                        }
                    }
                }
            }
            data.borders = borders;
        }
        exportForExcel(data) {
            this.export(data);
        }
    }
    BordersPlugin.getters = ["getCellBorder"];

    const nbspRegexp = new RegExp(String.fromCharCode(160), "g");
    /**
     * Core Plugin
     *
     * This is the most fundamental of all plugins. It defines how to interact with
     * cell and sheet content.
     */
    class CellPlugin extends CorePlugin {
        constructor() {
            super(...arguments);
            this.cells = {};
            this.createCell = cellFactory(this.getters);
        }
        adaptRanges(applyChange, sheetId) {
            for (const sheet of Object.keys(this.cells)) {
                for (const cell of Object.values(this.cells[sheet] || {})) {
                    if (cell.isFormula()) {
                        for (const range of cell.dependencies.references) {
                            if (!sheetId || range.sheetId === sheetId) {
                                const change = applyChange(range);
                                if (change.changeType !== "NONE") {
                                    this.history.update("cells", sheet, cell.id, "dependencies", "references", cell.dependencies.references.indexOf(range), change.range);
                                }
                            }
                        }
                    }
                }
            }
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        allowDispatch(cmd) {
            switch (cmd.type) {
                case "UPDATE_CELL":
                    return this.checkCellOutOfSheet(cmd.sheetId, cmd.col, cmd.row);
                default:
                    return 0 /* Success */;
            }
        }
        handle(cmd) {
            switch (cmd.type) {
                case "SET_FORMATTING":
                    if ("style" in cmd) {
                        this.setStyle(cmd.sheetId, cmd.target, cmd.style);
                    }
                    if ("format" in cmd && cmd.format !== undefined) {
                        this.setFormatter(cmd.sheetId, cmd.target, cmd.format);
                    }
                    break;
                case "CLEAR_FORMATTING":
                    this.clearStyles(cmd.sheetId, cmd.target);
                    break;
                case "ADD_COLUMNS_ROWS":
                    if (cmd.dimension === "COL") {
                        this.handleAddColumnsRows(cmd, this.copyColumnStyle.bind(this));
                    }
                    else {
                        this.handleAddColumnsRows(cmd, this.copyRowStyle.bind(this));
                    }
                    break;
                case "UPDATE_CELL":
                    this.updateCell(this.getters.getSheet(cmd.sheetId), cmd.col, cmd.row, cmd);
                    break;
                case "CLEAR_CELL":
                    this.dispatch("UPDATE_CELL", {
                        sheetId: cmd.sheetId,
                        col: cmd.col,
                        row: cmd.row,
                        content: "",
                        style: null,
                        format: "",
                    });
                    break;
            }
        }
        /**
         * Set a format to all the cells in a zone
         */
        setFormatter(sheetId, zones, format) {
            for (let zone of zones) {
                for (let row = zone.top; row <= zone.bottom; row++) {
                    for (let col = zone.left; col <= zone.right; col++) {
                        this.dispatch("UPDATE_CELL", {
                            sheetId,
                            col,
                            row,
                            format,
                        });
                    }
                }
            }
        }
        /**
         * Clear the styles of zones
         */
        clearStyles(sheetId, zones) {
            for (let zone of zones) {
                for (let col = zone.left; col <= zone.right; col++) {
                    for (let row = zone.top; row <= zone.bottom; row++) {
                        // commandHelpers.updateCell(sheetId, col, row, { style: undefined});
                        this.dispatch("UPDATE_CELL", {
                            sheetId,
                            col,
                            row,
                            style: null,
                        });
                    }
                }
            }
        }
        /**
         * Copy the style of the reference column/row to the new columns/rows.
         */
        handleAddColumnsRows(cmd, fn) {
            const sheet = this.getters.getSheet(cmd.sheetId);
            // The new elements have already been inserted in the sheet at this point.
            let insertedElements;
            let styleReference;
            if (cmd.position === "before") {
                insertedElements = range(cmd.base, cmd.base + cmd.quantity);
                styleReference = cmd.base + cmd.quantity;
            }
            else {
                insertedElements = range(cmd.base + 1, cmd.base + cmd.quantity + 1);
                styleReference = cmd.base;
            }
            fn(sheet, styleReference, insertedElements);
        }
        // ---------------------------------------------------------------------------
        // Import/Export
        // ---------------------------------------------------------------------------
        import(data) {
            for (let sheet of data.sheets) {
                const imported_sheet = this.getters.getSheet(sheet.id);
                // cells
                for (let xc in sheet.cells) {
                    const cellData = sheet.cells[xc];
                    const [col, row] = toCartesian(xc);
                    if ((cellData === null || cellData === void 0 ? void 0 : cellData.content) || (cellData === null || cellData === void 0 ? void 0 : cellData.format) || (cellData === null || cellData === void 0 ? void 0 : cellData.style)) {
                        const cell = this.importCell(imported_sheet, cellData, data.styles);
                        this.history.update("cells", sheet.id, cell.id, cell);
                        this.dispatch("UPDATE_CELL_POSITION", {
                            cell,
                            cellId: cell.id,
                            col,
                            row,
                            sheetId: sheet.id,
                        });
                    }
                }
            }
        }
        export(data) {
            let styleId = 0;
            const styles = {};
            /**
             * Get the id of the given style. If the style does not exist, it creates
             * one.
             */
            function getStyleId(style) {
                for (let [key, value] of Object.entries(styles)) {
                    if (stringify(value) === stringify(style)) {
                        return parseInt(key, 10);
                    }
                }
                styles[++styleId] = style;
                return styleId;
            }
            for (let _sheet of data.sheets) {
                const cells = {};
                const positions = Object.keys(this.cells[_sheet.id] || {})
                    .map((cellId) => this.getters.getCellPosition(cellId))
                    .sort((a, b) => (a.col === b.col ? a.row - b.row : a.col - b.col));
                for (const { col, row } of positions) {
                    const cell = this.getters.getCell(_sheet.id, col, row);
                    const xc = toXC(col, row);
                    cells[xc] = {
                        style: cell.style && getStyleId(cell.style),
                        format: cell.format,
                        content: cell.content,
                    };
                }
                _sheet.cells = cells;
            }
            data.styles = styles;
        }
        importCell(sheet, cellData, normalizedStyles) {
            const style = (cellData.style && normalizedStyles[cellData.style]) || undefined;
            const cellId = this.uuidGenerator.uuidv4();
            const properties = { format: cellData === null || cellData === void 0 ? void 0 : cellData.format, style };
            return this.createCell(cellId, (cellData === null || cellData === void 0 ? void 0 : cellData.content) || "", properties, sheet.id);
        }
        exportForExcel(data) {
            this.export(data);
            for (let sheet of data.sheets) {
                for (const xc in sheet.cells) {
                    const [col, row] = toCartesian(xc);
                    const cell = this.getters.getCell(sheet.id, col, row);
                    const exportedCellData = sheet.cells[xc];
                    exportedCellData.value = cell.evaluated.value;
                    exportedCellData.isFormula = cell.isFormula();
                }
            }
        }
        // ---------------------------------------------------------------------------
        // GETTERS
        // ---------------------------------------------------------------------------
        getCells(sheetId) {
            return this.cells[sheetId] || {};
        }
        /**
         * get a cell by ID. Used in evaluation when evaluating an async cell, we need to be able to find it back after
         * starting an async evaluation even if it has been moved or re-allocated
         */
        getCellById(cellId) {
            for (const sheet of Object.values(this.cells)) {
                if (sheet[cellId]) {
                    return sheet[cellId];
                }
            }
            return undefined;
        }
        /**
         * Reconstructs the original formula string based on a normalized form and its dependencies
         */
        buildFormulaContent(sheetId, formula, dependencies) {
            let newContent = formula;
            for (let [index, range] of Object.entries(dependencies.references)) {
                const xc = this.getters.getRangeString(range, sheetId);
                const stringPosition = `\\${FORMULA_REF_IDENTIFIER}${index}\\${FORMULA_REF_IDENTIFIER}`;
                newContent = newContent.replace(new RegExp(stringPosition, "g"), xc);
            }
            for (let [index, d] of Object.entries(dependencies.strings)) {
                const stringPosition = `\\${FORMULA_REF_IDENTIFIER}S${index}\\${FORMULA_REF_IDENTIFIER}`;
                newContent = newContent.replace(new RegExp(stringPosition, "g"), `"${d}"`);
            }
            for (let [index, d] of Object.entries(dependencies.numbers)) {
                const stringPosition = `\\${FORMULA_REF_IDENTIFIER}N${index}\\${FORMULA_REF_IDENTIFIER}`;
                newContent = newContent.replace(new RegExp(stringPosition, "g"), d.toString());
            }
            return newContent;
        }
        getFormulaCellContent(sheetId, cell) {
            return this.buildFormulaContent(sheetId, cell.normalizedText, cell.dependencies);
        }
        getCellStyle(cell) {
            return cell.style || {};
        }
        /**
         * Converts a zone to a XC coordinate system
         *
         * The conversion also treats merges as one single cell
         *
         * Examples:
         * {top:0,left:0,right:0,bottom:0} ==> A1
         * {top:0,left:0,right:1,bottom:1} ==> A1:B2
         *
         * if A1:B2 is a merge:
         * {top:0,left:0,right:1,bottom:1} ==> A1
         * {top:1,left:0,right:1,bottom:2} ==> A1:B3
         *
         * if A1:B2 and A4:B5 are merges:
         * {top:1,left:0,right:1,bottom:3} ==> A1:A5
         */
        zoneToXC(sheetId, zone, fixedParts = [{ colFixed: false, rowFixed: false }]) {
            zone = this.getters.expandZone(sheetId, zone);
            const topLeft = toXC(zone.left, zone.top, fixedParts[0]);
            const botRight = toXC(zone.right, zone.bottom, fixedParts.length > 1 ? fixedParts[1] : fixedParts[0]);
            const cellTopLeft = this.getters.getMainCell(sheetId, zone.left, zone.top);
            const cellBotRight = this.getters.getMainCell(sheetId, zone.right, zone.bottom);
            const sameCell = cellTopLeft[0] == cellBotRight[0] && cellTopLeft[1] == cellBotRight[1];
            if (topLeft != botRight && !sameCell) {
                return topLeft + ":" + botRight;
            }
            return topLeft;
        }
        setStyle(sheetId, target, style) {
            for (let zone of target) {
                for (let col = zone.left; col <= zone.right; col++) {
                    for (let row = zone.top; row <= zone.bottom; row++) {
                        const cell = this.getters.getCell(sheetId, col, row);
                        this.dispatch("UPDATE_CELL", {
                            sheetId,
                            col,
                            row,
                            style: style ? { ...cell === null || cell === void 0 ? void 0 : cell.style, ...style } : undefined,
                        });
                    }
                }
            }
        }
        /**
         * Copy the style of one column to other columns.
         */
        copyColumnStyle(sheet, refColumn, targetCols) {
            for (let row = 0; row < sheet.rows.length; row++) {
                const format = this.getFormat(sheet.id, refColumn, row);
                if (format.style || format.format) {
                    for (let col of targetCols) {
                        this.dispatch("UPDATE_CELL", { sheetId: sheet.id, col, row, ...format });
                    }
                }
            }
        }
        /**
         * Copy the style of one row to other rows.
         */
        copyRowStyle(sheet, refRow, targetRows) {
            for (let col = 0; col < sheet.cols.length; col++) {
                const format = this.getFormat(sheet.id, col, refRow);
                if (format.style || format.format) {
                    for (let row of targetRows) {
                        this.dispatch("UPDATE_CELL", { sheetId: sheet.id, col, row, ...format });
                    }
                }
            }
        }
        /**
         * gets the currently used style/border of a cell based on it's coordinates
         */
        getFormat(sheetId, col, row) {
            const format = {};
            const [mainCol, mainRow] = this.getters.getMainCell(sheetId, col, row);
            const cell = this.getters.getCell(sheetId, mainCol, mainRow);
            if (cell) {
                if (cell.style) {
                    format["style"] = cell.style;
                }
                if (cell.format) {
                    format["format"] = cell.format;
                }
            }
            return format;
        }
        updateCell(sheet, col, row, after) {
            var _a;
            const before = sheet.rows[row].cells[col];
            const hasContent = "content" in after || "formula" in after;
            // Compute the new cell properties
            const afterContent = hasContent
                ? ((_a = after.content) === null || _a === void 0 ? void 0 : _a.replace(nbspRegexp, "")) || ""
                : (before === null || before === void 0 ? void 0 : before.content) || "";
            let style;
            if (after.style !== undefined) {
                style = after.style || undefined;
            }
            else {
                style = before ? before.style : undefined;
            }
            let format = ("format" in after ? after.format : before && before.format) || NULL_FORMAT;
            /* Read the following IF as:
             * we need to remove the cell if it is completely empty, but we can know if it completely empty if:
             * - the command says the new content is empty and has no border/format/style
             * - the command has no content property, in this case
             *     - either there wasn't a cell at this place and the command says border/format/style is empty
             *     - or there was a cell at this place, but it's an empty cell and the command says border/format/style is empty
             *  */
            if (((hasContent && !afterContent && !after.formula) ||
                (!hasContent && (!before || before.isEmpty()))) &&
                !style &&
                !format) {
                if (before) {
                    this.history.update("cells", sheet.id, before.id, undefined);
                    this.dispatch("UPDATE_CELL_POSITION", {
                        cellId: before.id,
                        col,
                        row,
                        sheetId: sheet.id,
                        cell: undefined,
                    });
                }
                return;
            }
            const cellId = (before === null || before === void 0 ? void 0 : before.id) || this.uuidGenerator.uuidv4();
            const didContentChange = hasContent;
            const properties = { format, style };
            const cell = this.createCell(cellId, afterContent, properties, sheet.id);
            if (before && !didContentChange && cell.isFormula()) {
                // content is not re-evaluated if the content did not change => reassign the value manually
                // TODO this plugin should not care about evaluation
                // and evaluation should not depend on implementation details here.
                // Task 2813749
                cell.assignValue(before.evaluated.value);
                if (before.evaluated.type === CellValueType.error) {
                    cell.assignError(before.evaluated.value, before.evaluated.error);
                }
            }
            this.history.update("cells", sheet.id, cell.id, cell);
            this.dispatch("UPDATE_CELL_POSITION", { cell, cellId: cell.id, col, row, sheetId: sheet.id });
        }
        checkCellOutOfSheet(sheetId, col, row) {
            const sheet = this.getters.tryGetSheet(sheetId);
            if (!sheet)
                return 21 /* InvalidSheetId */;
            const sheetZone = {
                top: 0,
                left: 0,
                bottom: sheet.rows.length - 1,
                right: sheet.cols.length - 1,
            };
            return isInside(col, row, sheetZone) ? 0 /* Success */ : 16 /* TargetOutOfSheet */;
        }
    }
    CellPlugin.getters = [
        "zoneToXC",
        "getCells",
        "getFormulaCellContent",
        "getCellStyle",
        "buildFormulaContent",
        "getCellById",
    ];

    class ChartPlugin extends CorePlugin {
        constructor() {
            super(...arguments);
            this.chartFigures = {};
            this.nextId = 1;
        }
        adaptRanges(applyChange) {
            for (let [chartId, chart] of Object.entries(this.chartFigures)) {
                if (chart) {
                    this.adaptDataSetRanges(chart, chartId, applyChange);
                    this.adaptLabelRanges(chart, chartId, applyChange);
                }
            }
        }
        adaptDataSetRanges(chart, chartId, applyChange) {
            for (let ds of chart.dataSets) {
                if (ds.labelCell) {
                    const labelCellChange = applyChange(ds.labelCell);
                    switch (labelCellChange.changeType) {
                        case "REMOVE":
                            this.history.update("chartFigures", chartId, "dataSets", chart.dataSets.indexOf(ds), "labelCell", undefined);
                            break;
                        case "RESIZE":
                        case "MOVE":
                        case "CHANGE":
                            this.history.update("chartFigures", chartId, "dataSets", chart.dataSets.indexOf(ds), "labelCell", labelCellChange.range);
                    }
                }
                const dataRangeChange = applyChange(ds.dataRange);
                switch (dataRangeChange.changeType) {
                    case "REMOVE":
                        const newDataSets = chart.dataSets.filter((dataset) => dataset !== ds);
                        this.history.update("chartFigures", chartId, "dataSets", newDataSets);
                        break;
                    case "RESIZE":
                    case "MOVE":
                    case "CHANGE":
                        // We have to remove the ranges that are #REF
                        if (this.getters.getRangeString(dataRangeChange.range, dataRangeChange.range.sheetId) !==
                            INCORRECT_RANGE_STRING) {
                            this.history.update("chartFigures", chartId, "dataSets", chart.dataSets.indexOf(ds), "dataRange", dataRangeChange.range);
                        }
                        else {
                            const newDataSets = chart.dataSets.filter((dataset) => dataset !== ds);
                            this.history.update("chartFigures", chartId, "dataSets", newDataSets);
                        }
                        break;
                }
            }
        }
        adaptLabelRanges(chart, chartId, applyChange) {
            if (chart.labelRange) {
                const labelRangeChange = applyChange(chart.labelRange);
                switch (labelRangeChange.changeType) {
                    case "REMOVE":
                        this.history.update("chartFigures", chartId, "labelRange", undefined);
                        break;
                    case "RESIZE":
                    case "MOVE":
                    case "CHANGE":
                        this.history.update("chartFigures", chartId, "labelRange", labelRangeChange.range);
                        break;
                }
            }
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        allowDispatch(cmd) {
            const success = 0 /* Success */;
            switch (cmd.type) {
                case "UPDATE_CHART":
                case "CREATE_CHART":
                    return this.checkValidations(cmd, this.chainValidations(this.checkEmptyDataset, this.checkDataset), this.checkLabelRange);
                default:
                    return success;
            }
        }
        handle(cmd) {
            var _a, _b;
            switch (cmd.type) {
                case "CREATE_CHART":
                    const x = cmd.position ? cmd.position.x : 0;
                    const y = cmd.position ? cmd.position.y : 0;
                    this.addChartFigure(cmd.sheetId, this.createChartDefinition(cmd.definition, cmd.sheetId), {
                        id: cmd.id,
                        x,
                        y,
                        height: 335,
                        width: 536,
                        tag: "chart",
                    });
                    break;
                case "UPDATE_CHART": {
                    this.updateChartDefinition(cmd.id, cmd.definition);
                    break;
                }
                case "DUPLICATE_SHEET": {
                    const sheetFiguresFrom = this.getters.getFigures(cmd.sheetId);
                    for (const fig of sheetFiguresFrom) {
                        if (fig.tag === "chart") {
                            const id = this.nextId.toString();
                            this.history.update("nextId", this.nextId + 1);
                            const chartDefinition = { ...deepCopy(this.chartFigures[fig.id]), id };
                            chartDefinition.sheetId = cmd.sheetIdTo;
                            chartDefinition.dataSets.forEach((dataset) => {
                                var _a;
                                if (dataset.dataRange.sheetId === cmd.sheetId) {
                                    dataset.dataRange.sheetId = cmd.sheetIdTo;
                                }
                                if (((_a = dataset.labelCell) === null || _a === void 0 ? void 0 : _a.sheetId) === cmd.sheetId) {
                                    dataset.labelCell.sheetId = cmd.sheetIdTo;
                                }
                            });
                            if (((_a = chartDefinition.labelRange) === null || _a === void 0 ? void 0 : _a.sheetId) === cmd.sheetId) {
                                chartDefinition.labelRange.sheetId = cmd.sheetIdTo;
                            }
                            const figure = {
                                id: id,
                                x: fig.x,
                                y: fig.y,
                                height: fig.height,
                                width: fig.width,
                                tag: "chart",
                            };
                            this.addChartFigure(cmd.sheetIdTo, chartDefinition, figure);
                        }
                    }
                    break;
                }
                case "DELETE_FIGURE":
                    this.history.update("chartFigures", cmd.id, undefined);
                    break;
                case "DELETE_SHEET":
                    for (let id of Object.keys(this.chartFigures)) {
                        if (((_b = this.chartFigures[id]) === null || _b === void 0 ? void 0 : _b.sheetId) === cmd.sheetId) {
                            this.history.update("chartFigures", id, undefined);
                        }
                    }
                    break;
            }
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        getChartDefinition(figureId) {
            return this.chartFigures[figureId];
        }
        getChartsIdBySheet(sheetId) {
            return Object.entries(this.chartFigures)
                .filter((chart) => {
                return chart[1].sheetId === sheetId;
            })
                .map((chart) => chart[0]);
        }
        getChartDefinitionUI(sheetId, figureId) {
            const data = this.chartFigures[figureId];
            const dataSets = data.dataSets
                .map((ds) => (ds ? this.getters.getRangeString(ds.dataRange, sheetId) : ""))
                .filter((ds) => {
                return ds !== ""; // && range !== INCORRECT_RANGE_STRING ? show incorrect #ref ?
            });
            return {
                title: data && data.title ? data.title : "",
                dataSets,
                labelRange: data.labelRange
                    ? this.getters.getRangeString(data.labelRange, sheetId)
                    : undefined,
                type: data ? data.type : "bar",
                dataSetsHaveTitle: data && dataSets.length !== 0 ? Boolean(data.dataSets[0].labelCell) : false,
                background: data.background,
                verticalAxisPosition: data.verticalAxisPosition,
                legendPosition: data.legendPosition,
                stackedBar: data.stackedBar,
            };
        }
        getChartDefinitionExcel(sheetId, figureId) {
            const data = this.chartFigures[figureId];
            const dataSets = data.dataSets
                .map((ds) => this.toExcelDataset(ds))
                .filter((ds) => ds.range !== ""); // && range !== INCORRECT_RANGE_STRING ? show incorrect #ref ?
            return {
                ...this.getChartDefinitionUI("forceSheetReference", figureId),
                backgroundColor: data.background,
                dataSets,
            };
        }
        toExcelDataset(ds) {
            var _a;
            const labelZone = (_a = ds.labelCell) === null || _a === void 0 ? void 0 : _a.zone;
            let dataZone = ds.dataRange.zone;
            if (labelZone) {
                const { height, width } = zoneToDimension(dataZone);
                if (height === 1) {
                    dataZone = { ...dataZone, left: dataZone.left + 1 };
                }
                else if (width === 1) {
                    dataZone = { ...dataZone, top: dataZone.top + 1 };
                }
            }
            const dataRange = {
                ...ds.dataRange,
                zone: dataZone,
            };
            return {
                label: ds.labelCell
                    ? this.getters.getRangeString(ds.labelCell, "forceSheetReference")
                    : undefined,
                range: this.getters.getRangeString(dataRange, "forceSheetReference"),
            };
        }
        // ---------------------------------------------------------------------------
        // Import/Export
        // ---------------------------------------------------------------------------
        import(data) {
            for (let sheet of data.sheets) {
                if (sheet.figures) {
                    for (let figure of sheet.figures) {
                        if (figure.tag === "chart") {
                            const figureData = {
                                ...figure.data,
                            };
                            this.chartFigures[figure.id] = this.createChartDefinition(figureData, sheet.id);
                            delete figure.data;
                        }
                    }
                }
            }
        }
        export(data) {
            if (data.sheets) {
                for (let sheet of data.sheets) {
                    const sheetFigures = this.getters.getFigures(sheet.id);
                    const figures = sheetFigures;
                    for (let figure of figures) {
                        if (figure && figure.tag === "chart") {
                            figure.data = this.getChartDefinitionUI(sheet.id, figure.id);
                        }
                    }
                    sheet.figures = figures;
                }
            }
        }
        exportForExcel(data) {
            for (let sheet of data.sheets) {
                const sheetFigures = this.getters.getFigures(sheet.id);
                const figures = sheetFigures;
                for (let figure of figures) {
                    if (figure && figure.tag === "chart") {
                        figure.data = this.getChartDefinitionExcel(sheet.id, figure.id);
                    }
                }
                sheet.charts = figures;
            }
        }
        // ---------------------------------------------------------------------------
        // Private
        // ---------------------------------------------------------------------------
        /**
         * Create a new chart definition based on the given UI definition
         */
        createChartDefinition(definition, sheetId) {
            return {
                ...definition,
                dataSets: this.createDataSets(definition.dataSets, sheetId, definition.dataSetsHaveTitle),
                labelRange: definition.labelRange
                    ? this.getters.getRangeFromSheetXC(sheetId, definition.labelRange)
                    : undefined,
                sheetId,
            };
        }
        /**
         * Update the chart definition linked to the given id with the attributes
         * given in the partial UI definition
         */
        updateChartDefinition(id, definition) {
            const chart = this.chartFigures[id];
            if (!chart) {
                throw new Error(`There is no chart with the given id: ${id}`);
            }
            if (definition.title !== undefined) {
                this.history.update("chartFigures", id, "title", definition.title);
            }
            if (definition.type) {
                this.history.update("chartFigures", id, "type", definition.type);
            }
            if (definition.dataSets) {
                const dataSetsHaveTitle = !!definition.dataSetsHaveTitle;
                const dataSets = this.createDataSets(definition.dataSets, chart.sheetId, dataSetsHaveTitle);
                this.history.update("chartFigures", id, "dataSets", dataSets);
            }
            if (definition.labelRange !== undefined) {
                const labelRange = definition.labelRange
                    ? this.getters.getRangeFromSheetXC(chart.sheetId, definition.labelRange)
                    : undefined;
                this.history.update("chartFigures", id, "labelRange", labelRange);
            }
            if (definition.background) {
                this.history.update("chartFigures", id, "background", definition.background);
            }
            if (definition.verticalAxisPosition) {
                this.history.update("chartFigures", id, "verticalAxisPosition", definition.verticalAxisPosition);
            }
            if (definition.legendPosition) {
                this.history.update("chartFigures", id, "legendPosition", definition.legendPosition);
            }
            if (definition.stackedBar !== undefined) {
                this.history.update("chartFigures", id, "stackedBar", definition.stackedBar);
            }
        }
        createDataSets(dataSetsString, sheetId, dataSetsHaveTitle) {
            const dataSets = [];
            for (const sheetXC of dataSetsString) {
                const dataRange = this.getters.getRangeFromSheetXC(sheetId, sheetXC);
                const { zone, sheetId: dataSetSheetId, invalidSheetName } = dataRange;
                if (invalidSheetName) {
                    continue;
                }
                if (zone.left !== zone.right && zone.top !== zone.bottom) {
                    // It's a rectangle. We treat all columns (arbitrary) as different data series.
                    for (let column = zone.left; column <= zone.right; column++) {
                        const columnZone = {
                            left: column,
                            right: column,
                            top: zone.top,
                            bottom: zone.bottom,
                        };
                        dataSets.push(this.createDataSet(dataSetSheetId, columnZone, dataSetsHaveTitle
                            ? {
                                top: columnZone.top,
                                bottom: columnZone.top,
                                left: columnZone.left,
                                right: columnZone.left,
                            }
                            : undefined));
                    }
                }
                else if (zone.left === zone.right && zone.top === zone.bottom) {
                    // A single cell. If it's only the title, the dataset is not added.
                    if (!dataSetsHaveTitle) {
                        dataSets.push(this.createDataSet(dataSetSheetId, zone, undefined));
                    }
                }
                else {
                    /* 1 row or 1 column */
                    dataSets.push(this.createDataSet(dataSetSheetId, zone, dataSetsHaveTitle
                        ? {
                            top: zone.top,
                            bottom: zone.top,
                            left: zone.left,
                            right: zone.left,
                        }
                        : undefined));
                }
            }
            return dataSets;
        }
        addChartFigure(sheetId, data, figure) {
            this.dispatch("CREATE_FIGURE", {
                sheetId,
                figure,
            });
            this.history.update("chartFigures", figure.id, data);
        }
        createDataSet(sheetId, fullZone, titleZone) {
            if (fullZone.left !== fullZone.right && fullZone.top !== fullZone.bottom) {
                throw new Error(`Zone should be a single column or row: ${zoneToXc(fullZone)}`);
            }
            if (titleZone) {
                const dataXC = zoneToXc(fullZone);
                const labelCellXC = zoneToXc(titleZone);
                return {
                    labelCell: this.getters.getRangeFromSheetXC(sheetId, labelCellXC),
                    dataRange: this.getters.getRangeFromSheetXC(sheetId, dataXC),
                };
            }
            else {
                return {
                    labelCell: undefined,
                    dataRange: this.getters.getRangeFromSheetXC(sheetId, zoneToXc(fullZone)),
                };
            }
        }
        checkEmptyDataset(cmd) {
            return cmd.definition.dataSets && cmd.definition.dataSets.length === 0
                ? 25 /* EmptyDataSet */
                : 0 /* Success */;
        }
        checkDataset(cmd) {
            if (!cmd.definition.dataSets) {
                return 0 /* Success */;
            }
            const invalidRanges = cmd.definition.dataSets.find((range) => !rangeReference.test(range)) !== undefined;
            return invalidRanges ? 26 /* InvalidDataSet */ : 0 /* Success */;
        }
        checkLabelRange(cmd) {
            if (!cmd.definition.labelRange) {
                return 0 /* Success */;
            }
            const invalidLabels = !rangeReference.test(cmd.definition.labelRange || "");
            return invalidLabels ? 27 /* InvalidLabelRange */ : 0 /* Success */;
        }
    }
    ChartPlugin.getters = ["getChartDefinition", "getChartDefinitionUI", "getChartsIdBySheet"];

    // -----------------------------------------------------------------------------
    // Constants
    // -----------------------------------------------------------------------------
    function stringToNumber(value) {
        return value === "" ? NaN : Number(value);
    }
    class ConditionalFormatPlugin extends CorePlugin {
        constructor() {
            super(...arguments);
            this.cfRules = {};
        }
        loopThroughRangesOfSheet(sheetId, applyChange) {
            for (const rule of this.cfRules[sheetId]) {
                for (const range of rule.ranges) {
                    const change = applyChange(range);
                    switch (change.changeType) {
                        case "REMOVE":
                            let copy = rule.ranges.slice();
                            copy.splice(rule.ranges.indexOf(range), 1);
                            if (copy.length >= 1) {
                                this.history.update("cfRules", sheetId, this.cfRules[sheetId].indexOf(rule), "ranges", copy);
                            }
                            else {
                                this.removeConditionalFormatting(rule.id, sheetId);
                            }
                            break;
                        case "RESIZE":
                        case "MOVE":
                        case "CHANGE":
                            this.history.update("cfRules", sheetId, this.cfRules[sheetId].indexOf(rule), "ranges", rule.ranges.indexOf(range), change.range);
                            break;
                    }
                }
            }
        }
        adaptRanges(applyChange, sheetId) {
            if (sheetId) {
                this.loopThroughRangesOfSheet(sheetId, applyChange);
            }
            else {
                for (const sheetId of Object.keys(this.cfRules)) {
                    this.loopThroughRangesOfSheet(sheetId, applyChange);
                }
            }
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        allowDispatch(cmd) {
            if (cmd.type === "ADD_CONDITIONAL_FORMAT") {
                return this.checkValidations(cmd, this.checkCFRule, this.checkEmptyRange);
            }
            return 0 /* Success */;
        }
        handle(cmd) {
            switch (cmd.type) {
                case "CREATE_SHEET":
                    this.cfRules[cmd.sheetId] = [];
                    break;
                case "DUPLICATE_SHEET":
                    this.history.update("cfRules", cmd.sheetIdTo, []);
                    for (const cf of this.getConditionalFormats(cmd.sheetId)) {
                        this.addConditionalFormatting(cf, cmd.sheetIdTo);
                    }
                    break;
                case "DELETE_SHEET":
                    const cfRules = Object.assign({}, this.cfRules);
                    delete cfRules[cmd.sheetId];
                    this.history.update("cfRules", cfRules);
                    break;
                case "ADD_CONDITIONAL_FORMAT":
                    const cf = {
                        ...cmd.cf,
                        ranges: cmd.target.map(zoneToXc),
                    };
                    this.addConditionalFormatting(cf, cmd.sheetId);
                    break;
                case "REMOVE_CONDITIONAL_FORMAT":
                    this.removeConditionalFormatting(cmd.id, cmd.sheetId);
                    break;
            }
        }
        import(data) {
            for (let sheet of data.sheets) {
                this.cfRules[sheet.id] = sheet.conditionalFormats.map((rule) => this.mapToConditionalFormatInternal(sheet.id, rule));
            }
        }
        export(data) {
            if (data.sheets) {
                for (let sheet of data.sheets) {
                    if (this.cfRules[sheet.id]) {
                        sheet.conditionalFormats = this.cfRules[sheet.id].map((rule) => this.mapToConditionalFormat(sheet.id, rule));
                    }
                }
            }
        }
        exportForExcel(data) {
            this.export(data);
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        /**
         * Returns all the conditional format rules defined for the current sheet to display the user
         */
        getConditionalFormats(sheetId) {
            return this.cfRules[sheetId].map((cf) => this.mapToConditionalFormat(sheetId, cf)) || [];
        }
        getRulesSelection(sheetId, selection) {
            const ruleIds = new Set();
            selection.forEach((zone) => {
                const zoneRuleId = this.getRulesByZone(sheetId, zone);
                zoneRuleId.forEach((ruleId) => {
                    ruleIds.add(ruleId);
                });
            });
            return Array.from(ruleIds);
        }
        getRulesByZone(sheetId, zone) {
            const ruleIds = new Set();
            for (let row = zone.top; row <= zone.bottom; row++) {
                for (let col = zone.left; col <= zone.right; col++) {
                    const cellRules = this.getRulesByCell(sheetId, col, row);
                    cellRules.forEach((rule) => {
                        ruleIds.add(rule.id);
                    });
                }
            }
            return ruleIds;
        }
        getRulesByCell(sheetId, cellCol, cellRow) {
            const rules = [];
            for (let cf of this.cfRules[sheetId]) {
                for (let range of cf.ranges) {
                    if (isInside(cellCol, cellRow, range.zone)) {
                        rules.push(cf);
                    }
                }
            }
            return new Set(rules.map((rule) => {
                return this.mapToConditionalFormat(sheetId, rule);
            }));
        }
        // ---------------------------------------------------------------------------
        // Private
        // ---------------------------------------------------------------------------
        mapToConditionalFormat(sheetId, cf) {
            return {
                ...cf,
                ranges: cf.ranges.map((range) => {
                    return this.getters.getRangeString(range, sheetId);
                }),
            };
        }
        mapToConditionalFormatInternal(sheet, cf) {
            const conditionalFormat = {
                ...cf,
                ranges: cf.ranges.map((range) => {
                    return this.getters.getRangeFromSheetXC(sheet, range);
                }),
            };
            return conditionalFormat;
        }
        /**
         * Add or replace a conditional format rule
         */
        addConditionalFormatting(cf, sheet) {
            const currentCF = this.cfRules[sheet].slice();
            const replaceIndex = currentCF.findIndex((c) => c.id === cf.id);
            const newCF = this.mapToConditionalFormatInternal(sheet, cf);
            if (replaceIndex > -1) {
                currentCF.splice(replaceIndex, 1, newCF);
            }
            else {
                currentCF.push(newCF);
            }
            this.history.update("cfRules", sheet, currentCF);
        }
        checkEmptyRange(cmd) {
            return cmd.target.length ? 0 /* Success */ : 19 /* EmptyRange */;
        }
        checkCFRule(cmd) {
            const rule = cmd.cf.rule;
            switch (rule.type) {
                case "CellIsRule":
                    return this.checkValidations(rule, this.checkOperatorArgsNumber(2, ["Between", "NotBetween"]), this.checkOperatorArgsNumber(1, [
                        "BeginsWith",
                        "ContainsText",
                        "EndsWith",
                        "GreaterThan",
                        "GreaterThanOrEqual",
                        "LessThan",
                        "LessThanOrEqual",
                        "NotContains",
                    ]), this.checkOperatorArgsNumber(0, ["IsEmpty", "IsNotEmpty"]));
                case "ColorScaleRule": {
                    return this.checkValidations(rule, this.chainValidations(this.checkThresholds(this.checkFormulaCompilation)), this.chainValidations(this.checkThresholds(this.checkNaN), this.batchValidations(this.checkMinBiggerThanMax, this.checkMinBiggerThanMid, this.checkMidBiggerThanMax
                    // ☝️ Those three validations can be factorized further
                    )));
                }
                case "IconSetRule": {
                    return this.checkValidations(rule, this.chainValidations(this.checkInflectionPoints(this.checkNaN), this.checkLowerBiggerThanUpper), this.chainValidations(this.checkInflectionPoints(this.checkFormulaCompilation)));
                }
            }
            return 0 /* Success */;
        }
        checkOperatorArgsNumber(expectedNumber, operators) {
            if (expectedNumber > 2) {
                throw new Error("Checking more than 2 arguments is currently not supported. Add the appropriate CommandResult if you want to.");
            }
            return (rule) => {
                if (operators.includes(rule.operator)) {
                    const errors = [];
                    const isEmpty = (value) => value === undefined || value === "";
                    if (expectedNumber >= 1 && isEmpty(rule.values[0])) {
                        errors.push(34 /* FirstArgMissing */);
                    }
                    if (expectedNumber >= 2 && isEmpty(rule.values[1])) {
                        errors.push(35 /* SecondArgMissing */);
                    }
                    return errors.length ? errors : 0 /* Success */;
                }
                return 0 /* Success */;
            };
        }
        checkNaN(threshold, thresholdName) {
            if (["number", "percentage", "percentile"].includes(threshold.type) &&
                (threshold.value === "" || isNaN(threshold.value))) {
                switch (thresholdName) {
                    case "min":
                        return 36 /* MinNaN */;
                    case "max":
                        return 38 /* MaxNaN */;
                    case "mid":
                        return 37 /* MidNaN */;
                    case "upperInflectionPoint":
                        return 39 /* ValueUpperInflectionNaN */;
                    case "lowerInflectionPoint":
                        return 40 /* ValueLowerInflectionNaN */;
                }
            }
            return 0 /* Success */;
        }
        checkFormulaCompilation(threshold, thresholdName) {
            if (threshold.type !== "formula")
                return 0 /* Success */;
            try {
                compile(normalize(threshold.value || ""));
            }
            catch (error) {
                switch (thresholdName) {
                    case "min":
                        return 41 /* MinInvalidFormula */;
                    case "max":
                        return 43 /* MaxInvalidFormula */;
                    case "mid":
                        return 42 /* MidInvalidFormula */;
                    case "upperInflectionPoint":
                        return 44 /* ValueUpperInvalidFormula */;
                    case "lowerInflectionPoint":
                        return 45 /* ValueLowerInvalidFormula */;
                }
            }
            return 0 /* Success */;
        }
        checkThresholds(check) {
            return this.batchValidations((rule) => check(rule.minimum, "min"), (rule) => check(rule.maximum, "max"), (rule) => (rule.midpoint ? check(rule.midpoint, "mid") : 0 /* Success */));
        }
        checkInflectionPoints(check) {
            return this.batchValidations((rule) => check(rule.lowerInflectionPoint, "lowerInflectionPoint"), (rule) => check(rule.upperInflectionPoint, "upperInflectionPoint"));
        }
        checkLowerBiggerThanUpper(rule) {
            const minValue = rule.lowerInflectionPoint.value;
            const maxValue = rule.upperInflectionPoint.value;
            if (["number", "percentage", "percentile"].includes(rule.lowerInflectionPoint.type) &&
                rule.lowerInflectionPoint.type === rule.upperInflectionPoint.type &&
                Number(minValue) > Number(maxValue)) {
                return 31 /* LowerBiggerThanUpper */;
            }
            return 0 /* Success */;
        }
        checkMinBiggerThanMax(rule) {
            const minValue = rule.minimum.value;
            const maxValue = rule.maximum.value;
            if (["number", "percentage", "percentile"].includes(rule.minimum.type) &&
                rule.minimum.type === rule.maximum.type &&
                stringToNumber(minValue) >= stringToNumber(maxValue)) {
                return 30 /* MinBiggerThanMax */;
            }
            return 0 /* Success */;
        }
        checkMidBiggerThanMax(rule) {
            var _a;
            const midValue = (_a = rule.midpoint) === null || _a === void 0 ? void 0 : _a.value;
            const maxValue = rule.maximum.value;
            if (rule.midpoint &&
                ["number", "percentage", "percentile"].includes(rule.midpoint.type) &&
                rule.midpoint.type === rule.maximum.type &&
                stringToNumber(midValue) >= stringToNumber(maxValue)) {
                return 32 /* MidBiggerThanMax */;
            }
            return 0 /* Success */;
        }
        checkMinBiggerThanMid(rule) {
            var _a;
            const minValue = rule.minimum.value;
            const midValue = (_a = rule.midpoint) === null || _a === void 0 ? void 0 : _a.value;
            if (rule.midpoint &&
                ["number", "percentage", "percentile"].includes(rule.midpoint.type) &&
                rule.minimum.type === rule.midpoint.type &&
                stringToNumber(minValue) >= stringToNumber(midValue)) {
                return 33 /* MinBiggerThanMid */;
            }
            return 0 /* Success */;
        }
        removeConditionalFormatting(id, sheet) {
            const cfIndex = this.cfRules[sheet].findIndex((s) => s.id === id);
            if (cfIndex !== -1) {
                const currentCF = this.cfRules[sheet].slice();
                currentCF.splice(cfIndex, 1);
                this.history.update("cfRules", sheet, currentCF);
            }
        }
    }
    ConditionalFormatPlugin.getters = ["getConditionalFormats", "getRulesSelection", "getRulesByCell"];

    class FigurePlugin extends CorePlugin {
        constructor() {
            super(...arguments);
            this.figures = {};
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        allowDispatch(cmd) {
            switch (cmd.type) {
                case "UPDATE_FIGURE":
                case "DELETE_FIGURE":
                    return this.checkFigureExists(cmd.sheetId, cmd.id);
                default:
                    return 0 /* Success */;
            }
        }
        handle(cmd) {
            switch (cmd.type) {
                case "CREATE_SHEET":
                    this.figures[cmd.sheetId] = {};
                    break;
                case "DELETE_SHEET":
                    this.deleteSheet(cmd.sheetId);
                    break;
                case "CREATE_FIGURE":
                    this.addFigure(cmd.figure, cmd.sheetId);
                    break;
                case "UPDATE_FIGURE":
                    const { type, sheetId, ...update } = cmd;
                    const figure = update;
                    this.updateFigure(sheetId, figure);
                    break;
                case "DELETE_FIGURE":
                    this.removeFigure(cmd.id, cmd.sheetId);
                    break;
            }
        }
        updateFigure(sheetId, figure) {
            if (!("id" in figure)) {
                return;
            }
            for (const [key, value] of Object.entries(figure)) {
                switch (key) {
                    case "x":
                    case "y":
                        if (value !== undefined) {
                            this.history.update("figures", sheetId, figure.id, key, Math.max(value, 0));
                        }
                        break;
                    case "width":
                    case "height":
                        if (value !== undefined) {
                            this.history.update("figures", sheetId, figure.id, key, value);
                        }
                        break;
                }
            }
        }
        addFigure(figure, sheetId) {
            this.history.update("figures", sheetId, figure.id, figure);
        }
        deleteSheet(sheetId) {
            this.history.update("figures", sheetId, undefined);
        }
        removeFigure(id, sheetId) {
            this.history.update("figures", sheetId, id, undefined);
        }
        checkFigureExists(sheetId, figureId) {
            var _a;
            if (((_a = this.figures[sheetId]) === null || _a === void 0 ? void 0 : _a[figureId]) === undefined) {
                return 53 /* FigureDoesNotExist */;
            }
            return 0 /* Success */;
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        getFigures(sheetId) {
            return Object.values(this.figures[sheetId] || {}).filter(isDefined);
        }
        getFigure(sheetId, figureId) {
            var _a;
            return (_a = this.figures[sheetId]) === null || _a === void 0 ? void 0 : _a[figureId];
        }
        // ---------------------------------------------------------------------------
        // Import/Export
        // ---------------------------------------------------------------------------
        import(data) {
            for (let sheet of data.sheets) {
                const figures = {};
                sheet.figures.forEach((figure) => {
                    figures[figure.id] = figure;
                });
                this.figures[sheet.id] = figures;
            }
        }
        export(data) {
            for (const sheet of data.sheets) {
                for (const figure of this.getFigures(sheet.id)) {
                    const data = undefined;
                    sheet.figures.push({ ...figure, data });
                }
            }
        }
        exportForExcel(data) {
            this.export(data);
        }
    }
    FigurePlugin.getters = ["getFigures", "getFigure"];

    class MergePlugin extends CorePlugin {
        constructor() {
            super(...arguments);
            this.nextId = 1;
            this.pending = null;
            this.merges = {};
            this.mergeCellMap = {};
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        allowDispatch(cmd) {
            const force = "force" in cmd ? !!cmd.force : false;
            switch (cmd.type) {
                case "ADD_MERGE":
                    if (force) {
                        return 0 /* Success */;
                    }
                    return this.checkValidations(cmd, this.checkDestructiveMerge, this.checkOverlap);
                case "UPDATE_CELL":
                    return this.checkMergedContentUpdate(cmd);
                default:
                    return 0 /* Success */;
            }
        }
        beforeHandle(cmd) {
            switch (cmd.type) {
                case "REMOVE_COLUMNS_ROWS":
                    if (cmd.dimension === "COL") {
                        this.exportAndRemoveMerges(cmd.sheetId, (range) => updateRemoveColumns(range, cmd.elements), true);
                    }
                    else {
                        this.exportAndRemoveMerges(cmd.sheetId, (range) => updateRemoveRows(range, cmd.elements), false);
                    }
                    break;
                case "ADD_COLUMNS_ROWS":
                    const base = cmd.position === "before" ? cmd.base : cmd.base + 1;
                    if (cmd.dimension === "COL") {
                        this.exportAndRemoveMerges(cmd.sheetId, (range) => updateAddColumns(range, base, cmd.quantity), true);
                    }
                    else {
                        this.exportAndRemoveMerges(cmd.sheetId, (range) => updateAddRows(range, base, cmd.quantity), false);
                    }
            }
        }
        handle(cmd) {
            switch (cmd.type) {
                case "CREATE_SHEET":
                    this.history.update("merges", cmd.sheetId, {});
                    this.history.update("mergeCellMap", cmd.sheetId, {});
                    break;
                case "DELETE_SHEET":
                    this.history.update("merges", cmd.sheetId, {});
                    this.history.update("mergeCellMap", cmd.sheetId, {});
                    break;
                case "DUPLICATE_SHEET":
                    this.history.update("merges", cmd.sheetIdTo, Object.assign({}, this.merges[cmd.sheetId]));
                    this.history.update("mergeCellMap", cmd.sheetIdTo, Object.assign({}, this.mergeCellMap[cmd.sheetId]));
                    break;
                case "ADD_MERGE":
                    if (!cmd.interactive) {
                        for (const zone of cmd.target) {
                            this.addMerge(this.getters.getSheet(cmd.sheetId), zone);
                        }
                    }
                    break;
                case "REMOVE_MERGE":
                    for (const zone of cmd.target) {
                        this.removeMerge(cmd.sheetId, zone);
                    }
                    break;
                case "ADD_COLUMNS_ROWS":
                case "REMOVE_COLUMNS_ROWS":
                    if (this.pending) {
                        this.importMerges(this.pending.sheet, this.pending.merges);
                        this.pending = null;
                    }
                    break;
            }
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        getMerges(sheetId) {
            return Object.values(this.merges[sheetId] || {}).filter(isDefined);
        }
        getMerge(sheetId, col, row) {
            var _a;
            const sheetMap = this.mergeCellMap[sheetId];
            const mergeId = sheetMap ? col in sheetMap && ((_a = sheetMap[col]) === null || _a === void 0 ? void 0 : _a[row]) : undefined;
            return mergeId ? this.getMergeById(sheetId, mergeId) : undefined;
        }
        /**
         * Return true if the zone intersects an existing merge:
         * if they have at least a common cell
         */
        doesIntersectMerge(sheetId, zone) {
            const { left, right, top, bottom } = zone;
            for (let row = top; row <= bottom; row++) {
                for (let col = left; col <= right; col++) {
                    if (this.getMerge(sheetId, col, row)) {
                        return true;
                    }
                }
            }
            return false;
        }
        /**
         * Returns true if two columns have at least one merge in common
         */
        doesColumnsHaveCommonMerges(sheetId, colA, colB) {
            const sheet = this.getters.getSheet(sheetId);
            for (let row = 0; row < sheet.rows.length; row++) {
                if (this.isInSameMerge(sheet.id, colA, row, colB, row)) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Returns true if two rows have at least one merge in common
         */
        doesRowsHaveCommonMerges(sheetId, rowA, rowB) {
            const sheet = this.getters.getSheet(sheetId);
            for (let col = 0; col <= sheet.cols.length; col++) {
                if (this.isInSameMerge(sheet.id, col, rowA, col, rowB)) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Add all necessary merge to the current selection to make it valid
         */
        expandZone(sheetId, zone) {
            let { left, right, top, bottom } = zone;
            let result = { left, right, top, bottom };
            for (let id in this.merges[sheetId]) {
                const merge = this.getMergeById(sheetId, parseInt(id));
                if (merge && overlap(merge, result)) {
                    result = union(merge, result);
                }
            }
            return isEqual(result, zone) ? result : this.expandZone(sheetId, result);
        }
        isInSameMerge(sheetId, colA, rowA, colB, rowB) {
            if (!this.isInMerge(sheetId, colA, rowA) || !this.isInMerge(sheetId, colB, rowB)) {
                return false;
            }
            return this.getMerge(sheetId, colA, rowA) === this.getMerge(sheetId, colB, rowB);
        }
        isInMerge(sheetId, col, row) {
            var _a;
            const sheetMap = this.mergeCellMap[sheetId];
            return sheetMap ? col in sheetMap && Boolean((_a = sheetMap[col]) === null || _a === void 0 ? void 0 : _a[row]) : false;
        }
        getMainCell(sheetId, col, row) {
            if (!this.isInMerge(sheetId, col, row)) {
                return [col, row];
            }
            const mergeTopLeftPos = this.getMerge(sheetId, col, row).topLeft;
            return [mergeTopLeftPos.col, mergeTopLeftPos.row];
        }
        getBottomLeftCell(sheetId, col, row) {
            if (!this.isInMerge(sheetId, col, row)) {
                return [col, row];
            }
            const { bottom, left } = this.getMerge(sheetId, col, row);
            return [left, bottom];
        }
        isMergeHidden(sheetId, merge) {
            const hiddenColsGroups = this.getters.getHiddenColsGroups(sheetId);
            const hiddenRowsGroups = this.getters.getHiddenRowsGroups(sheetId);
            for (let group of hiddenColsGroups) {
                if (merge.left >= group[0] && merge.right <= group[group.length - 1]) {
                    return true;
                }
            }
            for (let group of hiddenRowsGroups) {
                if (merge.top >= group[0] && merge.bottom <= group[group.length - 1]) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Check if the zone represents a single cell or a single merge.
         */
        isSingleCellOrMerge(sheetId, zone) {
            const merge = this.getMerge(sheetId, zone.left, zone.top);
            if (merge) {
                return isEqual(zone, merge);
            }
            const { width, height } = zoneToDimension(zone);
            return width === 1 && height === 1;
        }
        // ---------------------------------------------------------------------------
        // Merges
        // ---------------------------------------------------------------------------
        /**
         * Return true if the current selection requires losing state if it is merged.
         * This happens when there is some textual content in other cells than the
         * top left.
         */
        isMergeDestructive(sheet, zone) {
            let { left, right, top, bottom } = zone;
            right = clip(right, 0, sheet.cols.length - 1);
            bottom = clip(bottom, 0, sheet.rows.length - 1);
            for (let row = top; row <= bottom; row++) {
                const actualRow = this.getters.getRow(sheet.id, row);
                for (let col = left; col <= right; col++) {
                    if (col !== left || row !== top) {
                        const cell = actualRow.cells[col];
                        if (cell && !cell.isEmpty()) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        getMergeById(sheetId, mergeId) {
            const merges = this.merges[sheetId];
            return merges !== undefined ? merges[mergeId] : undefined;
        }
        checkDestructiveMerge({ sheetId, target }) {
            const sheet = this.getters.tryGetSheet(sheetId);
            if (!sheet)
                return 0 /* Success */;
            const isDestructive = target.some((zone) => this.isMergeDestructive(sheet, zone));
            return isDestructive ? 3 /* MergeIsDestructive */ : 0 /* Success */;
        }
        checkOverlap({ target }) {
            for (const zone of target) {
                for (const zone2 of target) {
                    if (zone !== zone2 && overlap(zone, zone2)) {
                        return 48 /* MergeOverlap */;
                    }
                }
            }
            return 0 /* Success */;
        }
        /**
         * The content of a merged cell should always be empty.
         * Except for the top-left cell.
         */
        checkMergedContentUpdate(cmd) {
            const { col, row, sheetId, content } = cmd;
            if (content === undefined) {
                return 0 /* Success */;
            }
            const [mainCol, mainRow] = this.getMainCell(sheetId, col, row);
            if (mainCol === col && mainRow === row) {
                return 0 /* Success */;
            }
            return 4 /* CellIsMerged */;
        }
        /**
         * Merge the current selection. Note that:
         * - it assumes that we have a valid selection (no intersection with other
         *   merges)
         * - it does nothing if the merge is trivial: A1:A1
         */
        addMerge(sheet, zone) {
            let { left, right, top, bottom } = zone;
            right = clip(right, 0, sheet.cols.length - 1);
            bottom = clip(bottom, 0, sheet.rows.length - 1);
            const tl = toXC(left, top);
            const br = toXC(right, bottom);
            if (tl === br) {
                return;
            }
            const topLeft = this.getters.getCell(sheet.id, left, top);
            let id = this.nextId++;
            this.history.update("merges", sheet.id, id, {
                id,
                left,
                top,
                right,
                bottom,
                topLeft: { col: left, row: top },
            });
            let previousMerges = new Set();
            for (let row = top; row <= bottom; row++) {
                for (let col = left; col <= right; col++) {
                    if (col !== left || row !== top) {
                        this.dispatch("UPDATE_CELL", {
                            sheetId: sheet.id,
                            col,
                            row,
                            style: topLeft ? topLeft.style : null,
                            content: undefined,
                        });
                    }
                    const merge = this.getMerge(sheet.id, col, row);
                    if (merge) {
                        previousMerges.add(merge.id);
                    }
                    this.history.update("mergeCellMap", sheet.id, col, row, id);
                }
            }
            for (let mergeId of previousMerges) {
                const { top, bottom, left, right } = this.getMergeById(sheet.id, mergeId);
                for (let r = top; r <= bottom; r++) {
                    for (let c = left; c <= right; c++) {
                        const merge = this.getMerge(sheet.id, c, r);
                        if (!merge || merge.id !== id) {
                            this.history.update("mergeCellMap", sheet.id, c, r, undefined);
                            this.dispatch("CLEAR_CELL", {
                                sheetId: sheet.id,
                                col: c,
                                row: r,
                            });
                        }
                    }
                }
                this.history.update("merges", sheet.id, mergeId, undefined);
            }
        }
        removeMerge(sheetId, zone) {
            const { left, top, bottom, right } = zone;
            const merge = this.getMerge(sheetId, left, top);
            if (merge === undefined || !isEqual(zone, merge)) {
                throw new Error(_lt("Invalid merge zone"));
            }
            this.history.update("merges", sheetId, merge.id, undefined);
            for (let r = top; r <= bottom; r++) {
                for (let c = left; c <= right; c++) {
                    this.history.update("mergeCellMap", sheetId, c, r, undefined);
                }
            }
        }
        // ---------------------------------------------------------------------------
        // Add/Remove columns
        // ---------------------------------------------------------------------------
        removeAllMerges(sheetId) {
            for (let id in this.merges[sheetId]) {
                this.history.update("merges", sheetId, parseInt(id), undefined);
            }
            for (let colNumber in this.mergeCellMap[sheetId]) {
                this.history.update("mergeCellMap", sheetId, parseInt(colNumber), undefined);
            }
        }
        exportAndRemoveMerges(sheetId, updater, isCol) {
            const merges = this.merges[sheetId];
            if (!merges)
                return;
            const mergeXcs = exportMerges(merges);
            const updatedMerges = [];
            for (let m of mergeXcs) {
                const update = updater(m);
                if (update) {
                    const [tl, br] = update.split(":");
                    if (tl !== br) {
                        updatedMerges.push(update);
                    }
                }
            }
            this.removeAllMerges(sheetId);
            this.pending = { sheet: sheetId, merges: updatedMerges };
        }
        // ---------------------------------------------------------------------------
        // Import/Export
        // ---------------------------------------------------------------------------
        import(data) {
            const sheets = data.sheets || [];
            for (let sheetData of sheets) {
                this.history.update("merges", sheetData.id, {});
                this.history.update("mergeCellMap", sheetData.id, {});
                if (sheetData.merges) {
                    this.importMerges(sheetData.id, sheetData.merges);
                }
            }
        }
        importMerges(sheetId, merges) {
            const sheet = this.getters.getSheet(sheetId);
            for (let merge of merges) {
                this.addMerge(sheet, toZone(merge));
            }
        }
        export(data) {
            for (let sheetData of data.sheets) {
                const merges = this.merges[sheetData.id];
                if (merges) {
                    sheetData.merges.push(...exportMerges(merges));
                }
            }
        }
        exportForExcel(data) {
            this.export(data);
        }
    }
    MergePlugin.getters = [
        "isInMerge",
        "isInSameMerge",
        "isMergeHidden",
        "getMainCell",
        "getBottomLeftCell",
        "expandZone",
        "doesIntersectMerge",
        "doesColumnsHaveCommonMerges",
        "doesRowsHaveCommonMerges",
        "getMerges",
        "getMerge",
        "isSingleCellOrMerge",
    ];
    function exportMerges(merges) {
        return Object.values(merges)
            .filter(isDefined)
            .map((merge) => toXC(merge.left, merge.top) + ":" + toXC(merge.right, merge.bottom));
    }

    class SheetPlugin extends CorePlugin {
        constructor() {
            super(...arguments);
            this.sheetIds = {};
            this.visibleSheets = []; // ids of visible sheets
            this.sheets = {};
            this.cellPosition = {};
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        allowDispatch(cmd) {
            const genericChecks = this.chainValidations(this.checkSheetExists, this.checkZones)(cmd);
            if (genericChecks !== 0 /* Success */) {
                return genericChecks;
            }
            switch (cmd.type) {
                case "CREATE_SHEET": {
                    return this.checkValidations(cmd, this.checkSheetName, this.checkSheetPosition);
                }
                case "MOVE_SHEET":
                    const currentIndex = this.visibleSheets.findIndex((id) => id === cmd.sheetId);
                    return (cmd.direction === "left" && currentIndex === 0) ||
                        (cmd.direction === "right" && currentIndex === this.visibleSheets.length - 1)
                        ? 12 /* WrongSheetMove */
                        : 0 /* Success */;
                case "RENAME_SHEET":
                    return this.isRenameAllowed(cmd);
                case "DELETE_SHEET":
                    return this.visibleSheets.length > 1
                        ? 0 /* Success */
                        : 8 /* NotEnoughSheets */;
                case "REMOVE_COLUMNS_ROWS":
                    const sheet = this.getSheet(cmd.sheetId);
                    const length = cmd.dimension === "COL" ? sheet.cols.length : sheet.rows.length;
                    return length > cmd.elements.length
                        ? 0 /* Success */
                        : 7 /* NotEnoughElements */;
                case "HIDE_COLUMNS_ROWS": {
                    const sheet = this.sheets[cmd.sheetId];
                    const hiddenGroup = cmd.dimension === "COL" ? sheet.hiddenColsGroups : sheet.hiddenRowsGroups;
                    const elements = cmd.dimension === "COL" ? sheet.cols : sheet.rows;
                    return (hiddenGroup || []).flat().concat(cmd.elements).length < elements.length
                        ? 0 /* Success */
                        : 49 /* TooManyHiddenElements */;
                }
                default:
                    return 0 /* Success */;
            }
        }
        handle(cmd) {
            switch (cmd.type) {
                case "SET_GRID_LINES_VISIBILITY":
                    this.setGridLinesVisibility(cmd.sheetId, cmd.areGridLinesVisible);
                    break;
                case "DELETE_CONTENT":
                    this.clearZones(cmd.sheetId, cmd.target);
                    break;
                case "CREATE_SHEET":
                    const sheet = this.createSheet(cmd.sheetId, cmd.name || this.getNextSheetName(), cmd.cols || 26, cmd.rows || 100, cmd.position);
                    this.history.update("sheetIds", sheet.name, sheet.id);
                    break;
                case "RESIZE_COLUMNS_ROWS":
                    const dimension = cmd.dimension === "COL" ? "cols" : "rows";
                    for (let elt of cmd.elements) {
                        this.setHeaderSize(this.getSheet(cmd.sheetId), dimension, elt, cmd.size);
                    }
                    break;
                case "MOVE_SHEET":
                    this.moveSheet(cmd.sheetId, cmd.direction);
                    break;
                case "RENAME_SHEET":
                    if (!cmd.interactive) {
                        this.renameSheet(this.sheets[cmd.sheetId], cmd.name);
                    }
                    break;
                case "DUPLICATE_SHEET":
                    this.duplicateSheet(cmd.sheetId, cmd.sheetIdTo);
                    break;
                case "DELETE_SHEET":
                    this.deleteSheet(this.sheets[cmd.sheetId]);
                    break;
                case "REMOVE_COLUMNS_ROWS":
                    if (cmd.dimension === "COL") {
                        this.removeColumns(this.sheets[cmd.sheetId], cmd.elements);
                    }
                    else {
                        this.removeRows(this.sheets[cmd.sheetId], cmd.elements);
                    }
                    break;
                case "ADD_COLUMNS_ROWS":
                    if (cmd.dimension === "COL") {
                        this.addColumns(this.sheets[cmd.sheetId], cmd.base, cmd.position, cmd.quantity);
                    }
                    else {
                        this.addRows(this.sheets[cmd.sheetId], cmd.base, cmd.position, cmd.quantity);
                    }
                    break;
                case "HIDE_COLUMNS_ROWS": {
                    if (cmd.dimension === "COL") {
                        this.setElementsVisibility(this.sheets[cmd.sheetId], cmd.elements, "cols", "hide");
                    }
                    else {
                        this.setElementsVisibility(this.sheets[cmd.sheetId], cmd.elements, "rows", "hide");
                    }
                    break;
                }
                case "UNHIDE_COLUMNS_ROWS": {
                    if (cmd.dimension === "COL") {
                        this.setElementsVisibility(this.sheets[cmd.sheetId], cmd.elements, "cols", "show");
                    }
                    else {
                        this.setElementsVisibility(this.sheets[cmd.sheetId], cmd.elements, "rows", "show");
                    }
                    break;
                }
                case "UPDATE_CELL_POSITION":
                    this.updateCellPosition(cmd);
                    break;
            }
        }
        // ---------------------------------------------------------------------------
        // Import/Export
        // ---------------------------------------------------------------------------
        import(data) {
            // we need to fill the sheetIds mapping first, because otherwise formulas
            // that depends on a sheet not already imported will not be able to be
            // compiled
            for (let sheet of data.sheets) {
                this.sheetIds[sheet.name] = sheet.id;
            }
            for (let sheetData of data.sheets) {
                const name = sheetData.name || _t("Sheet") + (Object.keys(this.sheets).length + 1);
                const { colNumber, rowNumber } = this.getImportedSheetSize(sheetData);
                const sheet = {
                    id: sheetData.id,
                    name: name,
                    cols: createCols(sheetData.cols || {}, colNumber),
                    rows: createRows(sheetData.rows || {}, rowNumber),
                    hiddenColsGroups: [],
                    hiddenRowsGroups: [],
                    areGridLinesVisible: sheetData.areGridLinesVisible === undefined ? true : sheetData.areGridLinesVisible,
                };
                this.visibleSheets.push(sheet.id);
                this.sheets[sheet.id] = sheet;
                this.updateHiddenElementsGroups(sheet.id, "cols");
                this.updateHiddenElementsGroups(sheet.id, "rows");
            }
        }
        exportSheets(data, exportDefaultSizes = false) {
            data.sheets = this.visibleSheets.filter(isDefined).map((id) => {
                const sheet = this.sheets[id];
                return {
                    id: sheet.id,
                    name: sheet.name,
                    colNumber: sheet.cols.length,
                    rowNumber: sheet.rows.length,
                    rows: exportRows(sheet.rows, exportDefaultSizes),
                    cols: exportCols(sheet.cols, exportDefaultSizes),
                    merges: [],
                    cells: {},
                    conditionalFormats: [],
                    figures: [],
                    areGridLinesVisible: sheet.areGridLinesVisible === undefined ? true : sheet.areGridLinesVisible,
                };
            });
        }
        export(data) {
            this.exportSheets(data);
        }
        exportForExcel(data) {
            this.exportSheets(data, true);
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        getGridLinesVisibility(sheetId) {
            return this.getSheet(sheetId).areGridLinesVisible;
        }
        tryGetSheet(sheetId) {
            return this.sheets[sheetId];
        }
        getSheet(sheetId) {
            const sheet = this.sheets[sheetId];
            if (!sheet) {
                throw new Error(`Sheet ${sheetId} not found.`);
            }
            return sheet;
        }
        /**
         * Return the sheet name. Throw if the sheet is not found.
         */
        getSheetName(sheetId) {
            return this.getSheet(sheetId).name;
        }
        /**
         * Return the sheet name or undefined if the sheet doesn't exist.
         */
        tryGetSheetName(sheetId) {
            var _a;
            return (_a = this.tryGetSheet(sheetId)) === null || _a === void 0 ? void 0 : _a.name;
        }
        getSheetIdByName(name) {
            if (name) {
                const unquotedName = getUnquotedSheetName(name);
                for (const key in this.sheetIds) {
                    if (key.toUpperCase() === unquotedName.toUpperCase()) {
                        return this.sheetIds[key];
                    }
                }
            }
            return undefined;
        }
        getSheets() {
            const { visibleSheets, sheets } = this;
            return visibleSheets.map((id) => sheets[id]).filter(isDefined);
        }
        getVisibleSheets() {
            return this.visibleSheets;
        }
        getEvaluationSheets() {
            return this.sheets;
        }
        getCol(sheetId, index) {
            var _a;
            return (_a = this.sheets[sheetId]) === null || _a === void 0 ? void 0 : _a.cols[index];
        }
        getRow(sheetId, index) {
            var _a;
            return (_a = this.sheets[sheetId]) === null || _a === void 0 ? void 0 : _a.rows[index];
        }
        getCell(sheetId, col, row) {
            const sheet = this.tryGetSheet(sheetId);
            return (sheet && sheet.rows[row] && sheet.rows[row].cells[col]) || undefined;
        }
        /**
         * Returns all the cells of a col
         */
        getColCells(sheetId, col) {
            return this.getSheet(sheetId).rows.reduce((acc, cur) => {
                const cell = cur.cells[col];
                return cell !== undefined ? acc.concat(cell) : acc;
            }, []);
        }
        getColsZone(sheetId, start, end) {
            return {
                top: 0,
                bottom: this.getSheet(sheetId).rows.length - 1,
                left: start,
                right: end,
            };
        }
        getRowsZone(sheetId, start, end) {
            return {
                top: start,
                bottom: end,
                left: 0,
                right: this.getSheet(sheetId).cols.length - 1,
            };
        }
        getCellPosition(cellId) {
            const cell = this.cellPosition[cellId];
            if (!cell) {
                throw new Error(`asking for a cell position that doesn't exist, cell id: ${cellId}`);
            }
            return cell;
        }
        getHiddenColsGroups(sheetId) {
            var _a;
            return ((_a = this.sheets[sheetId]) === null || _a === void 0 ? void 0 : _a.hiddenColsGroups) || [];
        }
        getHiddenRowsGroups(sheetId) {
            var _a;
            return ((_a = this.sheets[sheetId]) === null || _a === void 0 ? void 0 : _a.hiddenRowsGroups) || [];
        }
        getNumberCols(sheetId) {
            return this.getSheet(sheetId).cols.length;
        }
        getNumberRows(sheetId) {
            return this.getSheet(sheetId).rows.length;
        }
        getNextSheetName(baseName = "Sheet") {
            let i = 1;
            const names = this.getSheets().map((s) => s.name);
            let name = `${baseName}${i}`;
            while (names.includes(name)) {
                name = `${baseName}${i}`;
                i++;
            }
            return name;
        }
        // ---------------------------------------------------------------------------
        // Row/Col manipulation
        // ---------------------------------------------------------------------------
        /**
         * Check if a zone only contains empty cells
         */
        isEmpty(sheetId, zone) {
            const sheet = this.getSheet(sheetId);
            return mapCellsInZone(zone, sheet, (cell) => cell, undefined)
                .flat()
                .every((cell) => !cell || cell.isEmpty());
        }
        setHeaderSize(sheet, dimension, index, size) {
            let start, end;
            const elements = sheet[dimension];
            const base = elements[index];
            const delta = size - base.size;
            this.history.update("sheets", sheet.id, dimension, index, "size", size);
            if (!base.isHidden)
                this.history.update("sheets", sheet.id, dimension, index, "end", base.end + delta);
            start = base.end;
            for (let i = index + 1; i < elements.length; i++) {
                const element = elements[i];
                end = element.isHidden ? start : start + element.size;
                this.history.update("sheets", sheet.id, dimension, i, "start", start);
                this.history.update("sheets", sheet.id, dimension, i, "end", end);
                start = end;
            }
        }
        updateCellPosition(cmd) {
            if (cmd.cell) {
                const position = this.cellPosition[cmd.cellId];
                if (position) {
                    this.history.update("sheets", cmd.sheetId, "rows", position.row, "cells", position.col, undefined);
                }
                this.history.update("cellPosition", cmd.cell.id, {
                    row: cmd.row,
                    col: cmd.col,
                    sheetId: cmd.sheetId,
                });
                //TODO : remove cell from the command, only store the cellId in sheets[sheet].row[rowIndex].cells[colIndex]
                this.history.update("sheets", cmd.sheetId, "rows", cmd.row, "cells", cmd.col, cmd.cell);
            }
            else {
                this.history.update("cellPosition", cmd.cellId, undefined);
                this.history.update("sheets", cmd.sheetId, "rows", cmd.row, "cells", cmd.col, undefined);
            }
        }
        setGridLinesVisibility(sheetId, areGridLinesVisible) {
            this.history.update("sheets", sheetId, "areGridLinesVisible", areGridLinesVisible);
        }
        clearZones(sheetId, zones) {
            for (let zone of zones) {
                for (let col = zone.left; col <= zone.right; col++) {
                    for (let row = zone.top; row <= zone.bottom; row++) {
                        const cell = this.sheets[sheetId].rows[row].cells[col];
                        if (cell) {
                            this.dispatch("UPDATE_CELL", {
                                sheetId: sheetId,
                                content: "",
                                col,
                                row,
                            });
                        }
                    }
                }
            }
        }
        createSheet(id, name, colNumber, rowNumber, position) {
            const sheet = {
                id,
                name,
                cols: createDefaultCols(colNumber),
                rows: createDefaultRows(rowNumber),
                hiddenColsGroups: [],
                hiddenRowsGroups: [],
                areGridLinesVisible: true,
            };
            const visibleSheets = this.visibleSheets.slice();
            visibleSheets.splice(position, 0, sheet.id);
            const sheets = this.sheets;
            this.history.update("visibleSheets", visibleSheets);
            this.history.update("sheets", Object.assign({}, sheets, { [sheet.id]: sheet }));
            return sheet;
        }
        moveSheet(sheetId, direction) {
            const visibleSheets = this.visibleSheets.slice();
            const currentIndex = visibleSheets.findIndex((id) => id === sheetId);
            const sheet = visibleSheets.splice(currentIndex, 1);
            visibleSheets.splice(currentIndex + (direction === "left" ? -1 : 1), 0, sheet[0]);
            this.history.update("visibleSheets", visibleSheets);
        }
        checkSheetName(cmd) {
            const { visibleSheets, sheets } = this;
            const name = cmd.name && cmd.name.trim().toLowerCase();
            if (visibleSheets.find((id) => { var _a; return ((_a = sheets[id]) === null || _a === void 0 ? void 0 : _a.name.toLowerCase()) === name; })) {
                return 10 /* DuplicatedSheetName */;
            }
            if (FORBIDDEN_IN_EXCEL_REGEX.test(name)) {
                return 11 /* ForbiddenCharactersInSheetName */;
            }
            return 0 /* Success */;
        }
        checkSheetPosition(cmd) {
            const { visibleSheets } = this;
            if (cmd.position > visibleSheets.length || cmd.position < 0) {
                return 13 /* WrongSheetPosition */;
            }
            return 0 /* Success */;
        }
        isRenameAllowed(cmd) {
            if (cmd.interactive) {
                return 0 /* Success */;
            }
            const name = cmd.name && cmd.name.trim().toLowerCase();
            if (!name) {
                return 9 /* MissingSheetName */;
            }
            return this.checkSheetName(cmd);
        }
        renameSheet(sheet, name) {
            const oldName = sheet.name;
            this.history.update("sheets", sheet.id, "name", name.trim());
            const sheetIds = Object.assign({}, this.sheetIds);
            sheetIds[name] = sheet.id;
            delete sheetIds[oldName];
            this.history.update("sheetIds", sheetIds);
        }
        duplicateSheet(fromId, toId) {
            const sheet = this.getSheet(fromId);
            const toName = this.getDuplicateSheetName(sheet.name);
            const newSheet = JSON.parse(JSON.stringify(sheet));
            newSheet.id = toId;
            newSheet.name = toName;
            for (let col = 0; col <= newSheet.cols.length; col++) {
                for (let row = 0; row <= newSheet.rows.length; row++) {
                    if (newSheet.rows[row]) {
                        newSheet.rows[row].cells[col] = undefined;
                    }
                }
            }
            const visibleSheets = this.visibleSheets.slice();
            const currentIndex = visibleSheets.findIndex((id) => id === fromId);
            visibleSheets.splice(currentIndex + 1, 0, newSheet.id);
            this.history.update("visibleSheets", visibleSheets);
            this.history.update("sheets", Object.assign({}, this.sheets, { [newSheet.id]: newSheet }));
            for (const cell of Object.values(this.getters.getCells(fromId))) {
                const { col, row } = this.getCellPosition(cell.id);
                this.dispatch("UPDATE_CELL", {
                    sheetId: newSheet.id,
                    col,
                    row,
                    content: cell.content,
                    format: cell.format,
                    style: cell.style,
                });
            }
            const sheetIds = Object.assign({}, this.sheetIds);
            sheetIds[newSheet.name] = newSheet.id;
            this.history.update("sheetIds", sheetIds);
        }
        getDuplicateSheetName(sheetName) {
            let i = 1;
            const names = this.getters.getSheets().map((s) => s.name);
            const baseName = _lt("Copy of %s", sheetName);
            let name = baseName.toString();
            while (names.includes(name)) {
                name = `${baseName} (${i})`;
                i++;
            }
            return name;
        }
        deleteSheet(sheet) {
            const name = sheet.name;
            const sheets = Object.assign({}, this.sheets);
            delete sheets[sheet.id];
            this.history.update("sheets", sheets);
            const visibleSheets = this.visibleSheets.slice();
            const currentIndex = visibleSheets.findIndex((id) => id === sheet.id);
            visibleSheets.splice(currentIndex, 1);
            this.history.update("visibleSheets", visibleSheets);
            const sheetIds = Object.assign({}, this.sheetIds);
            delete sheetIds[name];
            this.history.update("sheetIds", sheetIds);
        }
        /**
         * Delete column. This requires a lot of handling:
         * - Update all the formulas in all sheets
         * - Move the cells
         * - Update the cols/rows (size, number, (cells), ...)
         * - Reevaluate the cells
         *
         * @param sheet ID of the sheet on which deletion should be applied
         * @param columns Columns to delete
         */
        removeColumns(sheet, columns) {
            // This is necessary because we have to delete elements in correct order:
            // begin with the end.
            columns.sort((a, b) => b - a);
            for (let column of columns) {
                // Move the cells.
                this.moveCellOnColumnsDeletion(sheet, column);
            }
            // Effectively delete the element and recompute the left-right.
            this.updateColumnsStructureOnDeletion(sheet, columns);
        }
        /**
         * Delete row. This requires a lot of handling:
         * - Update the merges
         * - Update all the formulas in all sheets
         * - Move the cells
         * - Update the cols/rows (size, number, (cells), ...)
         * - Reevaluate the cells
         *
         * @param sheet ID of the sheet on which deletion should be applied
         * @param rows Rows to delete
         */
        removeRows(sheet, rows) {
            // This is necessary because we have to delete elements in correct order:
            // begin with the end.
            rows.sort((a, b) => b - a);
            for (let group of groupConsecutive(rows)) {
                // Move the cells.
                this.moveCellOnRowsDeletion(sheet, group[group.length - 1], group[0]);
                // Effectively delete the element and recompute the left-right/top-bottom.
                group.map((row) => this.updateRowsStructureOnDeletion(row, sheet));
            }
        }
        addColumns(sheet, column, position, quantity) {
            // Move the cells.
            this.moveCellsOnAddition(sheet, position === "before" ? column : column + 1, quantity, "columns");
            // Recompute the left-right/top-bottom.
            this.updateColumnsStructureOnAddition(sheet, column, quantity);
        }
        addRows(sheet, row, position, quantity) {
            this.addEmptyRows(sheet, quantity);
            // Move the cells.
            this.moveCellsOnAddition(sheet, position === "before" ? row : row + 1, quantity, "rows");
            // Recompute the left-right/top-bottom.
            this.updateRowsStructureOnAddition(sheet, row, quantity);
        }
        moveCellOnColumnsDeletion(sheet, deletedColumn) {
            for (let [index, row] of Object.entries(sheet.rows)) {
                const rowIndex = parseInt(index, 10);
                for (let i in row.cells) {
                    const colIndex = parseInt(i, 10);
                    const cell = row.cells[i];
                    if (cell) {
                        if (colIndex === deletedColumn) {
                            this.dispatch("CLEAR_CELL", {
                                sheetId: sheet.id,
                                col: colIndex,
                                row: rowIndex,
                            });
                        }
                        if (colIndex > deletedColumn) {
                            this.dispatch("UPDATE_CELL_POSITION", {
                                sheetId: sheet.id,
                                cellId: cell.id,
                                cell: cell,
                                col: colIndex - 1,
                                row: rowIndex,
                            });
                        }
                    }
                }
            }
        }
        /**
         * Move the cells after a column or rows insertion
         */
        moveCellsOnAddition(sheet, addedElement, quantity, dimension) {
            const commands = [];
            for (const [index, row] of Object.entries(sheet.rows)) {
                const rowIndex = parseInt(index, 10);
                if (dimension !== "rows" || rowIndex >= addedElement) {
                    for (let i in row.cells) {
                        const colIndex = parseInt(i, 10);
                        const cell = row.cells[i];
                        if (cell) {
                            if (dimension === "rows" || colIndex >= addedElement) {
                                commands.push({
                                    type: "UPDATE_CELL_POSITION",
                                    sheetId: sheet.id,
                                    cellId: cell.id,
                                    cell: cell,
                                    col: colIndex + (dimension === "columns" ? quantity : 0),
                                    row: rowIndex + (dimension === "rows" ? quantity : 0),
                                });
                            }
                        }
                    }
                }
            }
            for (let cmd of commands.reverse()) {
                this.dispatch(cmd.type, cmd);
            }
        }
        /**
         * Move all the cells that are from the row under `deleteToRow` up to `deleteFromRow`
         *
         * b.e.
         * move vertically with delete from 3 and delete to 5 will first clear all the cells from lines 3 to 5,
         * then take all the row starting at index 6 and add them back at index 3
         *
         */
        moveCellOnRowsDeletion(sheet, deleteFromRow, deleteToRow) {
            const numberRows = deleteToRow - deleteFromRow + 1;
            for (let [index, row] of Object.entries(sheet.rows)) {
                const rowIndex = parseInt(index, 10);
                if (rowIndex >= deleteFromRow && rowIndex <= deleteToRow) {
                    for (let i in row.cells) {
                        const colIndex = parseInt(i, 10);
                        const cell = row.cells[i];
                        if (cell) {
                            this.dispatch("CLEAR_CELL", {
                                sheetId: sheet.id,
                                col: colIndex,
                                row: rowIndex,
                            });
                        }
                    }
                }
                if (rowIndex > deleteToRow) {
                    for (let i in row.cells) {
                        const colIndex = parseInt(i, 10);
                        const cell = row.cells[i];
                        if (cell) {
                            this.dispatch("UPDATE_CELL_POSITION", {
                                sheetId: sheet.id,
                                cellId: cell.id,
                                cell: cell,
                                col: colIndex,
                                row: rowIndex - numberRows,
                            });
                        }
                    }
                }
            }
        }
        /**
         * Update the cols of the sheet after a deletion:
         * - Rename the cols
         * - Update start-end
         *
         * @param sheet Sheet on which the deletion occurs
         * @param deletedColumns Indexes of the deleted columns
         */
        updateColumnsStructureOnDeletion(sheet, deletedColumns) {
            const cols = [];
            let start = 0;
            let colSizeIndex = 0;
            for (let index in sheet.cols) {
                if (deletedColumns.includes(parseInt(index, 10))) {
                    continue;
                }
                const { size, isHidden } = sheet.cols[index];
                const end = isHidden ? start : start + size;
                cols.push({
                    name: numberToLetters(colSizeIndex),
                    size,
                    start,
                    end,
                    isHidden,
                });
                start = end;
                colSizeIndex++;
            }
            this.history.update("sheets", sheet.id, "cols", cols);
            this.updateHiddenElementsGroups(sheet.id, "cols");
        }
        /**
         * Update the cols of the sheet after an addition:
         * - Rename the cols
         * - Update start-end
         *
         * @param sheet Sheet on which the deletion occurs
         * @param addedColumn Index of the added columns
         * @param columnsToAdd Number of the columns to add
         */
        updateColumnsStructureOnAddition(sheet, addedColumn, columnsToAdd) {
            const cols = [];
            let start = 0;
            let colIndex = 0;
            for (let i in sheet.cols) {
                if (parseInt(i, 10) === addedColumn) {
                    const { size } = sheet.cols[colIndex];
                    for (let a = 0; a < columnsToAdd; a++) {
                        cols.push({
                            name: numberToLetters(colIndex),
                            size,
                            start,
                            end: start + size,
                        });
                        start += size;
                        colIndex++;
                    }
                }
                const { size, isHidden } = sheet.cols[i];
                const end = isHidden ? start : start + size;
                cols.push({
                    name: numberToLetters(colIndex),
                    size,
                    start,
                    end,
                    isHidden,
                });
                start = end;
                colIndex++;
            }
            this.history.update("sheets", sheet.id, "cols", cols);
            this.updateHiddenElementsGroups(sheet.id, "cols");
        }
        updateRowsStructureOnDeletion(index, sheet) {
            const rows = [];
            let start = 0;
            let rowIndex = 0;
            const cellsQueue = sheet.rows.map((row) => row.cells);
            for (let i in sheet.rows) {
                const row = sheet.rows[i];
                const { size, isHidden } = row;
                const end = isHidden ? start : start + size;
                if (parseInt(i, 10) === index) {
                    continue;
                }
                rowIndex++;
                rows.push({
                    start,
                    end,
                    size,
                    cells: cellsQueue.shift(),
                    name: String(rowIndex),
                    isHidden,
                });
                start = end;
            }
            this.history.update("sheets", sheet.id, "rows", rows);
            this.updateHiddenElementsGroups(sheet.id, "rows");
        }
        /**
         * Update the rows of the sheet after an addition:
         * - Rename the rows
         * - Update start-end
         *
         * @param sheet Sheet on which the deletion occurs
         * @param addedRow Index of the added row
         * @param rowsToAdd Number of the rows to add
         */
        updateRowsStructureOnAddition(sheet, addedRow, rowsToAdd) {
            const rows = [];
            let start = 0;
            let rowIndex = 0;
            let sizeIndex = 0;
            const cellsQueue = sheet.rows.map((row) => row.cells);
            for (let i in sheet.rows) {
                const { size, isHidden } = sheet.rows[sizeIndex];
                const end = isHidden ? start : start + size;
                if (parseInt(i, 10) < addedRow || parseInt(i, 10) >= addedRow + rowsToAdd) {
                    sizeIndex++;
                }
                rowIndex++;
                rows.push({
                    start,
                    end,
                    size,
                    cells: cellsQueue.shift(),
                    name: String(rowIndex),
                    isHidden,
                });
                start = end;
            }
            this.history.update("sheets", sheet.id, "rows", rows);
            this.updateHiddenElementsGroups(sheet.id, "rows");
        }
        /**
         * Add empty rows at the end of the rows
         *
         * @param sheet Sheet
         * @param quantity Number of rows to add
         */
        addEmptyRows(sheet, quantity) {
            const lastEnd = sheet.rows[sheet.rows.length - 1].end;
            const rows = sheet.rows.slice();
            for (let i = 0; i < quantity; i++) {
                rows.push({
                    start: lastEnd,
                    end: lastEnd,
                    size: 0,
                    name: (rows.length + 1).toString(),
                    cells: {},
                });
            }
            this.history.update("sheets", sheet.id, "rows", rows);
        }
        getImportedSheetSize(data) {
            const positions = Object.keys(data.cells).map(toCartesian);
            return {
                rowNumber: Math.max(data.rowNumber, ...new Set(positions.map(([col, row]) => row + 1))),
                colNumber: Math.max(data.colNumber, ...new Set(positions.map(([col, row]) => col + 1))),
            };
        }
        // ----------------------------------------------------
        //  HIDE / SHOW
        // ----------------------------------------------------
        setElementsVisibility(sheet, elements, direction, visibility) {
            let start = 0;
            const hide = visibility === "hide";
            for (let index = 0; index < sheet[direction].length; index++) {
                const { size, isHidden } = sheet[direction][index];
                const newIsHidden = elements.includes(index) ? hide : isHidden || false;
                const end = newIsHidden ? start : start + size;
                this.history.update("sheets", sheet.id, direction, index, "start", start);
                this.history.update("sheets", sheet.id, direction, index, "end", end);
                this.history.update("sheets", sheet.id, direction, index, "isHidden", newIsHidden);
                start = end;
            }
            this.updateHiddenElementsGroups(sheet.id, direction);
        }
        updateHiddenElementsGroups(sheetId, dimension) {
            var _a;
            const elements = ((_a = this.sheets[sheetId]) === null || _a === void 0 ? void 0 : _a[dimension]) || [];
            const elementsRef = dimension === "cols" ? "hiddenColsGroups" : "hiddenRowsGroups";
            const hiddenEltsGroups = elements.reduce((acc, currentElt, index) => {
                if (!currentElt.isHidden) {
                    return acc;
                }
                const currentGroup = acc[acc.length - 1];
                if (!currentGroup || currentGroup[currentGroup.length - 1] != index - 1) {
                    acc.push([]);
                }
                acc[acc.length - 1].push(index);
                return acc;
            }, []);
            this.history.update("sheets", sheetId, elementsRef, hiddenEltsGroups);
        }
        /**
         * Check that any "sheetId" in the command matches an existing
         * sheet.
         */
        checkSheetExists(cmd) {
            if (cmd.type !== "CREATE_SHEET" && "sheetId" in cmd && this.sheets[cmd.sheetId] === undefined) {
                return 21 /* InvalidSheetId */;
            }
            return 0 /* Success */;
        }
        /**
         * Check if zones in the command are well formed and
         * not outside the sheet.
         */
        checkZones(cmd) {
            const zones = [];
            if ("zone" in cmd) {
                zones.push(cmd.zone);
            }
            if ("target" in cmd && Array.isArray(cmd.target)) {
                zones.push(...cmd.target);
            }
            if (!zones.every(isZoneValid)) {
                return 20 /* InvalidRange */;
            }
            else if (zones.length && "sheetId" in cmd) {
                const sheet = this.getSheet(cmd.sheetId);
                const sheetZone = {
                    top: 0,
                    left: 0,
                    bottom: sheet.rows.length - 1,
                    right: sheet.cols.length - 1,
                };
                return zones.every((zone) => isZoneInside(zone, sheetZone))
                    ? 0 /* Success */
                    : 16 /* TargetOutOfSheet */;
            }
            return 0 /* Success */;
        }
    }
    SheetPlugin.getters = [
        "getSheetName",
        "tryGetSheetName",
        "getSheet",
        "tryGetSheet",
        "getSheetIdByName",
        "getSheets",
        "getVisibleSheets",
        "getEvaluationSheets",
        "getCol",
        "getRow",
        "getCell",
        "getCellPosition",
        "getColCells",
        "getColsZone",
        "getRowsZone",
        "getNumberCols",
        "getNumberRows",
        "getHiddenColsGroups",
        "getHiddenRowsGroups",
        "getGridLinesVisibility",
        "getNextSheetName",
        "isEmpty",
    ];

    /**
     * An AutofillModifierImplementation is used to describe how to handle a
     * AutofillModifier.
     */
    const autofillModifiersRegistry = new Registry();
    autofillModifiersRegistry
        .add("INCREMENT_MODIFIER", {
        apply: (rule, data) => {
            var _a;
            rule.current += rule.increment;
            const content = rule.current.toString();
            const tooltipValue = formatValue(rule.current, (_a = data.cell) === null || _a === void 0 ? void 0 : _a.format);
            return {
                cellData: {
                    border: data.border,
                    style: data.cell && data.cell.style,
                    format: data.cell && data.cell.format,
                    content,
                },
                tooltip: content ? { props: { content: tooltipValue } } : undefined,
            };
        },
    })
        .add("COPY_MODIFIER", {
        apply: (rule, data, getters) => {
            var _a, _b;
            const content = ((_a = data.cell) === null || _a === void 0 ? void 0 : _a.content) || "";
            return {
                cellData: {
                    border: data.border,
                    style: data.cell && data.cell.style,
                    format: data.cell && data.cell.format,
                    content,
                },
                tooltip: content ? { props: { content: (_b = data.cell) === null || _b === void 0 ? void 0 : _b.formattedValue } } : undefined,
            };
        },
    })
        .add("FORMULA_MODIFIER", {
        apply: (rule, data, getters, direction) => {
            rule.current += rule.increment;
            let x = 0;
            let y = 0;
            switch (direction) {
                case 0 /* UP */:
                    x = 0;
                    y = -rule.current;
                    break;
                case 1 /* DOWN */:
                    x = 0;
                    y = rule.current;
                    break;
                case 2 /* LEFT */:
                    x = -rule.current;
                    y = 0;
                    break;
                case 3 /* RIGHT */:
                    x = rule.current;
                    y = 0;
                    break;
            }
            if (!data.cell || !data.cell.isFormula()) {
                return { cellData: {} };
            }
            const sheetId = data.sheetId;
            const ranges = getters.createAdaptedRanges(data.cell.dependencies.references, x, y, sheetId);
            const content = getters.buildFormulaContent(sheetId, data.cell.normalizedText, {
                ...data.cell.dependencies,
                references: ranges,
            });
            return {
                cellData: {
                    border: data.border,
                    style: data.cell.style,
                    format: data.cell.format,
                    content,
                },
                tooltip: content ? { props: { content } } : undefined,
            };
        },
    });

    const autofillRulesRegistry = new Registry();
    /**
     * Get the consecutive xc that are of type "number" or "date".
     * Return the one which contains the given cell
     */
    function getGroup(cell, cells) {
        let group = [];
        let found = false;
        for (let x of cells) {
            if (x === cell) {
                found = true;
            }
            if ((x === null || x === void 0 ? void 0 : x.evaluated.type) === CellValueType.number) {
                group.push(x.evaluated.value);
            }
            else {
                if (found) {
                    return group;
                }
                group = [];
            }
        }
        return group;
    }
    /**
     * Get the average steps between numbers
     */
    function getAverageIncrement(group) {
        const averages = [];
        let last = group[0];
        for (let i = 1; i < group.length; i++) {
            const current = group[i];
            averages.push(current - last);
            last = current;
        }
        return averages.reduce((a, b) => a + b, 0) / averages.length;
    }
    autofillRulesRegistry
        .add("simple_value_copy", {
        condition: (cell, cells) => {
            var _a;
            return cells.length === 1 && !cell.isFormula() && !((_a = cell.format) === null || _a === void 0 ? void 0 : _a.match(DATETIME_FORMAT));
        },
        generateRule: () => {
            return { type: "COPY_MODIFIER" };
        },
        sequence: 10,
    })
        .add("copy_text", {
        condition: (cell) => !cell.isFormula() && cell.evaluated.type === CellValueType.text,
        generateRule: () => {
            return { type: "COPY_MODIFIER" };
        },
        sequence: 20,
    })
        .add("update_formula", {
        condition: (cell) => cell.isFormula(),
        generateRule: (_, cells) => {
            return { type: "FORMULA_MODIFIER", increment: cells.length, current: 0 };
        },
        sequence: 30,
    })
        .add("increment_number", {
        condition: (cell) => cell.evaluated.type === CellValueType.number,
        generateRule: (cell, cells) => {
            const group = getGroup(cell, cells);
            let increment = 1;
            if (group.length == 2) {
                increment = (group[1] - group[0]) * 2;
            }
            else if (group.length > 2) {
                increment = getAverageIncrement(group) * group.length;
            }
            return {
                type: "INCREMENT_MODIFIER",
                increment,
                current: cell.evaluated.type === CellValueType.number ? cell.evaluated.value : 0,
            };
        },
        sequence: 40,
    });

    const figureRegistry = new Registry();

    const inverseCommandRegistry = new Registry()
        .add("ADD_COLUMNS_ROWS", inverseAddColumnsRows)
        .add("REMOVE_COLUMNS_ROWS", inverseRemoveColumnsRows)
        .add("ADD_MERGE", inverseAddMerge)
        .add("REMOVE_MERGE", inverseRemoveMerge)
        .add("CREATE_SHEET", inverseCreateSheet)
        .add("DELETE_SHEET", inverseDeleteSheet)
        .add("DUPLICATE_SHEET", inverseDuplicateSheet)
        .add("CREATE_FIGURE", inverseCreateFigure)
        .add("CREATE_CHART", inverseCreateChart)
        .add("HIDE_COLUMNS_ROWS", inverseHideColumnsRows)
        .add("UNHIDE_COLUMNS_ROWS", inverseUnhideColumnsRows);
    for (const cmd of coreTypes.values()) {
        try {
            inverseCommandRegistry.get(cmd);
        }
        catch (_) {
            inverseCommandRegistry.add(cmd, identity);
        }
    }
    function identity(cmd) {
        return [cmd];
    }
    function inverseAddColumnsRows(cmd) {
        const elements = [];
        let start = cmd.base;
        if (cmd.position === "after") {
            start++;
        }
        for (let i = 0; i < cmd.quantity; i++) {
            elements.push(i + start);
        }
        return [
            {
                type: "REMOVE_COLUMNS_ROWS",
                dimension: cmd.dimension,
                elements,
                sheetId: cmd.sheetId,
            },
        ];
    }
    function inverseAddMerge(cmd) {
        return [{ type: "REMOVE_MERGE", sheetId: cmd.sheetId, target: cmd.target }];
    }
    function inverseRemoveMerge(cmd) {
        return [{ type: "ADD_MERGE", sheetId: cmd.sheetId, target: cmd.target }];
    }
    function inverseCreateSheet(cmd) {
        return [{ type: "DELETE_SHEET", sheetId: cmd.sheetId }];
    }
    function inverseDuplicateSheet(cmd) {
        return [{ type: "DELETE_SHEET", sheetId: cmd.sheetIdTo }];
    }
    function inverseRemoveColumnsRows(cmd) {
        const commands = [];
        const elements = [...cmd.elements].sort((a, b) => a - b);
        for (let group of groupConsecutive(elements)) {
            const column = group[0] === 0 ? 0 : group[0] - 1;
            const position = group[0] === 0 ? "before" : "after";
            commands.push({
                type: "ADD_COLUMNS_ROWS",
                dimension: cmd.dimension,
                quantity: group.length,
                base: column,
                sheetId: cmd.sheetId,
                position,
            });
        }
        return commands;
    }
    function inverseDeleteSheet(cmd) {
        return [{ type: "CREATE_SHEET", sheetId: cmd.sheetId, position: 1 }];
    }
    function inverseCreateFigure(cmd) {
        return [{ type: "DELETE_FIGURE", id: cmd.figure.id, sheetId: cmd.sheetId }];
    }
    function inverseCreateChart(cmd) {
        return [{ type: "DELETE_FIGURE", id: cmd.id, sheetId: cmd.sheetId }];
    }
    function inverseHideColumnsRows(cmd) {
        return [
            {
                type: "UNHIDE_COLUMNS_ROWS",
                sheetId: cmd.sheetId,
                dimension: cmd.dimension,
                elements: cmd.elements,
            },
        ];
    }
    function inverseUnhideColumnsRows(cmd) {
        return [
            {
                type: "HIDE_COLUMNS_ROWS",
                sheetId: cmd.sheetId,
                dimension: cmd.dimension,
                elements: cmd.elements,
            },
        ];
    }

    const DEFAULT_MENU_ITEM = (key) => ({
        isVisible: () => true,
        isEnabled: () => true,
        isReadonlyAllowed: false,
        shortCut: "",
        action: false,
        children: [],
        separator: false,
        icon: false,
        id: key,
    });
    function createFullMenuItem(key, value) {
        return Object.assign({}, DEFAULT_MENU_ITEM(key), value);
    }
    /**
     * The class Registry is extended in order to add the function addChild
     *
     */
    class MenuItemRegistry extends Registry {
        /**
         * @override
         */
        add(key, value) {
            this.content[key] = createFullMenuItem(key, value);
            return this;
        }
        /**
         * Add a subitem to an existing item
         * @param path Path of items to add this subitem
         * @param value Subitem to add
         */
        addChild(key, path, value) {
            const root = path.splice(0, 1)[0];
            let node = this.content[root];
            if (!node) {
                throw new Error(`Path ${root + ":" + path.join(":")} not found`);
            }
            for (let p of path) {
                if (typeof node.children === "function") {
                    node = undefined;
                }
                else {
                    node = node.children.find((elt) => elt.id === p);
                }
                if (!node) {
                    throw new Error(`Path ${root + ":" + path.join(":")} not found`);
                }
            }
            node.children.push(createFullMenuItem(key, value));
            return this;
        }
        getChildren(node, env) {
            if (typeof node.children === "function") {
                return node.children(env).sort((a, b) => a.sequence - b.sequence);
            }
            return node.children.sort((a, b) => a.sequence - b.sequence);
        }
        getName(node, env) {
            if (typeof node.name === "function") {
                return node.name(env);
            }
            return node.name;
        }
        getShortCut(node) {
            return node.shortCut ? node.shortCut : "";
        }
        /**
         * Get a list of all elements in the registry, ordered by sequence
         * @override
         */
        getAll() {
            return super.getAll().sort((a, b) => a.sequence - b.sequence);
        }
    }

    //------------------------------------------------------------------------------
    // Helpers
    //------------------------------------------------------------------------------
    function getColumnsNumber(env) {
        const activeCols = env.getters.getActiveCols();
        if (activeCols.size) {
            return activeCols.size;
        }
        else {
            const zone = env.getters.getSelectedZones()[0];
            return zone.right - zone.left + 1;
        }
    }
    function getRowsNumber(env) {
        const activeRows = env.getters.getActiveRows();
        if (activeRows.size) {
            return activeRows.size;
        }
        else {
            const zone = env.getters.getSelectedZones()[0];
            return zone.bottom - zone.top + 1;
        }
    }
    function setFormatter(env, format) {
        env.dispatch("SET_FORMATTING", {
            sheetId: env.getters.getActiveSheetId(),
            target: env.getters.getSelectedZones(),
            format,
        });
    }
    function setStyle(env, style) {
        env.dispatch("SET_FORMATTING", {
            sheetId: env.getters.getActiveSheetId(),
            target: env.getters.getSelectedZones(),
            style,
        });
    }
    //------------------------------------------------------------------------------
    // Simple actions
    //------------------------------------------------------------------------------
    const UNDO_ACTION = (env) => env.dispatch("REQUEST_UNDO");
    const REDO_ACTION = (env) => env.dispatch("REQUEST_REDO");
    const COPY_ACTION = async (env) => {
        env.dispatch("COPY", { target: env.getters.getSelectedZones() });
        await env.clipboard.writeText(env.getters.getClipboardContent());
    };
    const CUT_ACTION = async (env) => {
        env.dispatch("CUT", { target: env.getters.getSelectedZones() });
        await env.clipboard.writeText(env.getters.getClipboardContent());
    };
    const PASTE_ACTION = async (env) => {
        const spreadsheetClipboard = env.getters.getClipboardContent();
        let osClipboard;
        try {
            osClipboard = await env.clipboard.readText();
        }
        catch (e) {
            // Permission is required to read the clipboard.
            console.warn("The OS clipboard could not be read.");
            console.error(e);
        }
        const target = env.getters.getSelectedZones();
        if (osClipboard && osClipboard !== spreadsheetClipboard) {
            env.dispatch("PASTE_FROM_OS_CLIPBOARD", {
                target,
                text: osClipboard,
            });
        }
        else {
            env.dispatch("PASTE", { target, interactive: true });
        }
    };
    const PASTE_VALUE_ACTION = (env) => env.dispatch("PASTE", { target: env.getters.getSelectedZones(), pasteOption: "onlyValue" });
    const PASTE_FORMAT_ACTION = (env) => env.dispatch("PASTE", { target: env.getters.getSelectedZones(), pasteOption: "onlyFormat" });
    const DELETE_CONTENT_ACTION = (env) => env.dispatch("DELETE_CONTENT", {
        sheetId: env.getters.getActiveSheetId(),
        target: env.getters.getSelectedZones(),
    });
    const SET_FORMULA_VISIBILITY_ACTION = (env) => env.dispatch("SET_FORMULA_VISIBILITY", { show: !env.getters.shouldShowFormulas() });
    const SET_GRID_LINES_VISIBILITY_ACTION = (env) => {
        const sheetId = env.getters.getActiveSheetId();
        env.dispatch("SET_GRID_LINES_VISIBILITY", {
            sheetId,
            areGridLinesVisible: !env.getters.getGridLinesVisibility(sheetId),
        });
    };
    //------------------------------------------------------------------------------
    // Grid manipulations
    //------------------------------------------------------------------------------
    const DELETE_CONTENT_ROWS_NAME = (env) => {
        let first;
        let last;
        const activesRows = env.getters.getActiveRows();
        if (activesRows.size !== 0) {
            first = Math.min(...activesRows);
            last = Math.max(...activesRows);
        }
        else {
            const zone = env.getters.getSelectedZones()[0];
            first = zone.top;
            last = zone.bottom;
        }
        if (first === last) {
            return _lt("Clear row %s", (first + 1).toString());
        }
        return _lt("Clear rows %s - %s", (first + 1).toString(), (last + 1).toString());
    };
    const DELETE_CONTENT_ROWS_ACTION = (env) => {
        const sheetId = env.getters.getActiveSheetId();
        const target = [...env.getters.getActiveRows()].map((index) => env.getters.getRowsZone(sheetId, index, index));
        env.dispatch("DELETE_CONTENT", {
            target,
            sheetId: env.getters.getActiveSheetId(),
        });
    };
    const DELETE_CONTENT_COLUMNS_NAME = (env) => {
        let first;
        let last;
        const activeCols = env.getters.getActiveCols();
        if (activeCols.size !== 0) {
            first = Math.min(...activeCols);
            last = Math.max(...activeCols);
        }
        else {
            const zone = env.getters.getSelectedZones()[0];
            first = zone.left;
            last = zone.right;
        }
        if (first === last) {
            return _lt("Clear column %s", numberToLetters(first));
        }
        return _lt("Clear columns %s - %s", numberToLetters(first), numberToLetters(last));
    };
    const DELETE_CONTENT_COLUMNS_ACTION = (env) => {
        const sheetId = env.getters.getActiveSheetId();
        const target = [...env.getters.getActiveCols()].map((index) => env.getters.getColsZone(sheetId, index, index));
        env.dispatch("DELETE_CONTENT", {
            target,
            sheetId: env.getters.getActiveSheetId(),
        });
    };
    const REMOVE_ROWS_NAME = (env) => {
        let first;
        let last;
        const activesRows = env.getters.getActiveRows();
        if (activesRows.size !== 0) {
            first = Math.min(...activesRows);
            last = Math.max(...activesRows);
        }
        else {
            const zone = env.getters.getSelectedZones()[0];
            first = zone.top;
            last = zone.bottom;
        }
        if (first === last) {
            return _lt("Delete row %s", (first + 1).toString());
        }
        return _lt("Delete rows %s - %s", (first + 1).toString(), (last + 1).toString());
    };
    const REMOVE_ROWS_ACTION = (env) => {
        let rows = [...env.getters.getActiveRows()];
        if (!rows.length) {
            const zone = env.getters.getSelectedZones()[0];
            for (let i = zone.top; i <= zone.bottom; i++) {
                rows.push(i);
            }
        }
        env.dispatch("REMOVE_COLUMNS_ROWS", {
            sheetId: env.getters.getActiveSheetId(),
            dimension: "ROW",
            elements: rows,
        });
    };
    const REMOVE_COLUMNS_NAME = (env) => {
        let first;
        let last;
        const activeCols = env.getters.getActiveCols();
        if (activeCols.size !== 0) {
            first = Math.min(...activeCols);
            last = Math.max(...activeCols);
        }
        else {
            const zone = env.getters.getSelectedZones()[0];
            first = zone.left;
            last = zone.right;
        }
        if (first === last) {
            return _lt("Delete column %s", numberToLetters(first));
        }
        return _lt("Delete columns %s - %s", numberToLetters(first), numberToLetters(last));
    };
    const REMOVE_COLUMNS_ACTION = (env) => {
        let columns = [...env.getters.getActiveCols()];
        if (!columns.length) {
            const zone = env.getters.getSelectedZones()[0];
            for (let i = zone.left; i <= zone.right; i++) {
                columns.push(i);
            }
        }
        env.dispatch("REMOVE_COLUMNS_ROWS", {
            sheetId: env.getters.getActiveSheetId(),
            dimension: "COL",
            elements: columns,
        });
    };
    const INSERT_CELL_SHIFT_DOWN = (env) => {
        const zone = env.getters.getSelectedZone();
        env.dispatch("INSERT_CELL", { shiftDimension: "ROW", zone, interactive: true });
    };
    const INSERT_CELL_SHIFT_RIGHT = (env) => {
        const zone = env.getters.getSelectedZone();
        env.dispatch("INSERT_CELL", { shiftDimension: "COL", zone, interactive: true });
    };
    const DELETE_CELL_SHIFT_UP = (env) => {
        const zone = env.getters.getSelectedZone();
        env.dispatch("DELETE_CELL", { shiftDimension: "ROW", zone, interactive: true });
    };
    const DELETE_CELL_SHIFT_LEFT = (env) => {
        const zone = env.getters.getSelectedZone();
        env.dispatch("DELETE_CELL", { shiftDimension: "COL", zone, interactive: true });
    };
    const MENU_INSERT_ROWS_BEFORE_NAME = (env) => {
        const number = getRowsNumber(env);
        if (number === 1) {
            return _lt("Row above");
        }
        return _lt("%s Rows above", number.toString());
    };
    const ROW_INSERT_ROWS_BEFORE_NAME = (env) => {
        const number = getRowsNumber(env);
        return number === 1 ? _lt("Insert row above") : _lt("Insert %s rows above", number.toString());
    };
    const CELL_INSERT_ROWS_BEFORE_NAME = (env) => {
        const number = getRowsNumber(env);
        if (number === 1) {
            return _lt("Insert row");
        }
        return _lt("Insert %s rows", number.toString());
    };
    const INSERT_ROWS_BEFORE_ACTION = (env) => {
        const activeRows = env.getters.getActiveRows();
        let row;
        let quantity;
        if (activeRows.size) {
            row = Math.min(...activeRows);
            quantity = activeRows.size;
        }
        else {
            const zone = env.getters.getSelectedZones()[0];
            row = zone.top;
            quantity = zone.bottom - zone.top + 1;
        }
        env.dispatch("ADD_COLUMNS_ROWS", {
            sheetId: env.getters.getActiveSheetId(),
            position: "before",
            base: row,
            quantity,
            dimension: "ROW",
        });
    };
    const MENU_INSERT_ROWS_AFTER_NAME = (env) => {
        const number = getRowsNumber(env);
        if (number === 1) {
            return _lt("Row below");
        }
        return _lt("%s Rows below", number.toString());
    };
    const ROW_INSERT_ROWS_AFTER_NAME = (env) => {
        const number = getRowsNumber(env);
        return number === 1 ? _lt("Insert row below") : _lt("Insert %s rows below", number.toString());
    };
    const INSERT_ROWS_AFTER_ACTION = (env) => {
        const activeRows = env.getters.getActiveRows();
        let row;
        let quantity;
        if (activeRows.size) {
            row = Math.max(...activeRows);
            quantity = activeRows.size;
        }
        else {
            const zone = env.getters.getSelectedZones()[0];
            row = zone.bottom;
            quantity = zone.bottom - zone.top + 1;
        }
        env.dispatch("ADD_COLUMNS_ROWS", {
            sheetId: env.getters.getActiveSheetId(),
            position: "after",
            base: row,
            quantity,
            dimension: "ROW",
        });
    };
    const MENU_INSERT_COLUMNS_BEFORE_NAME = (env) => {
        const number = getColumnsNumber(env);
        if (number === 1) {
            return _lt("Column left");
        }
        return _lt("%s Columns left", number.toString());
    };
    const COLUMN_INSERT_COLUMNS_BEFORE_NAME = (env) => {
        const number = getColumnsNumber(env);
        return number === 1
            ? _lt("Insert column left")
            : _lt("Insert %s columns left", number.toString());
    };
    const CELL_INSERT_COLUMNS_BEFORE_NAME = (env) => {
        const number = getColumnsNumber(env);
        if (number === 1) {
            return _lt("Insert column");
        }
        return _lt("Insert %s columns", number.toString());
    };
    const INSERT_COLUMNS_BEFORE_ACTION = (env) => {
        const activeCols = env.getters.getActiveCols();
        let column;
        let quantity;
        if (activeCols.size) {
            column = Math.min(...activeCols);
            quantity = activeCols.size;
        }
        else {
            const zone = env.getters.getSelectedZones()[0];
            column = zone.left;
            quantity = zone.right - zone.left + 1;
        }
        env.dispatch("ADD_COLUMNS_ROWS", {
            sheetId: env.getters.getActiveSheetId(),
            position: "before",
            dimension: "COL",
            base: column,
            quantity,
        });
    };
    const MENU_INSERT_COLUMNS_AFTER_NAME = (env) => {
        const number = getColumnsNumber(env);
        if (number === 1) {
            return _lt("Column right");
        }
        return _lt("%s Columns right", number.toString());
    };
    const COLUMN_INSERT_COLUMNS_AFTER_NAME = (env) => {
        const number = getColumnsNumber(env);
        return number === 1
            ? _lt("Insert column right")
            : _lt("Insert %s columns right", number.toString());
    };
    const INSERT_COLUMNS_AFTER_ACTION = (env) => {
        const activeCols = env.getters.getActiveCols();
        let column;
        let quantity;
        if (activeCols.size) {
            column = Math.max(...activeCols);
            quantity = activeCols.size;
        }
        else {
            const zone = env.getters.getSelectedZones()[0];
            column = zone.right;
            quantity = zone.right - zone.left + 1;
        }
        env.dispatch("ADD_COLUMNS_ROWS", {
            sheetId: env.getters.getActiveSheetId(),
            position: "after",
            dimension: "COL",
            base: column,
            quantity,
        });
    };
    const HIDE_COLUMNS_NAME = (env) => {
        const cols = env.getters.getElementsFromSelection("COL");
        let first = cols[0];
        let last = cols[cols.length - 1];
        if (cols.length === 1) {
            return _lt("Hide column %s", numberToLetters(first).toString());
        }
        else if (last - first + 1 === cols.length) {
            return _lt("Hide columns %s - %s", numberToLetters(first).toString(), numberToLetters(last).toString());
        }
        else {
            return _lt("Hide columns");
        }
    };
    const HIDE_COLUMNS_ACTION = (env) => {
        const columns = env.getters.getElementsFromSelection("COL");
        env.dispatch("HIDE_COLUMNS_ROWS", {
            sheetId: env.getters.getActiveSheetId(),
            dimension: "COL",
            elements: columns,
        });
    };
    const UNHIDE_ALL_COLUMNS_ACTION = (env) => {
        const sheet = env.getters.getActiveSheet();
        env.dispatch("UNHIDE_COLUMNS_ROWS", {
            sheetId: sheet.id,
            dimension: "COL",
            elements: Array.from(Array(sheet.cols.length).keys()),
        });
    };
    const UNHIDE_COLUMNS_ACTION = (env) => {
        const columns = env.getters.getElementsFromSelection("COL");
        env.dispatch("UNHIDE_COLUMNS_ROWS", {
            sheetId: env.getters.getActiveSheetId(),
            dimension: "COL",
            elements: columns,
        });
    };
    const HIDE_ROWS_NAME = (env) => {
        const rows = env.getters.getElementsFromSelection("ROW");
        let first = rows[0];
        let last = rows[rows.length - 1];
        if (rows.length === 1) {
            return _lt("Hide row %s", (first + 1).toString());
        }
        else if (last - first + 1 === rows.length) {
            return _lt("Hide rows %s - %s", (first + 1).toString(), (last + 1).toString());
        }
        else {
            return _lt("Hide rows");
        }
    };
    const HIDE_ROWS_ACTION = (env) => {
        const rows = env.getters.getElementsFromSelection("ROW");
        env.dispatch("HIDE_COLUMNS_ROWS", {
            sheetId: env.getters.getActiveSheetId(),
            dimension: "ROW",
            elements: rows,
        });
    };
    const UNHIDE_ALL_ROWS_ACTION = (env) => {
        const sheet = env.getters.getActiveSheet();
        env.dispatch("UNHIDE_COLUMNS_ROWS", {
            sheetId: sheet.id,
            dimension: "ROW",
            elements: Array.from(Array(sheet.rows.length).keys()),
        });
    };
    const UNHIDE_ROWS_ACTION = (env) => {
        const columns = env.getters.getElementsFromSelection("ROW");
        env.dispatch("UNHIDE_COLUMNS_ROWS", {
            sheetId: env.getters.getActiveSheetId(),
            dimension: "ROW",
            elements: columns,
        });
    };
    //------------------------------------------------------------------------------
    // Sheets
    //------------------------------------------------------------------------------
    const CREATE_SHEET_ACTION = (env) => {
        const activeSheetId = env.getters.getActiveSheetId();
        const position = env.getters.getVisibleSheets().findIndex((sheetId) => sheetId === activeSheetId) + 1;
        const sheetId = env.uuidGenerator.uuidv4();
        env.dispatch("CREATE_SHEET", { sheetId, position });
        env.dispatch("ACTIVATE_SHEET", { sheetIdFrom: activeSheetId, sheetIdTo: sheetId });
    };
    //------------------------------------------------------------------------------
    // Charts
    //------------------------------------------------------------------------------
    const CREATE_CHART = (env) => {
        var _a, _b;
        const zone = env.getters.getSelectedZone();
        let dataSetZone = zone;
        const id = env.uuidGenerator.uuidv4();
        let labelRange;
        if (zone.left !== zone.right) {
            dataSetZone = { ...zone, left: zone.left + 1 };
        }
        const dataSets = [zoneToXc(dataSetZone)];
        const sheetId = env.getters.getActiveSheetId();
        const position = {
            x: ((_a = env.getters.getCol(sheetId, zone.right + 1)) === null || _a === void 0 ? void 0 : _a.start) || 0,
            y: ((_b = env.getters.getRow(sheetId, zone.top)) === null || _b === void 0 ? void 0 : _b.start) || 0,
        };
        let dataSetsHaveTitle = false;
        for (let x = dataSetZone.left; x <= dataSetZone.right; x++) {
            const cell = env.getters.getCell(sheetId, x, zone.top);
            if (cell && cell.evaluated.type !== CellValueType.number) {
                dataSetsHaveTitle = true;
                break;
            }
        }
        if (zone.left !== zone.right) {
            labelRange = zoneToXc({
                ...zone,
                right: zone.left,
                top: dataSetsHaveTitle ? zone.top + 1 : zone.top,
            });
        }
        env.dispatch("CREATE_CHART", {
            sheetId,
            id,
            position,
            definition: {
                title: "",
                dataSets,
                labelRange,
                type: "bar",
                stackedBar: false,
                dataSetsHaveTitle,
                background: BACKGROUND_CHART_COLOR,
                verticalAxisPosition: "left",
                legendPosition: "top",
            },
        });
        const figure = env.getters.getFigure(sheetId, id);
        env.openSidePanel("ChartPanel", { figure });
    };
    //------------------------------------------------------------------------------
    // Style/Format
    //------------------------------------------------------------------------------
    const FORMAT_GENERAL_ACTION = (env) => setFormatter(env, "");
    const FORMAT_NUMBER_ACTION = (env) => setFormatter(env, "#,##0.00");
    const FORMAT_PERCENT_ACTION = (env) => setFormatter(env, "0.00%");
    const FORMAT_DATE_ACTION = (env) => setFormatter(env, "m/d/yyyy");
    const FORMAT_TIME_ACTION = (env) => setFormatter(env, "hh:mm:ss a");
    const FORMAT_DATE_TIME_ACTION = (env) => setFormatter(env, "m/d/yyyy hh:mm:ss");
    const FORMAT_DURATION_ACTION = (env) => setFormatter(env, "hhhh:mm:ss");
    const FORMAT_BOLD_ACTION = (env) => setStyle(env, { bold: !env.getters.getCurrentStyle().bold });
    const FORMAT_ITALIC_ACTION = (env) => setStyle(env, { italic: !env.getters.getCurrentStyle().italic });
    const FORMAT_STRIKETHROUGH_ACTION = (env) => setStyle(env, { strikethrough: !env.getters.getCurrentStyle().strikethrough });
    const FORMAT_UNDERLINE_ACTION = (env) => setStyle(env, { underline: !env.getters.getCurrentStyle().underline });
    //------------------------------------------------------------------------------
    // Side panel
    //------------------------------------------------------------------------------
    const OPEN_CF_SIDEPANEL_ACTION = (env) => {
        env.openSidePanel("ConditionalFormatting", { selection: env.getters.getSelectedZones() });
    };
    const OPEN_FAR_SIDEPANEL_ACTION = (env) => {
        env.openSidePanel("FindAndReplace", {});
    };
    const INSERT_LINK = (env) => {
        env.openLinkEditor();
    };
    //------------------------------------------------------------------------------
    // Sorting action
    //------------------------------------------------------------------------------
    const SORT_CELLS_ASCENDING = (env) => {
        const { anchor, zones } = env.getters.getSelection();
        env.dispatch("SORT_CELLS", {
            interactive: true,
            sheetId: env.getters.getActiveSheetId(),
            anchor: anchor,
            zone: zones[0],
            sortDirection: "ascending",
        });
    };
    const SORT_CELLS_DESCENDING = (env) => {
        const { anchor, zones } = env.getters.getSelection();
        env.dispatch("SORT_CELLS", {
            interactive: true,
            sheetId: env.getters.getActiveSheetId(),
            anchor: anchor,
            zone: zones[0],
            sortDirection: "descending",
        });
    };
    const IS_ONLY_ONE_RANGE = (env) => {
        return env.getters.getSelectedZones().length === 1;
    };

    //------------------------------------------------------------------------------
    // Context Menu Registry
    //------------------------------------------------------------------------------
    const cellMenuRegistry = new MenuItemRegistry();
    cellMenuRegistry
        .add("cut", {
        name: _lt("Cut"),
        shortCut: "Ctrl+X",
        sequence: 10,
        action: CUT_ACTION,
    })
        .add("copy", {
        name: _lt("Copy"),
        shortCut: "Ctrl+C",
        sequence: 20,
        isReadonlyAllowed: true,
        action: COPY_ACTION,
    })
        .add("paste", {
        name: _lt("Paste"),
        shortCut: "Ctrl+V",
        sequence: 30,
        action: PASTE_ACTION,
        isVisible: IS_ONLY_ONE_RANGE,
    })
        .add("paste_special", {
        name: _lt("Paste special"),
        sequence: 40,
        separator: true,
        isVisible: IS_ONLY_ONE_RANGE,
    })
        .addChild("paste_value_only", ["paste_special"], {
        name: _lt("Paste values only"),
        sequence: 10,
        action: PASTE_VALUE_ACTION,
    })
        .addChild("paste_format_only", ["paste_special"], {
        name: _lt("Paste format only"),
        sequence: 20,
        action: PASTE_FORMAT_ACTION,
    })
        .add("sort_range", {
        name: _lt("Sort range"),
        sequence: 50,
        isVisible: IS_ONLY_ONE_RANGE,
        separator: true,
    })
        .addChild("sort_ascending", ["sort_range"], {
        name: _lt("Ascending (A ⟶ Z)"),
        sequence: 10,
        action: SORT_CELLS_ASCENDING,
    })
        .addChild("sort_descending", ["sort_range"], {
        name: _lt("Descending (Z ⟶ A)"),
        sequence: 20,
        action: SORT_CELLS_DESCENDING,
    })
        .add("add_row_before", {
        name: CELL_INSERT_ROWS_BEFORE_NAME,
        sequence: 70,
        action: INSERT_ROWS_BEFORE_ACTION,
        isVisible: IS_ONLY_ONE_RANGE,
    })
        .add("add_column_before", {
        name: CELL_INSERT_COLUMNS_BEFORE_NAME,
        sequence: 90,
        action: INSERT_COLUMNS_BEFORE_ACTION,
        isVisible: IS_ONLY_ONE_RANGE,
    })
        .add("insert_cell", {
        name: _lt("Insert cells"),
        sequence: 100,
        isVisible: IS_ONLY_ONE_RANGE,
        separator: true,
    })
        .addChild("insert_cell_down", ["insert_cell"], {
        name: _lt("Shift down"),
        sequence: 10,
        action: INSERT_CELL_SHIFT_DOWN,
    })
        .addChild("insert_cell_right", ["insert_cell"], {
        name: _lt("Shift right"),
        sequence: 20,
        action: INSERT_CELL_SHIFT_RIGHT,
    })
        .add("delete_row", {
        name: REMOVE_ROWS_NAME,
        sequence: 110,
        action: REMOVE_ROWS_ACTION,
        isVisible: IS_ONLY_ONE_RANGE,
    })
        .add("delete_column", {
        name: REMOVE_COLUMNS_NAME,
        sequence: 120,
        action: REMOVE_COLUMNS_ACTION,
        isVisible: IS_ONLY_ONE_RANGE,
    })
        .add("delete_cell", {
        name: _lt("Delete cells"),
        sequence: 130,
        isVisible: IS_ONLY_ONE_RANGE,
    })
        .addChild("delete_cell_up", ["delete_cell"], {
        name: _lt("Shift up"),
        sequence: 10,
        action: DELETE_CELL_SHIFT_UP,
    })
        .addChild("delete_cell_down", ["delete_cell"], {
        name: _lt("Shift left"),
        sequence: 20,
        action: DELETE_CELL_SHIFT_LEFT,
    })
        .add("clear_cell", {
        name: _lt("Clear cells"),
        sequence: 140,
        action: DELETE_CONTENT_ACTION,
        isEnabled: (env) => {
            const cell = env.getters.getActiveCell();
            return Boolean(cell);
        },
        separator: true,
    })
        .add("insert_link", {
        name: _lt("Insert link"),
        separator: true,
        sequence: 150,
        action: INSERT_LINK,
    })
        .add("conditional_formatting", {
        name: _lt("Conditional formatting"),
        sequence: 160,
        action: OPEN_CF_SIDEPANEL_ACTION,
        separator: true,
    });

    const colMenuRegistry = new MenuItemRegistry();
    colMenuRegistry
        .add("cut", {
        name: _lt("Cut"),
        shortCut: "Ctrl+X",
        sequence: 10,
        action: CUT_ACTION,
    })
        .add("copy", {
        name: _lt("Copy"),
        shortCut: "Ctrl+C",
        sequence: 20,
        isReadonlyAllowed: true,
        action: COPY_ACTION,
    })
        .add("paste", {
        name: _lt("Paste"),
        shortCut: "Ctrl+V",
        sequence: 30,
        action: PASTE_ACTION,
    })
        .add("paste_special", {
        name: _lt("Paste special"),
        sequence: 40,
        separator: true,
    })
        .addChild("paste_value_only", ["paste_special"], {
        name: _lt("Paste value only"),
        sequence: 10,
        action: PASTE_VALUE_ACTION,
    })
        .addChild("paste_format_only", ["paste_special"], {
        name: _lt("Paste format only"),
        sequence: 20,
        action: PASTE_FORMAT_ACTION,
    })
        .add("sort_columns", {
        name: (env) => env.getters.getActiveCols().size > 1 ? _lt("Sort columns") : _lt("Sort column"),
        sequence: 50,
        isVisible: IS_ONLY_ONE_RANGE,
        separator: true,
    })
        .addChild("sort_ascending", ["sort_columns"], {
        name: _lt("Ascending (A ⟶ Z)"),
        sequence: 10,
        action: SORT_CELLS_ASCENDING,
    })
        .addChild("sort_descending", ["sort_columns"], {
        name: _lt("Descending (Z ⟶ A)"),
        sequence: 20,
        action: SORT_CELLS_DESCENDING,
    })
        .add("add_column_before", {
        name: COLUMN_INSERT_COLUMNS_BEFORE_NAME,
        sequence: 70,
        action: INSERT_COLUMNS_BEFORE_ACTION,
    })
        .add("add_column_after", {
        name: COLUMN_INSERT_COLUMNS_AFTER_NAME,
        sequence: 80,
        action: INSERT_COLUMNS_AFTER_ACTION,
    })
        .add("delete_column", {
        name: REMOVE_COLUMNS_NAME,
        sequence: 90,
        action: REMOVE_COLUMNS_ACTION,
    })
        .add("clear_column", {
        name: DELETE_CONTENT_COLUMNS_NAME,
        sequence: 100,
        action: DELETE_CONTENT_COLUMNS_ACTION,
    })
        .add("hide_columns", {
        name: HIDE_COLUMNS_NAME,
        sequence: 85,
        action: HIDE_COLUMNS_ACTION,
        isVisible: (env) => {
            const sheet = env.getters.getActiveSheet();
            const hiddenCols = env.getters.getHiddenColsGroups(sheet.id).flat();
            return (sheet.cols.length > hiddenCols.length + env.getters.getElementsFromSelection("COL").length);
        },
        separator: true,
    })
        .add("unhide_columns", {
        name: "Unhide columns",
        sequence: 86,
        action: UNHIDE_COLUMNS_ACTION,
        isVisible: (env) => {
            const hiddenCols = env.getters.getHiddenColsGroups(env.getters.getActiveSheetId()).flat();
            const currentCols = env.getters.getElementsFromSelection("COL");
            return currentCols.some((col) => hiddenCols.includes(col));
        },
        separator: true,
    })
        .add("conditional_formatting", {
        name: _lt("Conditional formatting"),
        sequence: 110,
        action: OPEN_CF_SIDEPANEL_ACTION,
    });

    //------------------------------------------------------------------------------
    // Link Menu Registry
    //------------------------------------------------------------------------------
    const linkMenuRegistry = new MenuItemRegistry();
    linkMenuRegistry.add("sheet", {
        name: _lt("Link sheet"),
        sequence: 10,
        children: (env) => {
            const sheets = env.getters.getSheets();
            return sheets.map((sheet, i) => createFullMenuItem(sheet.id, {
                name: sheet.name,
                sequence: i,
                action: () => ({
                    link: { label: sheet.name, url: buildSheetLink(sheet.id) },
                    urlRepresentation: sheet.name,
                    isUrlEditable: false,
                }),
            }));
        },
    });

    const rowMenuRegistry = new MenuItemRegistry();
    rowMenuRegistry
        .add("cut", {
        name: _lt("Cut"),
        sequence: 10,
        shortCut: "Ctrl+X",
        action: CUT_ACTION,
    })
        .add("copy", {
        name: _lt("Copy"),
        shortCut: "Ctrl+C",
        sequence: 20,
        isReadonlyAllowed: true,
        action: COPY_ACTION,
    })
        .add("paste", {
        name: _lt("Paste"),
        shortCut: "Ctrl+V",
        sequence: 30,
        action: PASTE_ACTION,
    })
        .add("paste_special", {
        name: _lt("Paste special"),
        sequence: 40,
        separator: true,
    })
        .addChild("paste_value_only", ["paste_special"], {
        name: _lt("Paste value only"),
        sequence: 10,
        action: PASTE_VALUE_ACTION,
    })
        .addChild("paste_format_only", ["paste_special"], {
        name: _lt("Paste format only"),
        sequence: 20,
        action: PASTE_FORMAT_ACTION,
    })
        .add("add_row_before", {
        name: ROW_INSERT_ROWS_BEFORE_NAME,
        sequence: 50,
        action: INSERT_ROWS_BEFORE_ACTION,
    })
        .add("add_row_after", {
        name: ROW_INSERT_ROWS_AFTER_NAME,
        sequence: 60,
        action: INSERT_ROWS_AFTER_ACTION,
    })
        .add("delete_row", {
        name: REMOVE_ROWS_NAME,
        sequence: 70,
        action: REMOVE_ROWS_ACTION,
    })
        .add("clear_row", {
        name: DELETE_CONTENT_ROWS_NAME,
        sequence: 80,
        action: DELETE_CONTENT_ROWS_ACTION,
    })
        .add("hide_rows", {
        name: HIDE_ROWS_NAME,
        sequence: 85,
        action: HIDE_ROWS_ACTION,
        isVisible: (env) => {
            const sheet = env.getters.getActiveSheet();
            const hiddenRows = env.getters.getHiddenRowsGroups(sheet.id).flat();
            return (sheet.rows.length > hiddenRows.length + env.getters.getElementsFromSelection("ROW").length);
        },
        separator: true,
    })
        .add("unhide_rows", {
        name: "Unhide rows",
        sequence: 86,
        action: UNHIDE_ROWS_ACTION,
        isVisible: (env) => {
            const hiddenRows = env.getters.getHiddenRowsGroups(env.getters.getActiveSheetId()).flat();
            const currentRows = env.getters.getElementsFromSelection("ROW");
            return currentRows.some((col) => hiddenRows.includes(col));
        },
        separator: true,
    })
        .add("conditional_formatting", {
        name: _lt("Conditional formatting"),
        sequence: 90,
        action: OPEN_CF_SIDEPANEL_ACTION,
    });

    const sheetMenuRegistry = new MenuItemRegistry();
    sheetMenuRegistry
        .add("delete", {
        name: _lt("Delete"),
        sequence: 10,
        isVisible: (env) => {
            return env.getters.getSheets().length > 1;
        },
        action: (env) => env.dispatch("DELETE_SHEET_CONFIRMATION", { sheetId: env.getters.getActiveSheetId() }),
    })
        .add("duplicate", {
        name: _lt("Duplicate"),
        sequence: 20,
        action: (env) => {
            const sheetIdFrom = env.getters.getActiveSheetId();
            const sheetIdTo = env.uuidGenerator.uuidv4();
            env.dispatch("DUPLICATE_SHEET", {
                sheetId: sheetIdFrom,
                sheetIdTo,
            });
            env.dispatch("ACTIVATE_SHEET", { sheetIdFrom, sheetIdTo });
        },
    })
        .add("rename", {
        name: _lt("Rename"),
        sequence: 30,
        action: (env) => env.dispatch("RENAME_SHEET", {
            interactive: true,
            sheetId: env.getters.getActiveSheetId(),
        }),
    })
        .add("move_right", {
        name: _lt("Move right"),
        sequence: 40,
        isVisible: (env) => {
            const sheet = env.getters.getActiveSheetId();
            const sheets = env.getters.getSheets();
            return sheets.findIndex((s) => s.id === sheet) !== sheets.length - 1;
        },
        action: (env) => env.dispatch("MOVE_SHEET", { sheetId: env.getters.getActiveSheetId(), direction: "right" }),
    })
        .add("move_left", {
        name: _lt("Move left"),
        sequence: 50,
        isVisible: (env) => {
            const sheet = env.getters.getActiveSheetId();
            return env.getters.getSheets().findIndex((s) => s.id === sheet) !== 0;
        },
        action: (env) => env.dispatch("MOVE_SHEET", { sheetId: env.getters.getActiveSheetId(), direction: "left" }),
    });

    const topbarMenuRegistry = new MenuItemRegistry();
    topbarMenuRegistry
        .add("file", { name: _lt("File"), sequence: 10 })
        .add("edit", { name: _lt("Edit"), sequence: 20 })
        .add("view", { name: _lt("View"), sequence: 30 })
        .add("insert", { name: _lt("Insert"), sequence: 40 })
        .add("format", { name: _lt("Format"), sequence: 50 })
        .add("data", { name: _lt("Data"), sequence: 60 })
        .addChild("save", ["file"], {
        name: _lt("Save"),
        shortCut: "Ctrl+S",
        sequence: 10,
        action: () => console.log("Not implemented"),
    })
        .addChild("undo", ["edit"], {
        name: _lt("Undo"),
        shortCut: "Ctrl+Z",
        sequence: 10,
        action: UNDO_ACTION,
    })
        .addChild("redo", ["edit"], {
        name: _lt("Redo"),
        shortCut: "Ctrl+Y",
        sequence: 20,
        action: REDO_ACTION,
        separator: true,
    })
        .addChild("copy", ["edit"], {
        name: _lt("Copy"),
        shortCut: "Ctrl+C",
        sequence: 30,
        isReadonlyAllowed: true,
        action: COPY_ACTION,
    })
        .addChild("cut", ["edit"], {
        name: _lt("Cut"),
        shortCut: "Ctrl+X",
        sequence: 40,
        action: CUT_ACTION,
    })
        .addChild("paste", ["edit"], {
        name: _lt("Paste"),
        shortCut: "Ctrl+V",
        sequence: 50,
        action: PASTE_ACTION,
    })
        .addChild("paste_special", ["edit"], {
        name: _lt("Paste special"),
        sequence: 60,
        separator: true,
    })
        .addChild("paste_special_value", ["edit", "paste_special"], {
        name: _lt("Paste value only"),
        sequence: 10,
        action: PASTE_VALUE_ACTION,
    })
        .addChild("paste_special_format", ["edit", "paste_special"], {
        name: _lt("Paste format only"),
        sequence: 20,
        action: PASTE_FORMAT_ACTION,
    })
        .addChild("sort_range", ["edit"], {
        name: _lt("Sort range"),
        sequence: 62,
        isVisible: IS_ONLY_ONE_RANGE,
        separator: true,
    })
        .addChild("sort_ascending", ["edit", "sort_range"], {
        name: _lt("Ascending (A ⟶ Z)"),
        sequence: 10,
        action: SORT_CELLS_ASCENDING,
    })
        .addChild("sort_descending", ["edit", "sort_range"], {
        name: _lt("Descending (Z ⟶ A)"),
        sequence: 20,
        action: SORT_CELLS_DESCENDING,
    })
        .addChild("find_and_replace", ["edit"], {
        name: _lt("Find and replace"),
        shortCut: "Ctrl+H",
        sequence: 65,
        isReadonlyAllowed: true,
        action: OPEN_FAR_SIDEPANEL_ACTION,
        separator: true,
    })
        .addChild("edit_delete_cell_values", ["edit"], {
        name: _lt("Delete values"),
        sequence: 70,
        action: DELETE_CONTENT_ACTION,
    })
        .addChild("edit_delete_row", ["edit"], {
        name: REMOVE_ROWS_NAME,
        sequence: 80,
        action: REMOVE_ROWS_ACTION,
    })
        .addChild("edit_delete_column", ["edit"], {
        name: REMOVE_COLUMNS_NAME,
        sequence: 90,
        action: REMOVE_COLUMNS_ACTION,
    })
        .addChild("edit_delete_cell_shift_up", ["edit"], {
        name: _lt("Delete cell and shift up"),
        sequence: 93,
        action: DELETE_CELL_SHIFT_UP,
    })
        .addChild("edit_delete_cell_shift_left", ["edit"], {
        name: _lt("Delete cell and shift left"),
        sequence: 97,
        action: DELETE_CELL_SHIFT_LEFT,
    })
        .addChild("edit_unhide_columns", ["edit"], {
        name: _lt("Unhide all columns"),
        sequence: 100,
        action: UNHIDE_ALL_COLUMNS_ACTION,
        isVisible: (env) => env.getters.getHiddenColsGroups(env.getters.getActiveSheetId()).length > 0,
    })
        .addChild("edit_unhide_rows", ["edit"], {
        name: _lt("Unhide all rows"),
        sequence: 100,
        action: UNHIDE_ALL_ROWS_ACTION,
        isVisible: (env) => env.getters.getHiddenRowsGroups(env.getters.getActiveSheetId()).length > 0,
    })
        .addChild("insert_row_before", ["insert"], {
        name: MENU_INSERT_ROWS_BEFORE_NAME,
        sequence: 10,
        action: INSERT_ROWS_BEFORE_ACTION,
        isVisible: (env) => env.getters.getActiveCols().size === 0,
    })
        .addChild("insert_row_after", ["insert"], {
        name: MENU_INSERT_ROWS_AFTER_NAME,
        sequence: 20,
        action: INSERT_ROWS_AFTER_ACTION,
        isVisible: (env) => env.getters.getActiveCols().size === 0,
        separator: true,
    })
        .addChild("insert_column_before", ["insert"], {
        name: MENU_INSERT_COLUMNS_BEFORE_NAME,
        sequence: 30,
        action: INSERT_COLUMNS_BEFORE_ACTION,
        isVisible: (env) => env.getters.getActiveRows().size === 0,
    })
        .addChild("insert_column_after", ["insert"], {
        name: MENU_INSERT_COLUMNS_AFTER_NAME,
        sequence: 40,
        action: INSERT_COLUMNS_AFTER_ACTION,
        isVisible: (env) => env.getters.getActiveRows().size === 0,
        separator: true,
    })
        .addChild("insert_insert_cell_shift_down", ["insert"], {
        name: _lt("Insert cells and shift down"),
        sequence: 43,
        action: INSERT_CELL_SHIFT_DOWN,
    })
        .addChild("insert_insert_cell_shift_right", ["insert"], {
        name: _lt("Insert cells and shift right"),
        sequence: 47,
        action: INSERT_CELL_SHIFT_RIGHT,
        separator: true,
    })
        .addChild("insert_chart", ["insert"], {
        name: _lt("Chart"),
        sequence: 50,
        action: CREATE_CHART,
    })
        .addChild("insert_link", ["insert"], {
        name: _lt("Link"),
        separator: true,
        sequence: 60,
        action: INSERT_LINK,
    })
        .addChild("insert_sheet", ["insert"], {
        name: _lt("New sheet"),
        sequence: 70,
        action: CREATE_SHEET_ACTION,
        separator: true,
    })
        .addChild("view_gridlines", ["view"], {
        name: (env) => env.getters.getGridLinesVisibility(env.getters.getActiveSheetId())
            ? _lt("Hide gridlines")
            : _lt("Show gridlines"),
        action: SET_GRID_LINES_VISIBILITY_ACTION,
        sequence: 5,
        separator: true,
    })
        .addChild("view_formulas", ["view"], {
        name: (env) => env.getters.shouldShowFormulas() ? _lt("Hide formulas") : _lt("Show formulas"),
        action: SET_FORMULA_VISIBILITY_ACTION,
        isReadonlyAllowed: true,
        sequence: 10,
    })
        .addChild("format_number", ["format"], {
        name: _lt("Numbers"),
        sequence: 10,
        separator: true,
    })
        .addChild("format_number_general", ["format", "format_number"], {
        name: _lt("General"),
        sequence: 10,
        separator: true,
        action: FORMAT_GENERAL_ACTION,
    })
        .addChild("format_number_number", ["format", "format_number"], {
        name: _lt("Number (1,000.12)"),
        sequence: 20,
        action: FORMAT_NUMBER_ACTION,
    })
        .addChild("format_number_percent", ["format", "format_number"], {
        name: _lt("Percent (10.12%)"),
        sequence: 30,
        separator: true,
        action: FORMAT_PERCENT_ACTION,
    })
        .addChild("format_number_date", ["format", "format_number"], {
        name: _lt("Date (9/26/2008)"),
        sequence: 40,
        action: FORMAT_DATE_ACTION,
    })
        .addChild("format_number_time", ["format", "format_number"], {
        name: _lt("Time (10:43:00 PM)"),
        sequence: 50,
        action: FORMAT_TIME_ACTION,
    })
        .addChild("format_number_date_time", ["format", "format_number"], {
        name: _lt("Date time (9/26/2008 22:43:00)"),
        sequence: 60,
        action: FORMAT_DATE_TIME_ACTION,
    })
        .addChild("format_number_duration", ["format", "format_number"], {
        name: _lt("Duration (27:51:38)"),
        sequence: 70,
        separator: true,
        action: FORMAT_DURATION_ACTION,
    })
        .addChild("format_bold", ["format"], {
        name: _lt("Bold"),
        sequence: 20,
        shortCut: "Ctrl+B",
        action: FORMAT_BOLD_ACTION,
    })
        .addChild("format_italic", ["format"], {
        name: _lt("Italic"),
        sequence: 30,
        shortCut: "Ctrl+I",
        action: FORMAT_ITALIC_ACTION,
    })
        .addChild("format_underline", ["format"], {
        name: _lt("Underline"),
        shortCut: "Ctrl+U",
        sequence: 40,
        action: FORMAT_UNDERLINE_ACTION,
    })
        .addChild("format_strikethrough", ["format"], {
        name: _lt("Strikethrough"),
        sequence: 50,
        action: FORMAT_STRIKETHROUGH_ACTION,
        separator: true,
    })
        .addChild("format_font_size", ["format"], {
        name: _lt("Font size"),
        sequence: 60,
        separator: true,
    })
        .addChild("format_cf", ["format"], {
        name: _lt("Conditional formatting"),
        sequence: 70,
        action: OPEN_CF_SIDEPANEL_ACTION,
        separator: true,
    });
    // Font-sizes
    for (let fs of fontSizes) {
        topbarMenuRegistry.addChild(`format_font_size_${fs.pt}`, ["format", "format_font_size"], {
            name: fs.pt.toString(),
            sequence: fs.pt,
            action: (env) => setStyle(env, { fontSize: fs.pt }),
        });
    }

    class OTRegistry extends Registry {
        /**
         * Add a transformation function to the registry. When the executed command
         * happened, all the commands in toTransforms should be transformed using the
         * transformation function given
         */
        addTransformation(executed, toTransforms, fn) {
            for (let toTransform of toTransforms) {
                if (!this.content[toTransform]) {
                    this.content[toTransform] = new Map();
                }
                this.content[toTransform].set(executed, fn);
            }
            return this;
        }
        /**
         * Get the transformation function to transform the command toTransform, after
         * that the executed command happened.
         */
        getTransformation(toTransform, executed) {
            return this.content[toTransform] && this.content[toTransform].get(executed);
        }
    }
    const otRegistry = new OTRegistry();

    const { Component: Component$r } = owl__namespace;
    const { css: css$s, xml: xml$u } = owl__namespace.tags;
    const COLORS = [
        [
            "#000000",
            "#434343",
            "#666666",
            "#999999",
            "#b7b7b7",
            "#cccccc",
            "#d9d9d9",
            "#efefef",
            "#f3f3f3",
            "#ffffff",
        ],
        [
            "#980000",
            "#ff0000",
            "#ff9900",
            "#ffff00",
            "#00ff00",
            "#00ffff",
            "#4a86e8",
            "#0000ff",
            "#9900ff",
            "#ff00ff",
        ],
        [
            "#e6b8af",
            "#f4cccc",
            "#fce5cd",
            "#fff2cc",
            "#d9ead3",
            "#d0e0e3",
            "#c9daf8",
            "#cfe2f3",
            "#d9d2e9",
            "#ead1dc",
        ],
        [
            "#dd7e6b",
            "#ea9999",
            "#f9cb9c",
            "#ffe599",
            "#b6d7a8",
            "#a2c4c9",
            "#a4c2f4",
            "#9fc5e8",
            "#b4a7d6",
            "#d5a6bd",
        ],
        [
            "#cc4125",
            "#e06666",
            "#f6b26b",
            "#ffd966",
            "#93c47d",
            "#76a5af",
            "#6d9eeb",
            "#6fa8dc",
            "#8e7cc3",
            "#c27ba0",
        ],
        [
            "#a61c00",
            "#cc0000",
            "#e69138",
            "#f1c232",
            "#6aa84f",
            "#45818e",
            "#3c78d8",
            "#3d85c6",
            "#674ea7",
            "#a64d79",
        ],
        [
            "#85200c",
            "#990000",
            "#b45f06",
            "#bf9000",
            "#38761d",
            "#134f5c",
            "#1155cc",
            "#0b5394",
            "#351c75",
            "#741b47",
        ],
        [
            "#5b0f00",
            "#660000",
            "#783f04",
            "#7f6000",
            "#274e13",
            "#0c343d",
            "#1c4587",
            "#073763",
            "#20124d",
            "#4c1130",
        ],
    ];
    const PICKER_VERTICAL_PADDING = 6;
    const LINE_VERTICAL_PADDING = 3;
    const LINE_HORIZONTAL_PADDING = 6;
    const ITEM_HORIZONTAL_MARGIN = 2;
    const ITEM_EDGE_LENGTH = 18;
    const ITEM_BORDER_WIDTH = 1;
    const ITEMS_PER_LINE = Math.max(...COLORS.map((line) => line.length));
    const PICKER_WIDTH = ITEMS_PER_LINE * (ITEM_EDGE_LENGTH + ITEM_HORIZONTAL_MARGIN * 2 + 2 * ITEM_BORDER_WIDTH) +
        2 * LINE_HORIZONTAL_PADDING;
    class ColorPicker extends Component$r {
        constructor() {
            super(...arguments);
            this.COLORS = COLORS;
        }
        onColorClick(ev) {
            const color = ev.target.dataset.color;
            if (color) {
                this.trigger("color-picked", { color });
            }
        }
    }
    ColorPicker.template = xml$u /* xml */ `
  <div class="o-color-picker"
    t-att-class="props.dropdownDirection || 'right'"
    t-on-click="onColorClick">
    <div class="o-color-picker-line" t-foreach="COLORS" t-as="colors" t-key="colors">
      <t t-foreach="colors" t-as="color" t-key="color">
        <div class="o-color-picker-line-item" t-att-data-color="color" t-attf-style="background-color:{{color}};"></div>
      </t>
    </div>
  </div>`;
    ColorPicker.style = css$s /* scss */ `
    .o-color-picker {
      position: absolute;
      top: calc(100% + 5px);
      z-index: 10;
      box-shadow: 1px 2px 5px 2px rgba(51, 51, 51, 0.15);
      background-color: white;
      padding: ${PICKER_VERTICAL_PADDING}px 0px;

      .o-color-picker-line {
        display: flex;
        padding: ${LINE_VERTICAL_PADDING}px ${LINE_HORIZONTAL_PADDING}px;
        .o-color-picker-line-item {
          width: ${ITEM_EDGE_LENGTH}px;
          height: ${ITEM_EDGE_LENGTH}px;
          margin: 0px ${ITEM_HORIZONTAL_MARGIN}px;
          border-radius: 50px;
          border: ${ITEM_BORDER_WIDTH}px solid #c0c0c0;
          &:hover {
            cursor: pointer;
            background-color: rgba(0, 0, 0, 0.08);
            outline: 1px solid gray;
          }
        }
      }

      &.right {
        left: 0;
      }

      &.left {
        right: 0;
      }
      &.center {
        left: calc(50% - ${PICKER_WIDTH / 2}px);
      }
    }
  `;

    // -----------------------------------------------------------------------------
    // -----------------------------------------------------------------------------
    const UNDO_ICON = `<svg class="o-icon"><path fill="#000000" d="M11.5656391,4.43436088 L9,7 L16,7 L16,0 L13.0418424,2.95815758 C11.5936787,1.73635959 9.72260775,1 7.67955083,1 C4.22126258,1 1.25575599,3.10984908 0,6 L2,7 C2.93658775,4.60974406 5.12943697,3.08011229 7.67955083,3 C9.14881247,3.0528747 10.4994783,3.57862053 11.5656391,4.43436088 Z" transform="matrix(-1 0 0 1 17 5)"/></svg>`;
    const REDO_ICON = `<svg class="o-icon"><path fill="#000000" d="M11.5656391,4.43436088 L9,7 L16,7 L16,0 L13.0418424,2.95815758 C11.5936787,1.73635959 9.72260775,1 7.67955083,1 C4.22126258,1 1.25575599,3.10984908 0,6 L2,7 C2.93658775,4.60974406 5.12943697,3.08011229 7.67955083,3 C9.14881247,3.0528747 10.4994783,3.57862053 11.5656391,4.43436088 Z" transform="translate(1 5)"/></svg>`;
    const PAINT_FORMAT_ICON = `<svg class="o-icon"><path fill="#000000" d="M9,0 L1,0 C0.45,0 0,0.45 0,1 L0,4 C0,4.55 0.45,5 1,5 L9,5 C9.55,5 10,4.55 10,4 L10,3 L11,3 L11,6 L4,6 L4,14 L6,14 L6,8 L13,8 L13,2 L10,2 L10,1 C10,0.45 9.55,0 9,0 Z" transform="translate(3 2)"/></svg>`;
    const CLEAR_FORMAT_ICON = `<svg class="o-icon"><path fill="#000000" d="M0.27,1.55 L5.43,6.7 L3,12 L5.5,12 L7.14,8.42 L11.73,13 L13,11.73 L1.55,0.27 L0.27,1.55 L0.27,1.55 Z M3.82,0 L5.82,2 L7.58,2 L7.03,3.21 L8.74,4.92 L10.08,2 L14,2 L14,0 L3.82,0 L3.82,0 Z" transform="translate(2 3)"/></svg>`;
    const TRIANGLE_DOWN_ICON = `<svg class="o-icon"><polygon fill="#000000" points="0 0 4 4 8 0" transform="translate(5 7)"/></svg>`;
    const TRIANGLE_UP_ICON = `<svg class="o-icon"><polygon fill="#000000" points="4 0 0 4 8 4" transform="translate(5 7)"/></svg>`;
    const TRIANGLE_RIGHT_ICON = `<svg class="o-icon"><polygon fill="#000000" points="0 0 4 4 0 8" transform="translate(5 5)"/></svg>`;
    const TRIANGLE_LEFT_ICON = `<svg class="o-icon"><polygon fill="#000000" points="4 0 0 4 4 8" transform="translate(5 5)"/></svg>`;
    const BOLD_ICON = `<svg class="o-icon"><path fill="#000000" fill-rule="evenodd" d="M9,3.5 C9,1.57 7.43,0 5.5,0 L1.77635684e-15,0 L1.77635684e-15,12 L6.25,12 C8.04,12 9.5,10.54 9.5,8.75 C9.5,7.45 8.73,6.34 7.63,5.82 C8.46,5.24 9,4.38 9,3.5 Z M5,2 C5.82999992,2 6.5,2.67 6.5,3.5 C6.5,4.33 5.82999992,5 5,5 L3,5 L3,2 L5,2 Z M3,10 L3,7 L5.5,7 C6.32999992,7 7,7.67 7,8.5 C7,9.33 6.32999992,10 5.5,10 L3,10 Z" transform="translate(4 3)"/></svg>`;
    const ITALIC_ICON = `<svg class="o-icon"><polygon fill="#000000" fill-rule="evenodd" points="4 0 4 2 6.58 2 2.92 10 0 10 0 12 8 12 8 10 5.42 10 9.08 2 12 2 12 0" transform="translate(3 3)"/></svg>`;
    const UNDERLINE_ICON = `<svg class="o-icon"><path fill="#000000" d="M6,12 C8.76,12 11,9.76 11,7 L11,0 L9,0 L9,7 C9,8.75029916 7.49912807,10 6,10 C4.50087193,10 3,8.75837486 3,7 L3,0 L1,0 L1,7 C1,9.76 3.24,12 6,12 Z M0,13 L0,15 L12,15 L12,13 L0,13 Z" transform="translate(3 3)"/></svg>`;
    const STRIKE_ICON = `<svg class="o-icon"><path fill="#010101" fill-rule="evenodd" d="M2.8875,3.06 C2.8875,2.6025 2.985,2.18625 3.18375,1.8075 C3.3825,1.42875 3.66,1.10625 4.02,0.84 C4.38,0.57375 4.80375,0.3675 5.29875,0.22125 C5.79375,0.075 6.33375,0 6.92625,0 C7.53375,0 8.085,0.0825 8.58,0.25125 C9.075,0.42 9.49875,0.6525 9.85125,0.95625 C10.20375,1.25625 10.47375,1.6125 10.665,2.02875 C10.85625,2.44125 10.95,2.895 10.95,3.38625 L8.6925,3.38625 C8.6925,3.1575 8.655,2.94375 8.58375,2.74875 C8.5125,2.55 8.4,2.38125 8.25,2.2425 C8.1,2.10375 7.9125,1.99125 7.6875,1.91625 C7.4625,1.8375 7.19625,1.8 6.88875,1.8 C6.5925,1.8 6.3375,1.83375 6.11625,1.8975 C5.89875,1.96125 5.71875,2.05125 5.57625,2.1675 C5.43375,2.28375 5.325,2.41875 5.25375,2.5725 C5.1825,2.72625 5.145,2.895 5.145,3.0675 C5.145,3.4275 5.32875,3.73125 5.69625,3.975 C5.71780203,3.98908066 5.73942012,4.00311728 5.76118357,4.01733315 C6.02342923,4.18863185 6.5,4.5 7,5 L4,5 C4,5 3.21375,4.37625 3.17625,4.30875 C2.985,3.9525 2.8875,3.53625 2.8875,3.06 Z M14,6 L0,6 L0,8 L7.21875,8 C7.35375,8.0525 7.51875,8.105 7.63125,8.15375 C7.90875,8.2775 8.12625,8.40875 8.28375,8.53625 C8.44125,8.6675 8.54625,8.81 8.6025,8.96 C8.65875,9.11375 8.685,9.28625 8.685,9.47375 C8.685,9.65 8.65125,9.815 8.58375,9.965 C8.51625,10.11875 8.41125,10.25 8.2725,10.35875 C8.13375,10.4675 7.95375,10.55375 7.74,10.6175 C7.5225,10.68125 7.27125,10.71125 6.97875,10.71125 C6.6525,10.71125 6.35625,10.6775 6.09,10.61375 C5.82375,10.55 5.59875,10.445 5.41125,10.3025 C5.22375,10.16 5.0775,9.9725 4.9725,9.74375 C4.8675,9.515 4.78125,9.17 4.78125,9 L2.55,9 C2.55,9.2525 2.61,9.6875 2.72625,10.025 C2.8425,10.3625 3.0075,10.66625 3.21375,10.9325 C3.42,11.19875 3.6675,11.4275 3.94875,11.6225 C4.23,11.8175 4.53375,11.9825 4.86375,12.11 C5.19375,12.24125 5.535,12.33875 5.89875,12.39875 C6.25875,12.4625 6.6225,12.4925 6.9825,12.4925 C7.5825,12.4925 8.13,12.425 8.6175,12.28625 C9.105,12.1475 9.525,11.94875 9.87,11.69375 C10.215,11.435 10.48125,11.12 10.6725,10.74125 C10.86375,10.3625 10.95375,9.935 10.95375,9.455 C10.95375,9.005 10.875,8.6 10.72125,8.24375 C10.68375,8.1575 10.6425,8.075 10.59375,7.9925 L14,8 L14,6 Z" transform="translate(2 3)"/></svg>`;
    const TEXT_COLOR_ICON = `<svg class="o-icon"><path fill="#000000" d="M7,0 L5,0 L0.5,12 L2.5,12 L3.62,9 L8.37,9 L9.49,12 L11.49,12 L7,0 L7,0 Z M4.38,7 L6,2.67 L7.62,7 L4.38,7 L4.38,7 Z" transform="translate(3 1)"/></svg>`;
    const FILL_COLOR_ICON = `<svg class="o-icon"><path fill="#000000" d="M14.5,8.87 C14.5,8.87 13,10.49 13,11.49 C13,12.32 13.67,12.99 14.5,12.99 C15.33,12.99 16,12.32 16,11.49 C16,10.5 14.5,8.87 14.5,8.87 L14.5,8.87 Z M12.71,6.79 L5.91,0 L4.85,1.06 L6.44,2.65 L2.29,6.79 C1.9,7.18 1.9,7.81 2.29,8.2 L6.79,12.7 C6.99,12.9 7.24,13 7.5,13 C7.76,13 8.01,12.9 8.21,12.71 L12.71,8.21 C13.1,7.82 13.1,7.18 12.71,6.79 L12.71,6.79 Z M4.21,7 L7.5,3.71 L10.79,7 L4.21,7 L4.21,7 Z"/></svg>`;
    const MERGE_CELL_ICON = `<svg class="o-icon"><path fill="#000000" d="M3,6 L1,6 L1,2 L8,2 L8,4 L3,4 L3,6 Z M10,4 L10,2 L17,2 L17,6 L15,6 L15,4 L10,4 Z M10,14 L15,14 L15,12 L17,12 L17,16 L10,16 L10,14 Z M1,12 L3,12 L3,14 L8,14 L8,16 L1,16 L1,12 Z M1,8 L5,8 L5,6 L8,9 L5,12 L5,10 L1,10 L1,8 Z M10,9 L13,6 L13,8 L17,8 L17,10 L13,10 L13,12 L10,9 Z"/></svg>`;
    const ALIGN_LEFT_ICON = `<svg class="o-icon"><path fill="#000000" d="M0,14 L10,14 L10,12 L0,12 L0,14 Z M10,4 L0,4 L0,6 L10,6 L10,4 Z M0,0 L0,2 L14,2 L14,0 L0,0 Z M0,10 L14,10 L14,8 L0,8 L0,10 Z" transform="translate(2 2)"/></svg>`;
    const ALIGN_CENTER_ICON = `<svg class="o-icon"><path fill="#000000" d="M2,12 L2,14 L12,14 L12,12 L2,12 Z M2,4 L2,6 L12,6 L12,4 L2,4 Z M0,10 L14,10 L14,8 L0,8 L0,10 Z M0,0 L0,2 L14,2 L14,0 L0,0 Z" transform="translate(2 2)"/></svg>`;
    const ALIGN_RIGHT_ICON = `<svg class="o-icon"><path fill="#000000" d="M4,14 L14,14 L14,12 L4,12 L4,14 Z M0,10 L14,10 L14,8 L0,8 L0,10 Z M0,0 L0,2 L14,2 L14,0 L0,0 Z M4,6 L14,6 L14,4 L4,4 L4,6 Z" transform="translate(2 2)"/></svg>`;
    // export const ALIGN_TOP_ICON = `<svg class="o-icon"><path fill="#000000" d="M0,0 L0,2 L12,2 L12,0 L0,0 L0,0 Z M2.5,7 L5,7 L5,14 L7,14 L7,7 L9.5,7 L6,3.5 L2.5,7 L2.5,7 Z" transform="translate(3 2)"/></svg>`;
    const ALIGN_MIDDLE_ICON = `<svg class="o-icon"><path fill="#000000" d="M9.5,3 L7,3 L7,0 L5,0 L5,3 L2.5,3 L6,6.5 L9.5,3 L9.5,3 Z M0,8 L0,10 L12,10 L12,8 L0,8 L0,8 Z M2.5,15 L5,15 L5,18 L7,18 L7,15 L9.5,15 L6,11.5 L2.5,15 L2.5,15 Z" transform="translate(3)"/></svg>`;
    // export const ALIGN_BOTTOM_ICON = `<svg class="o-icon"><path fill="#000000" d="M9.5,7 L7,7 L7,0 L5,0 L5,7 L2.5,7 L6,10.5 L9.5,7 L9.5,7 Z M0,12 L0,14 L12,14 L12,12 L0,12 L0,12 Z" transform="translate(3 2)"/></svg>`;
    const TEXT_WRAPPING_ICON = `<svg class="o-icon"><path fill="#000000" d="M14,0 L0,0 L0,2 L14,2 L14,0 Z M0,12 L4,12 L4,10 L0,10 L0,12 Z M11.5,5 L0,5 L0,7 L11.75,7 C12.58,7 13.25,7.67 13.25,8.5 C13.25,9.33 12.58,10 11.75,10 L9,10 L9,8 L6,11 L9,14 L9,12 L11.5,12 C13.43,12 15,10.43 15,8.5 C15,6.57 13.43,5 11.5,5 Z" transform="translate(2 3)"/></svg>`;
    const BORDERS_ICON = `<svg class="o-icon"><path fill="#000000" d="M0,0 L0,14 L14,14 L14,0 L0,0 L0,0 Z M6,12 L2,12 L2,8 L6,8 L6,12 L6,12 Z M6,6 L2,6 L2,2 L6,2 L6,6 L6,6 Z M12,12 L8,12 L8,8 L12,8 L12,12 L12,12 Z M12,6 L8,6 L8,2 L12,2 L12,6 L12,6 Z" transform="translate(2 2)"/></svg>`;
    const BORDER_HV = `<svg class="o-icon"><g fill="#000000"><path d="M0,14 L2,14 L2,12 L0,12 L0,14 L0,14 Z M2,3 L0,3 L0,5 L2,5 L2,3 L2,3 Z M3,14 L5,14 L5,12 L3,12 L3,14 L3,14 Z M11,0 L9,0 L9,2 L11,2 L11,0 L11,0 Z M2,0 L0,0 L0,2 L2,2 L2,0 L2,0 Z M5,0 L3,0 L3,2 L5,2 L5,0 L5,0 Z M0,11 L2,11 L2,9 L0,9 L0,11 L0,11 Z M9,14 L11,14 L11,12 L9,12 L9,14 L9,14 Z M12,0 L12,2 L14,2 L14,0 L12,0 L12,0 Z M12,5 L14,5 L14,3 L12,3 L12,5 L12,5 Z M12,14 L14,14 L14,12 L12,12 L12,14 L12,14 Z M12,11 L14,11 L14,9 L12,9 L12,11 L12,11 Z" opacity=".54"/><polygon points="8 0 6 0 6 6 0 6 0 8 6 8 6 14 8 14 8 8 14 8 14 6 8 6"/></g></svg>`;
    const BORDER_H = `<svg class="o-icon"><g fill="#000000"><path d="M6,14 L8,14 L8,12 L6,12 L6,14 L6,14 Z M3,2 L5,2 L5,0 L3,0 L3,2 L3,2 Z M6,11 L8,11 L8,9 L6,9 L6,11 L6,11 Z M3,14 L5,14 L5,12 L3,12 L3,14 L3,14 Z M0,5 L2,5 L2,3 L0,3 L0,5 L0,5 Z M0,14 L2,14 L2,12 L0,12 L0,14 L0,14 Z M0,2 L2,2 L2,0 L0,0 L0,2 L0,2 Z M0,11 L2,11 L2,9 L0,9 L0,11 L0,11 Z M12,11 L14,11 L14,9 L12,9 L12,11 L12,11 Z M12,14 L14,14 L14,12 L12,12 L12,14 L12,14 Z M12,5 L14,5 L14,3 L12,3 L12,5 L12,5 Z M12,0 L12,2 L14,2 L14,0 L12,0 L12,0 Z M6,2 L8,2 L8,0 L6,0 L6,2 L6,2 Z M9,2 L11,2 L11,0 L9,0 L9,2 L9,2 Z M6,5 L8,5 L8,3 L6,3 L6,5 L6,5 Z M9,14 L11,14 L11,12 L9,12 L9,14 L9,14 Z" opacity=".54"/><polygon points="0 8 14 8 14 6 0 6"/></g></svg>`;
    const BORDER_V = `<svg class="o-icon"><g fill="#000000"><path d="M3,14 L5,14 L5,12 L3,12 L3,14 L3,14 Z M0,5 L2,5 L2,3 L0,3 L0,5 L0,5 Z M0,2 L2,2 L2,0 L0,0 L0,2 L0,2 Z M3,8 L5,8 L5,6 L3,6 L3,8 L3,8 Z M3,2 L5,2 L5,0 L3,0 L3,2 L3,2 Z M0,14 L2,14 L2,12 L0,12 L0,14 L0,14 Z M0,8 L2,8 L2,6 L0,6 L0,8 L0,8 Z M0,11 L2,11 L2,9 L0,9 L0,11 L0,11 Z M12,0 L12,2 L14,2 L14,0 L12,0 L12,0 Z M12,8 L14,8 L14,6 L12,6 L12,8 L12,8 Z M12,14 L14,14 L14,12 L12,12 L12,14 L12,14 Z M12,5 L14,5 L14,3 L12,3 L12,5 L12,5 Z M12,11 L14,11 L14,9 L12,9 L12,11 L12,11 Z M9,14 L11,14 L11,12 L9,12 L9,14 L9,14 Z M9,8 L11,8 L11,6 L9,6 L9,8 L9,8 Z M9,2 L11,2 L11,0 L9,0 L9,2 L9,2 Z" opacity=".54"/><polygon points="6 14 8 14 8 0 6 0"/></g></svg>`;
    const BORDER_EXTERNAL = `<svg class="o-icon"><g fill="#000000"><path d="M8,3 L6,3 L6,5 L8,5 L8,3 L8,3 Z M11,6 L9,6 L9,8 L11,8 L11,6 L11,6 Z M8,6 L6,6 L6,8 L8,8 L8,6 L8,6 Z M8,9 L6,9 L6,11 L8,11 L8,9 L8,9 Z M5,6 L3,6 L3,8 L5,8 L5,6 L5,6 Z" opacity=".54"/><path d="M0,0 L14,0 L14,14 L0,14 L0,0 Z M12,12 L12,2 L2,2 L2,12 L12,12 Z"/></g></svg>`;
    const BORDER_LEFT = `<svg class="o-icon"><g fill="#000000"><path d="M6,8 L8,8 L8,6 L6,6 L6,8 L6,8 Z M6,5 L8,5 L8,3 L6,3 L6,5 L6,5 Z M6,11 L8,11 L8,9 L6,9 L6,11 L6,11 Z M6,14 L8,14 L8,12 L6,12 L6,14 L6,14 Z M3,14 L5,14 L5,12 L3,12 L3,14 L3,14 Z M3,2 L5,2 L5,0 L3,0 L3,2 L3,2 Z M3,8 L5,8 L5,6 L3,6 L3,8 L3,8 Z M12,14 L14,14 L14,12 L12,12 L12,14 L12,14 Z M12,8 L14,8 L14,6 L12,6 L12,8 L12,8 Z M12,11 L14,11 L14,9 L12,9 L12,11 L12,11 Z M12,5 L14,5 L14,3 L12,3 L12,5 L12,5 Z M6,2 L8,2 L8,0 L6,0 L6,2 L6,2 Z M12,0 L12,2 L14,2 L14,0 L12,0 L12,0 Z M9,14 L11,14 L11,12 L9,12 L9,14 L9,14 Z M9,8 L11,8 L11,6 L9,6 L9,8 L9,8 Z M9,2 L11,2 L11,0 L9,0 L9,2 L9,2 Z" opacity=".54"/><polygon points="0 14 2 14 2 0 0 0"/></g></svg>`;
    const BORDER_TOP = `<svg class="o-icon"><g fill="#000000"><path d="M3,8 L5,8 L5,6 L3,6 L3,8 L3,8 Z M0,14 L2,14 L2,12 L0,12 L0,14 L0,14 Z M6,14 L8,14 L8,12 L6,12 L6,14 L6,14 Z M6,11 L8,11 L8,9 L6,9 L6,11 L6,11 Z M3,14 L5,14 L5,12 L3,12 L3,14 L3,14 Z M0,11 L2,11 L2,9 L0,9 L0,11 L0,11 Z M6,8 L8,8 L8,6 L6,6 L6,8 L6,8 Z M0,5 L2,5 L2,3 L0,3 L0,5 L0,5 Z M0,8 L2,8 L2,6 L0,6 L0,8 L0,8 Z M12,8 L14,8 L14,6 L12,6 L12,8 L12,8 Z M12,11 L14,11 L14,9 L12,9 L12,11 L12,11 Z M12,5 L14,5 L14,3 L12,3 L12,5 L12,5 Z M6,5 L8,5 L8,3 L6,3 L6,5 L6,5 Z M9,14 L11,14 L11,12 L9,12 L9,14 L9,14 Z M9,8 L11,8 L11,6 L9,6 L9,8 L9,8 Z M12,14 L14,14 L14,12 L12,12 L12,14 L12,14 Z" opacity=".54"/><polygon points="0 0 0 2 14 2 14 0"/></g></svg>`;
    const BORDER_RIGHT = `<svg class="o-icon"><g fill="#000000"><path d="M0,2 L2,2 L2,0 L0,0 L0,2 L0,2 Z M3,2 L5,2 L5,0 L3,0 L3,2 L3,2 Z M3,8 L5,8 L5,6 L3,6 L3,8 L3,8 Z M3,14 L5,14 L5,12 L3,12 L3,14 L3,14 Z M0,5 L2,5 L2,3 L0,3 L0,5 L0,5 Z M0,8 L2,8 L2,6 L0,6 L0,8 L0,8 Z M0,14 L2,14 L2,12 L0,12 L0,14 L0,14 Z M0,11 L2,11 L2,9 L0,9 L0,11 L0,11 Z M9,8 L11,8 L11,6 L9,6 L9,8 L9,8 Z M6,14 L8,14 L8,12 L6,12 L6,14 L6,14 Z M9,14 L11,14 L11,12 L9,12 L9,14 L9,14 Z M6,2 L8,2 L8,0 L6,0 L6,2 L6,2 Z M9,2 L11,2 L11,0 L9,0 L9,2 L9,2 Z M6,11 L8,11 L8,9 L6,9 L6,11 L6,11 Z M6,5 L8,5 L8,3 L6,3 L6,5 L6,5 Z M6,8 L8,8 L8,6 L6,6 L6,8 L6,8 Z" opacity=".54"/><polygon points="12 0 12 14 14 14 14 0"/></g></svg>`;
    const BORDER_BOTTOM = `<svg class="o-icon"><g fill="#000000"><path d="M5,0 L3,0 L3,2 L5,2 L5,0 L5,0 Z M8,6 L6,6 L6,8 L8,8 L8,6 L8,6 Z M8,9 L6,9 L6,11 L8,11 L8,9 L8,9 Z M11,6 L9,6 L9,8 L11,8 L11,6 L11,6 Z M5,6 L3,6 L3,8 L5,8 L5,6 L5,6 Z M11,0 L9,0 L9,2 L11,2 L11,0 L11,0 Z M8,3 L6,3 L6,5 L8,5 L8,3 L8,3 Z M8,0 L6,0 L6,2 L8,2 L8,0 L8,0 Z M2,9 L0,9 L0,11 L2,11 L2,9 L2,9 Z M12,11 L14,11 L14,9 L12,9 L12,11 L12,11 Z M12,5 L14,5 L14,3 L12,3 L12,5 L12,5 Z M12,8 L14,8 L14,6 L12,6 L12,8 L12,8 Z M12,0 L12,2 L14,2 L14,0 L12,0 L12,0 Z M2,0 L0,0 L0,2 L2,2 L2,0 L2,0 Z M2,3 L0,3 L0,5 L2,5 L2,3 L2,3 Z M2,6 L0,6 L0,8 L2,8 L2,6 L2,6 Z" opacity=".54"/><polygon points="0 14 14 14 14 12 0 12"/></g></svg>`;
    const BORDER_CLEAR = `<svg class="o-icon"><path fill="#000000" fill-rule="evenodd" d="M6,14 L8,14 L8,12 L6,12 L6,14 L6,14 Z M3,8 L5,8 L5,6 L3,6 L3,8 L3,8 Z M3,2 L5,2 L5,0 L3,0 L3,2 L3,2 Z M6,11 L8,11 L8,9 L6,9 L6,11 L6,11 Z M3,14 L5,14 L5,12 L3,12 L3,14 L3,14 Z M0,5 L2,5 L2,3 L0,3 L0,5 L0,5 Z M0,14 L2,14 L2,12 L0,12 L0,14 L0,14 Z M0,2 L2,2 L2,0 L0,0 L0,2 L0,2 Z M0,8 L2,8 L2,6 L0,6 L0,8 L0,8 Z M6,8 L8,8 L8,6 L6,6 L6,8 L6,8 Z M0,11 L2,11 L2,9 L0,9 L0,11 L0,11 Z M12,11 L14,11 L14,9 L12,9 L12,11 L12,11 Z M12,14 L14,14 L14,12 L12,12 L12,14 L12,14 Z M12,8 L14,8 L14,6 L12,6 L12,8 L12,8 Z M12,5 L14,5 L14,3 L12,3 L12,5 L12,5 Z M12,0 L12,2 L14,2 L14,0 L12,0 L12,0 Z M6,2 L8,2 L8,0 L6,0 L6,2 L6,2 Z M9,2 L11,2 L11,0 L9,0 L9,2 L9,2 Z M6,5 L8,5 L8,3 L6,3 L6,5 L6,5 Z M9,14 L11,14 L11,12 L9,12 L9,14 L9,14 Z M9,8 L11,8 L11,6 L9,6 L9,8 L9,8 Z" transform="translate(2 2)" opacity=".54"/></svg>`;
    const PLUS = `<svg class="o-icon"><path fill="#000000" d="M8,0 L10,0 L10,8 L18,8 L18,10 L10,10 L10,18 L8,18 L8,10 L0,10 L0,8 L8,8"/></svg>`;
    const LIST = `<svg class="o-icon" viewBox="0 0 384 384"><rect x="0" y="277.333" width="384" height="42.667"/><rect x="0" y="170.667" width="384" height="42.667"/><rect x="0" y="64" width="384" height="42.667"/></svg>`;
    const EDIT = `<svg class="o-icon" viewBox="0 0 576 512"><path fill="currentColor" d="M402.6 83.2l90.2 90.2c3.8 3.8 3.8 10 0 13.8L274.4 405.6l-92.8 10.3c-12.4 1.4-22.9-9.1-21.5-21.5l10.3-92.8L388.8 83.2c3.8-3.8 10-3.8 13.8 0zm162-22.9l-48.8-48.8c-15.2-15.2-39.9-15.2-55.2 0l-35.4 35.4c-3.8 3.8-3.8 10 0 13.8l90.2 90.2c3.8 3.8 10 3.8 13.8 0l35.4-35.4c15.2-15.3 15.2-40 0-55.2zM384 346.2V448H64V128h229.8c3.2 0 6.2-1.3 8.5-3.5l40-40c7.6-7.6 2.2-20.5-8.5-20.5H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V306.2c0-10.7-12.9-16-20.5-8.5l-40 40c-2.2 2.3-3.5 5.3-3.5 8.5z"></path></svg>`;
    const UNLINK = `<svg class="o-icon" viewBox="0 0 512 512"><path fill="currentColor" d="M304.083 405.907c4.686 4.686 4.686 12.284 0 16.971l-44.674 44.674c-59.263 59.262-155.693 59.266-214.961 0-59.264-59.265-59.264-155.696 0-214.96l44.675-44.675c4.686-4.686 12.284-4.686 16.971 0l39.598 39.598c4.686 4.686 4.686 12.284 0 16.971l-44.675 44.674c-28.072 28.073-28.072 73.75 0 101.823 28.072 28.072 73.75 28.073 101.824 0l44.674-44.674c4.686-4.686 12.284-4.686 16.971 0l39.597 39.598zm-56.568-260.216c4.686 4.686 12.284 4.686 16.971 0l44.674-44.674c28.072-28.075 73.75-28.073 101.824 0 28.072 28.073 28.072 73.75 0 101.823l-44.675 44.674c-4.686 4.686-4.686 12.284 0 16.971l39.598 39.598c4.686 4.686 12.284 4.686 16.971 0l44.675-44.675c59.265-59.265 59.265-155.695 0-214.96-59.266-59.264-155.695-59.264-214.961 0l-44.674 44.674c-4.686 4.686-4.686 12.284 0 16.971l39.597 39.598zm234.828 359.28l22.627-22.627c9.373-9.373 9.373-24.569 0-33.941L63.598 7.029c-9.373-9.373-24.569-9.373-33.941 0L7.029 29.657c-9.373 9.373-9.373 24.569 0 33.941l441.373 441.373c9.373 9.372 24.569 9.372 33.941 0z"></path></svg>`;
    /** Font Awesome by Dave Gandy
     *  http://fontawesome.io/
     *  https://fontawesome.com/license
     */
    const TRASH = '<svg xmlns ="http://www.w3.org/2000/svg" class="o-cf-icon trash" viewBox = "0 0 448 512" > <path fill="currentColor" d = "M432 32H312l-9.4-18.7A24 24 0 0 0 281.1 0H166.8a23.72 23.72 0 0 0-21.4 13.3L136 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zM53.2 467a48 48 0 0 0 47.9 45h245.8a48 48 0 0 0 47.9-45L416 128H32z" > </path></svg >';
    const REFRESH = '<svg xmlns="http://www.w3.org/2000/svg" class="o-cf-icon refresh" viewBox="0 0 512 512"><path fill="currentColor" d="M440.65 12.57l4 82.77A247.16 247.16 0 0 0 255.83 8C134.73 8 33.91 94.92 12.29 209.82A12 12 0 0 0 24.09 224h49.05a12 12 0 0 0 11.67-9.26 175.91 175.91 0 0 1 317-56.94l-101.46-4.86a12 12 0 0 0-12.57 12v47.41a12 12 0 0 0 12 12H500a12 12 0 0 0 12-12V12a12 12 0 0 0-12-12h-47.37a12 12 0 0 0-11.98 12.57zM255.83 432a175.61 175.61 0 0 1-146-77.8l101.8 4.87a12 12 0 0 0 12.57-12v-47.4a12 12 0 0 0-12-12H12a12 12 0 0 0-12 12V500a12 12 0 0 0 12 12h47.35a12 12 0 0 0 12-12.6l-4.15-82.57A247.17 247.17 0 0 0 255.83 504c121.11 0 221.93-86.92 243.55-201.82a12 12 0 0 0-11.8-14.18h-49.05a12 12 0 0 0-11.67 9.26A175.86 175.86 0 0 1 255.83 432z"></path></svg>';
    const ARROW_DOWN = '<svg xmlns="http://www.w3.org/2000/svg" class="o-cf-icon arrow-down" width="10" height="10" focusable="false" viewBox="0 0 448 512"><path fill="#DC6965" d="M413.1 222.5l22.2 22.2c9.4 9.4 9.4 24.6 0 33.9L241 473c-9.4 9.4-24.6 9.4-33.9 0L12.7 278.6c-9.4-9.4-9.4-24.6 0-33.9l22.2-22.2c9.5-9.5 25-9.3 34.3.4L184 343.4V56c0-13.3 10.7-24 24-24h32c13.3 0 24 10.7 24 24v287.4l114.8-120.5c9.3-9.8 24.8-10 34.3-.4z"></path></svg>';
    const ARROW_UP = '<svg xmlns="http://www.w3.org/2000/svg" class="o-cf-icon arrow-up" width="10" height="10" focusable="false" viewBox="0 0 448 512"><path fill="#00A04A" d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"></path></svg>';
    const ARROW_RIGHT = '<svg xmlns="http://www.w3.org/2000/svg" class="o-cf-icon arrow-right" width="10" height="10" focusable="false" viewBox="0 0 448 512"><path fill="#F0AD4E" d="M190.5 66.9l22.2-22.2c9.4-9.4 24.6-9.4 33.9 0L441 239c9.4 9.4 9.4 24.6 0 33.9L246.6 467.3c-9.4 9.4-24.6 9.4-33.9 0l-22.2-22.2c-9.5-9.5-9.3-25 .4-34.3L311.4 296H24c-13.3 0-24-10.7-24-24v-32c0-13.3 10.7-24 24-24h287.4L190.9 101.2c-9.8-9.3-10-24.8-.4-34.3z"></path></svg>';
    const SMILE = '<svg xmlns="http://www.w3.org/2000/svg" class="o-cf-icon smile" width="10" height="10" focusable="false" viewBox="0 0 496 512"><path fill="#00A04A" d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 448c-110.3 0-200-89.7-200-200S137.7 56 248 56s200 89.7 200 200-89.7 200-200 200zm-80-216c17.7 0 32-14.3 32-32s-14.3-32-32-32-32 14.3-32 32 14.3 32 32 32zm160 0c17.7 0 32-14.3 32-32s-14.3-32-32-32-32 14.3-32 32 14.3 32 32 32zm4 72.6c-20.8 25-51.5 39.4-84 39.4s-63.2-14.3-84-39.4c-8.5-10.2-23.7-11.5-33.8-3.1-10.2 8.5-11.5 23.6-3.1 33.8 30 36 74.1 56.6 120.9 56.6s90.9-20.6 120.9-56.6c8.5-10.2 7.1-25.3-3.1-33.8-10.1-8.4-25.3-7.1-33.8 3.1z"></path></svg>';
    const MEH = '<svg xmlns="http://www.w3.org/2000/svg" class="o-cf-icon meh" width="10" height="10" focusable="false" viewBox="0 0 496 512"><path fill="#F0AD4E" d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 448c-110.3 0-200-89.7-200-200S137.7 56 248 56s200 89.7 200 200-89.7 200-200 200zm-80-216c17.7 0 32-14.3 32-32s-14.3-32-32-32-32 14.3-32 32 14.3 32 32 32zm160-64c-17.7 0-32 14.3-32 32s14.3 32 32 32 32-14.3 32-32-14.3-32-32-32zm8 144H160c-13.2 0-24 10.8-24 24s10.8 24 24 24h176c13.2 0 24-10.8 24-24s-10.8-24-24-24z"></path></svg>';
    const FROWN = '<svg xmlns="http://www.w3.org/2000/svg" class="o-cf-icon frown" width="10" height="10" focusable="false" viewBox="0 0 496 512"><path fill="#DC6965" d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 448c-110.3 0-200-89.7-200-200S137.7 56 248 56s200 89.7 200 200-89.7 200-200 200zm-80-216c17.7 0 32-14.3 32-32s-14.3-32-32-32-32 14.3-32 32 14.3 32 32 32zm160-64c-17.7 0-32 14.3-32 32s14.3 32 32 32 32-14.3 32-32-14.3-32-32-32zm-80 128c-40.2 0-78 17.7-103.8 48.6-8.5 10.2-7.1 25.3 3.1 33.8 10.2 8.4 25.3 7.1 33.8-3.1 16.6-19.9 41-31.4 66.9-31.4s50.3 11.4 66.9 31.4c8.1 9.7 23.1 11.9 33.8 3.1 10.2-8.5 11.5-23.6 3.1-33.8C326 321.7 288.2 304 248 304z"></path></svg>';
    const GREEN_DOT = '<svg xmlns="http://www.w3.org/2000/svg" class="o-cf-icon green-dot" width="10" height="10" focusable="false" viewBox="0 0 512 512"><path fill="#00A04A" d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8z"></path></svg>';
    const YELLOW_DOT = '<svg xmlns="http://www.w3.org/2000/svg" class="o-cf-icon yellow-dot" width="10" height="10" focusable="false" viewBox="0 0 512 512"><path fill="#F0AD4E" d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8z"></path></svg>';
    const RED_DOT = '<svg xmlns="http://www.w3.org/2000/svg" class="o-cf-icon red-dot" width="10" height="10" focusable="false" viewBox="0 0 512 512"><path fill="#DC6965" d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8z"></path></svg>';
    function loadIconImage(svg) {
        const image = new Image();
        image.src = "data:image/svg+xml; charset=utf8, " + encodeURIComponent(svg);
        return image;
    }
    const ICONS = {
        arrowGood: {
            img: loadIconImage(ARROW_UP),
            svg: ARROW_UP,
        },
        arrowNeutral: {
            img: loadIconImage(ARROW_RIGHT),
            svg: ARROW_RIGHT,
        },
        arrowBad: {
            img: loadIconImage(ARROW_DOWN),
            svg: ARROW_DOWN,
        },
        smileyGood: {
            img: loadIconImage(SMILE),
            svg: SMILE,
        },
        smileyNeutral: {
            img: loadIconImage(MEH),
            svg: MEH,
        },
        smileyBad: {
            img: loadIconImage(FROWN),
            svg: FROWN,
        },
        dotGood: {
            img: loadIconImage(GREEN_DOT),
            svg: GREEN_DOT,
        },
        dotNeutral: {
            img: loadIconImage(YELLOW_DOT),
            svg: YELLOW_DOT,
        },
        dotBad: {
            img: loadIconImage(RED_DOT),
            svg: RED_DOT,
        },
    };
    const ICON_SETS = {
        arrows: {
            good: "arrowGood",
            neutral: "arrowNeutral",
            bad: "arrowBad",
        },
        smiley: {
            good: "smileyGood",
            neutral: "smileyNeutral",
            bad: "smileyBad",
        },
        dots: {
            good: "dotGood",
            neutral: "dotNeutral",
            bad: "dotBad",
        },
    };

    const { Component: Component$q, useState: useState$l } = owl__namespace;
    const { xml: xml$t, css: css$r } = owl__namespace.tags;
    const uuidGenerator$1 = new UuidGenerator();
    const TEMPLATE$q = xml$t /* xml */ `
  <div class="o-selection">
    <div t-foreach="ranges" t-as="range" t-key="range.id" class="o-selection-input">
      <input
        type="text"
        spellcheck="false"
        t-on-change="onInputChanged(range.id)"
        t-on-focus="focus(range.id)"
        t-att-value="range.xc"
        t-att-style="getColor(range)"
        t-att-class="{
          'o-focused' : range.isFocused,
          'o-required': props.required,
          'o-invalid': isInvalid || !range.isValidRange,
        }"
      />
      <button
        class="o-btn o-remove-selection"
        t-if="ranges.length > 1"
        t-on-click="removeInput(range.id)">✖</button>
    </div>

    <div class="o-selection-input">
    </div>

    <div class="o-selection-input">
      <button
        class="o-btn-action o-add-selection"
        t-if="canAddRange"
        t-on-click="addEmptyInput">Add range</button>
      <button
          class="o-btn-action o-selection-ok"
          t-if="hasFocus"
          t-on-click="disable">Confirm</button>
    </div>

  </div>`;
    const CSS$n = css$r /* scss */ `
  .o-selection {
    .o-selection-input {
      display: flex;
      flex-direction: row;

      input {
        padding: 4px 6px;
        border-radius: 4px;
        box-sizing: border-box;
        border: 1px solid #dadce0;
        flex-grow: 2;
      }
      input:focus {
        outline: none;
      }
      input.o-required,
      input.o-focused {
        border-width: 2px;
        padding: 3px 5px;
      }
      input.o-focused {
        border-color: ${SELECTION_BORDER_COLOR};
      }
      input.o-invalid {
        border-color: red;
      }
      button.o-btn {
        background: transparent;
        border: none;
        color: #333;
        cursor: pointer;
      }
      button.o-btn-action {
        margin: 8px 1px;
        border-radius: 4px;
        background: transparent;
        border: 1px solid #dadce0;
        color: #188038;
        font-weight: bold;
        font-size: 14px;
        height: 25px;
      }
    }
  }
`;
    /**
     * This component can be used when the user needs to input some
     * ranges. He can either input the ranges with the regular DOM `<input/>`
     * displayed or by selecting zones on the grid.
     *
     * A `selection-changed` event is triggered every time the input value
     * changes.
     */
    class SelectionInput extends Component$q {
        constructor() {
            super(...arguments);
            this.id = uuidGenerator$1.uuidv4();
            this.previousRanges = this.props.ranges || [];
            this.getters = this.env.getters;
            this.dispatch = this.env.dispatch;
            this.originSheet = this.env.getters.getActiveSheetId();
            this.state = useState$l({
                isMissing: false,
            });
        }
        get ranges() {
            const existingSelectionRange = this.getters.getSelectionInput(this.id);
            const ranges = existingSelectionRange.length
                ? existingSelectionRange
                : this.props.ranges
                    ? this.props.ranges.map((xc, i) => ({
                        xc,
                        id: i.toString(),
                        isFocused: false,
                    }))
                    : [];
            return ranges.map((range) => ({
                ...range,
                isValidRange: range.xc === "" || this.getters.isRangeValid(range.xc),
            }));
        }
        get hasFocus() {
            return this.ranges.filter((i) => i.isFocused).length > 0;
        }
        get canAddRange() {
            return !this.props.hasSingleRange;
        }
        get isInvalid() {
            return this.props.isInvalid || this.state.isMissing;
        }
        mounted() {
            this.dispatch("ENABLE_NEW_SELECTION_INPUT", {
                id: this.id,
                initialRanges: this.props.ranges,
                hasSingleRange: this.props.hasSingleRange,
            });
        }
        async willUnmount() {
            this.dispatch("DISABLE_SELECTION_INPUT", { id: this.id });
        }
        async patched() {
            const value = this.getters.getSelectionInputValue(this.id);
            if (this.previousRanges.join() !== value.join()) {
                this.triggerChange();
            }
        }
        getColor(range) {
            const color = range.color || "#000";
            return "color: " + color + ";";
        }
        triggerChange() {
            const ranges = this.getters.getSelectionInputValue(this.id);
            this.trigger("selection-changed", { ranges });
            this.previousRanges = ranges;
        }
        focus(rangeId) {
            this.state.isMissing = false;
            this.dispatch("STOP_EDITION", { cancel: true });
            this.dispatch("FOCUS_RANGE", {
                id: this.id,
                rangeId,
            });
        }
        addEmptyInput() {
            this.dispatch("ADD_EMPTY_RANGE", { id: this.id });
        }
        removeInput(rangeId) {
            this.dispatch("REMOVE_RANGE", { id: this.id, rangeId });
            this.triggerChange();
            this.trigger("selection-confirmed");
        }
        onInputChanged(rangeId, ev) {
            const target = ev.target;
            this.dispatch("CHANGE_RANGE", {
                id: this.id,
                rangeId,
                value: target.value,
            });
            target.blur();
            this.triggerChange();
        }
        disable() {
            this.dispatch("UNFOCUS_SELECTION_INPUT");
            const ranges = this.getters.getSelectionInputValue(this.id);
            if (this.props.required && ranges.length === 0) {
                this.state.isMissing = true;
            }
            const activeSheetId = this.getters.getActiveSheetId();
            if (this.originSheet !== activeSheetId) {
                this.dispatch("ACTIVATE_SHEET", {
                    sheetIdFrom: activeSheetId,
                    sheetIdTo: this.originSheet,
                });
            }
            this.trigger("selection-confirmed");
        }
    }
    SelectionInput.template = TEMPLATE$q;
    SelectionInput.style = CSS$n;

    const conditionalFormattingTerms = {
        CF_TITLE: _lt("Format rules"),
        IS_RULE: _lt("Format cells if..."),
        FORMATTING_STYLE: _lt("Formatting style"),
        BOLD: _lt("Bold"),
        ITALIC: _lt("Italic"),
        UNDERLINE: _lt("Underline"),
        STRIKE_THROUGH: _lt("Strikethrough"),
        TEXT_COLOR: _lt("Text Color"),
        FILL_COLOR: _lt("Fill Color"),
        CANCEL: _lt("Cancel"),
        SAVE: _lt("Save"),
        PREVIEW_TEXT: _lt("Preview text"),
        Errors: {
            [20 /* InvalidRange */]: _lt("The range is invalid"),
            [34 /* FirstArgMissing */]: _lt("The argument is missing. Please provide a value"),
            [35 /* SecondArgMissing */]: _lt("The second argument is missing. Please provide a value"),
            [36 /* MinNaN */]: _lt("The minpoint must be a number"),
            [37 /* MidNaN */]: _lt("The midpoint must be a number"),
            [38 /* MaxNaN */]: _lt("The maxpoint must be a number"),
            [39 /* ValueUpperInflectionNaN */]: _lt("The first value must be a number"),
            [40 /* ValueLowerInflectionNaN */]: _lt("The second value must be a number"),
            [30 /* MinBiggerThanMax */]: _lt("Minimum must be smaller then Maximum"),
            [33 /* MinBiggerThanMid */]: _lt("Minimum must be smaller then Midpoint"),
            [32 /* MidBiggerThanMax */]: _lt("Midpoint must be smaller then Maximum"),
            [31 /* LowerBiggerThanUpper */]: _lt("Lower inflection point must be smaller then upper inflection point"),
            [41 /* MinInvalidFormula */]: _lt("Invalid Minpoint formula"),
            [43 /* MaxInvalidFormula */]: _lt("Invalid Maxpoint formula"),
            [42 /* MidInvalidFormula */]: _lt("Invalid Midpoint formula"),
            [44 /* ValueUpperInvalidFormula */]: _lt("Invalid upper inflection point formula"),
            [45 /* ValueLowerInvalidFormula */]: _lt("Invalid lower inflection point formula"),
            [19 /* EmptyRange */]: _lt("A range needs to be defined"),
            unexpected: _lt("The rule is invalid for an unknown reason"),
        },
        SingleColor: _lt("Single color"),
        ColorScale: _lt("Color scale"),
        IconSet: _lt("Icon set"),
        newRule: _lt("Add another rule"),
        FixedNumber: _lt("Number"),
        Percentage: _lt("Percentage"),
        Percentile: _lt("Percentile"),
        Formula: _lt("Formula"),
    };
    const colorScale = {
        CellValues: _lt("Cell values"),
        None: _lt("None"),
        Preview: _lt("Preview"),
        Minpoint: _lt("Minpoint"),
        MaxPoint: _lt("Maxpoint"),
        MidPoint: _lt("Midpoint"),
    };
    const iconSetRule = {
        WhenValueIs: _lt("When value is"),
        Else: _lt("Else"),
        ReverseIcons: _lt("Reverse icons"),
        Icons: _lt("Icons"),
        Type: _lt("Type"),
        Value: _lt("Value"),
    };
    const cellIsOperators = {
        IsEmpty: _lt("Is empty"),
        IsNotEmpty: _lt("Is not empty"),
        ContainsText: _lt("Contains"),
        NotContains: _lt("Does not contain"),
        BeginsWith: _lt("Starts with"),
        EndsWith: _lt("Ends with"),
        Equal: _lt("Is equal to"),
        NotEqual: _lt("Is not equal to"),
        GreaterThan: _lt("Is greater than"),
        GreaterThanOrEqual: _lt("Is greater than or equal to"),
        LessThan: _lt("Is less than"),
        LessThanOrEqual: _lt("Is less than or equal to"),
        Between: _lt("Is between"),
        NotBetween: _lt("Is not between"),
    };
    const chartTerms = {
        ChartType: _lt("Chart type"),
        Line: _lt("Line"),
        Bar: _lt("Bar"),
        Pie: _lt("Pie"),
        StackedBar: _lt("Stacked barchart"),
        Title: _lt("Title"),
        Series: _lt("Series"),
        DataSeries: _lt("Data Series"),
        MyDataHasTitle: _lt("Data series include title"),
        DataCategories: _lt("Categories / Labels"),
        UpdateChart: _lt("Update chart"),
        CreateChart: _lt("Create chart"),
        TitlePlaceholder: _lt("New Chart"),
        BackgroundColor: _lt("Background color"),
        SelectColor: _lt("Select a color..."),
        VerticalAxisPosition: _lt("Vertical axis position"),
        LegendPosition: _lt("Legend position"),
        Left: _lt("Left"),
        Right: _lt("Right"),
        None: _lt("None"),
        Top: _lt("Top"),
        Bottom: _lt("Bottom"),
        Center: _lt("Center"),
        Linear: _lt("Linear"),
        Exponential: _lt("Exponential"),
        Logarithmic: _lt("Logarithmic"),
        Errors: {
            [25 /* EmptyDataSet */]: _lt("A dataset needs to be defined"),
            [26 /* InvalidDataSet */]: _lt("The dataset is invalid"),
            [27 /* InvalidLabelRange */]: _lt("Labels are invalid"),
            unexpected: _lt("The chart definition is invalid for an unknown reason"),
        },
    };
    const FindAndReplaceTerms = {
        Search: _lt("Search"),
        Replace: _lt("Replace"),
        Next: _lt("Next"),
        Previous: _lt("Previous"),
        MatchCase: _lt("Match case"),
        ExactMatch: _lt("Match entire cell content"),
        SearchFormulas: _lt("Search in formulas"),
        ReplaceAll: _lt("Replace all"),
        ReplaceFormulas: _lt("Also modify formulas"),
    };
    const LinkEditorTerms = {
        Text: _lt("Text"),
        Link: _lt("Link"),
        Confirm: _lt("Confirm"),
        Cancel: _lt("Cancel"),
        Edit: _lt("Edit link"),
        Remove: _lt("Remove link"),
    };
    const GenericWords = {
        And: _lt("and"),
    };

    const { Component: Component$p, useState: useState$k } = owl__namespace;
    const { xml: xml$s, css: css$q } = owl__namespace.tags;
    const CONFIGURATION_TEMPLATE = xml$s /* xml */ `
<div>
  <div class="o-section">
    <div class="o-section-title" t-esc="env._t('${chartTerms.ChartType}')"/>
    <select t-model="state.chart.type" class="o-input o-type-selector" t-on-change="updateSelect('type')">
      <option value="bar" t-esc="env._t('${chartTerms.Bar}')"/>
      <option value="line" t-esc="env._t('${chartTerms.Line}')"/>
      <option value="pie" t-esc="env._t('${chartTerms.Pie}')"/>
    </select>
    <t t-if="state.chart.type === 'bar'">
      <div class="o_checkbox">
        <input type="checkbox" name="stackedBar" t-model="state.chart.stackedBar" t-on-change="updateStacked"/>
        <t t-esc="env._t('${chartTerms.StackedBar}')"/>
      </div>
    </t>
  </div>
  <div class="o-section o-data-series">
    <div class="o-section-title" t-esc="env._t('${chartTerms.DataSeries}')"/>
    <SelectionInput t-key="getKey('dataSets')"
                    ranges="state.chart.dataSets"
                    isInvalid="isDatasetInvalid"
                    required="true"
                    t-on-selection-changed="onSeriesChanged"
                    t-on-selection-confirmed="updateDataSet" />
    <input type="checkbox" t-model="state.chart.dataSetsHaveTitle" t-on-change="updateDataSet"/><t t-esc="env._t('${chartTerms.MyDataHasTitle}')"/>
  </div>
  <div class="o-section o-data-labels">
    <div class="o-section-title" t-esc="env._t('${chartTerms.DataCategories}')"/>
    <SelectionInput t-key="getKey('label')"
                    ranges="[state.chart.labelRange || '']"
                    isInvalid="isLabelInvalid"
                    hasSingleRange="true"
                    t-on-selection-changed="onLabelRangeChanged"
                    t-on-selection-confirmed="updateLabelRange" />
  </div>
  <div class="o-section o-sidepanel-error" t-if="errorMessages">
    <div t-foreach="errorMessages" t-as="error">
      <t t-esc="error"/>
    </div>
  </div>
</div>
`;
    const DESIGN_TEMPLATE = xml$s /* xml */ `
<div>
  <div class="o-section o-chart-title">
    <div class="o-section-title" t-esc="env._t('${chartTerms.BackgroundColor}')"/>
    <div class="o-with-color-picker">
      <t t-esc="env._t('${chartTerms.SelectColor}')"/>
      <span t-attf-style="border-color:{{state.chart.background}}"
            t-on-click.stop="toggleColorPicker">${FILL_COLOR_ICON}</span>
      <ColorPicker t-if="state.fillColorTool" t-on-color-picked="setColor" t-key="backgroundColor"/>
    </div>
  </div>
  <div class="o-section o-chart-title">
    <div class="o-section-title" t-esc="env._t('${chartTerms.Title}')"/>
    <input type="text" t-model="state.chart.title" t-on-change="updateTitle" class="o-input" t-att-placeholder="env._t('${chartTerms.TitlePlaceholder}')"/>
  </div>
  <div class="o-section">
    <div class="o-section-title"><t t-esc="env._t('${chartTerms.VerticalAxisPosition}')"/></div>
    <select t-model="state.chart.verticalAxisPosition" class="o-input o-type-selector" t-on-change="updateSelect('verticalAxisPosition')">
      <option value="left" t-esc="env._t('${chartTerms.Left}')"/>
      <option value="right" t-esc="env._t('${chartTerms.Right}')"/>
    </select>
  </div>
  <div class="o-section">
    <div class="o-section-title"><t t-esc="env._t('${chartTerms.LegendPosition}')"/></div>
    <select t-model="state.chart.legendPosition" class="o-input o-type-selector" t-on-change="updateSelect('legendPosition')">
      <option value="top" t-esc="env._t('${chartTerms.Top}')"/>
      <option value="bottom" t-esc="env._t('${chartTerms.Bottom}')"/>
      <option value="left" t-esc="env._t('${chartTerms.Left}')"/>
      <option value="right" t-esc="env._t('${chartTerms.Right}')"/>
    </select>
  </div>
</div>
`;
    const TEMPLATE$p = xml$s /* xml */ `
  <div class="o-chart">
    <div class="o-panel">
      <div class="o-panel-element"
          t-att-class="state.panel !== 'configuration' ? 'inactive' : ''"
          t-on-click="activate('configuration')">
        <i class="fa fa-sliders"/>Configuration
      </div>
      <div class="o-panel-element"
          t-att-class="state.panel !== 'design' ? 'inactive' : ''"
          t-on-click="activate('design')">
        <i class="fa fa-paint-brush"/>Design
      </div>
    </div>

    <t t-if="state.panel === 'configuration'">
      <t t-call="${CONFIGURATION_TEMPLATE}"/>
    </t>
    <t t-else="">
      <t t-call="${DESIGN_TEMPLATE}"/>
    </t>
  </div>
`;
    const STYLE = css$q /* scss */ `
  .o-chart {
    .o-panel {
      display: flex;
      .o-panel-element {
        flex: 1 0 auto;
        padding: 8px 0px;
        text-align: center;
        cursor: pointer;
        border-right: 1px solid darkgray;
        &.inactive {
          background-color: ${BACKGROUND_HEADER_COLOR};
          border-bottom: 1px solid darkgray;
        }
        .fa {
          margin-right: 4px;
        }
      }
      .o-panel-element:last-child {
        border-right: none;
      }
    }

    .o-with-color-picker {
      position: relative;
    }
    .o-with-color-picker > span {
      border-bottom: 4px solid;
    }
  }
`;
    class ChartPanel extends Component$p {
        constructor() {
            super(...arguments);
            this.getters = this.env.getters;
            this.state = useState$k(this.initialState(this.props.figure));
        }
        async willUpdateProps(nextProps) {
            if (!this.getters.getChartDefinition(nextProps.figure.id)) {
                this.trigger("close-side-panel");
                return;
            }
            if (nextProps.figure.id !== this.props.figure.id) {
                this.state.panel = "configuration";
                this.state.fillColorTool = false;
                this.state.datasetDispatchResult = undefined;
                this.state.labelsDispatchResult = undefined;
                this.state.chart = this.env.getters.getChartDefinitionUI(this.env.getters.getActiveSheetId(), nextProps.figure.id);
            }
        }
        get errorMessages() {
            var _a, _b;
            const cancelledReasons = [
                ...(((_a = this.state.datasetDispatchResult) === null || _a === void 0 ? void 0 : _a.reasons) || []),
                ...(((_b = this.state.labelsDispatchResult) === null || _b === void 0 ? void 0 : _b.reasons) || []),
            ];
            return cancelledReasons.map((error) => this.env._t(chartTerms.Errors[error] || chartTerms.Errors.unexpected));
        }
        get isDatasetInvalid() {
            var _a, _b;
            return !!(((_a = this.state.datasetDispatchResult) === null || _a === void 0 ? void 0 : _a.isCancelledBecause(25 /* EmptyDataSet */)) ||
                ((_b = this.state.datasetDispatchResult) === null || _b === void 0 ? void 0 : _b.isCancelledBecause(26 /* InvalidDataSet */)));
        }
        get isLabelInvalid() {
            var _a;
            return !!((_a = this.state.labelsDispatchResult) === null || _a === void 0 ? void 0 : _a.isCancelledBecause(27 /* InvalidLabelRange */));
        }
        onSeriesChanged(ev) {
            this.state.chart.dataSets = ev.detail.ranges;
        }
        updateDataSet() {
            this.state.datasetDispatchResult = this.updateChart({
                dataSets: this.state.chart.dataSets,
                dataSetsHaveTitle: this.state.chart.dataSetsHaveTitle,
            });
        }
        updateStacked() {
            this.updateChart({ stackedBar: this.state.chart.stackedBar });
        }
        updateTitle() {
            this.updateChart({ title: this.state.chart.title });
        }
        updateSelect(attr, ev) {
            this.state.chart[attr] = ev.target.value;
            this.updateChart({ [attr]: ev.target.value });
        }
        updateLabelRange() {
            this.state.labelsDispatchResult = this.updateChart({
                labelRange: this.state.chart.labelRange || null,
            });
        }
        updateChart(definition) {
            return this.env.dispatch("UPDATE_CHART", {
                id: this.props.figure.id,
                sheetId: this.getters.getActiveSheetId(),
                definition,
            });
        }
        onLabelRangeChanged(ev) {
            this.state.chart.labelRange = ev.detail.ranges[0];
        }
        getKey(label) {
            return label + this.props.figure.id;
        }
        toggleColorPicker() {
            this.state.fillColorTool = !this.state.fillColorTool;
        }
        setColor(ev) {
            this.state.chart.background = ev.detail.color;
            this.state.fillColorTool = false;
            this.updateChart({ background: this.state.chart.background });
        }
        activate(panel) {
            this.state.panel = panel;
        }
        initialState(figure) {
            return {
                chart: this.env.getters.getChartDefinitionUI(this.env.getters.getActiveSheetId(), figure.id),
                panel: "configuration",
                fillColorTool: false,
            };
        }
    }
    ChartPanel.template = TEMPLATE$p;
    ChartPanel.style = STYLE;
    ChartPanel.components = { SelectionInput, ColorPicker };

    /**
     * Return true if the event was triggered from
     * a child element.
     */
    function isChildEvent(parent, ev) {
        return !!ev.target && parent.contains(ev.target);
    }
    function getTextDecoration({ strikethrough, underline, }) {
        if (!strikethrough && !underline) {
            return "none";
        }
        return `${strikethrough ? "line-through" : ""} ${underline ? "underline" : ""}`;
    }

    const { Component: Component$o, useState: useState$j, hooks: hooks$4 } = owl__namespace;
    const { useExternalListener: useExternalListener$5 } = hooks$4;
    const { xml: xml$r, css: css$p } = owl__namespace.tags;
    const PREVIEW_TEMPLATE$2 = xml$r /* xml */ `
    <div class="o-cf-preview-line"
         t-attf-style="font-weight:{{currentStyle.bold ?'bold':'normal'}};
                       text-decoration:{{getTextDecoration(currentStyle)}};
                       font-style:{{currentStyle.italic?'italic':'normal'}};
                       color:{{currentStyle.textColor}};
                       border-radius: 4px;
                       background-color:{{currentStyle.fillColor}};"
         t-esc="previewText || env._t('${conditionalFormattingTerms.PREVIEW_TEXT}')" />
`;
    const TEMPLATE$o = xml$r /* xml */ `
<div>
    <div class="o-cf-title-text" t-esc="env._t('${conditionalFormattingTerms.IS_RULE}')"></div>
    <select t-model="state.condition.operator" class="o-input o-cell-is-operator">
        <t t-foreach="Object.keys(cellIsOperators)" t-as="op" t-key="op_index">
            <option t-att-value="op" t-esc="cellIsOperators[op]"/>
        </t>
    </select>
    <t t-if="state.condition.operator !== 'IsEmpty' and state.condition.operator !== 'IsNotEmpty'">
      <input type="text"
             placeholder="Value"
             t-model="state.condition.value1"
             t-att-class="{ 'o-invalid': isValue1Invalid }"
             class="o-input o-cell-is-value o-required"/>
      <t t-if="state.condition.operator === 'Between' || state.condition.operator === 'NotBetween'">
          <input type="text"
                 placeholder="and value"
                 t-model="state.condition.value2"
                 t-att-class="{ 'o-invalid': isValue2Invalid }"
                 class="o-input o-cell-is-value o-required"/>
      </t>
    </t>
    <div class="o-cf-title-text" t-esc="env._t('${conditionalFormattingTerms.FORMATTING_STYLE}')"></div>

    <t t-call="${PREVIEW_TEMPLATE$2}">
        <t t-set="currentStyle" t-value="state.style"/>
    </t>
    <div class="o-tools">
        <div class="o-tool" t-att-title="env._t('${conditionalFormattingTerms.BOLD}')" t-att-class="{active:state.style.bold}" t-on-click="toggleTool('bold')">
            ${BOLD_ICON}
        </div>
        <div class="o-tool" t-att-title="env._t('${conditionalFormattingTerms.ITALIC}')" t-att-class="{active:state.style.italic}" t-on-click="toggleTool('italic')">
            ${ITALIC_ICON}
        </div>
        <div class="o-tool" t-att-title="env._t('${conditionalFormattingTerms.UNDERLINE}')" t-att-class="{active:state.style.underline}"
             t-on-click="toggleTool('underline')">${UNDERLINE_ICON}
        </div>
        <div class="o-tool" t-att-title="env._t('${conditionalFormattingTerms.STRIKE_THROUGH}')" t-att-class="{active:state.style.strikethrough}"
             t-on-click="toggleTool('strikethrough')">${STRIKE_ICON}
        </div>
        <div class="o-tool o-dropdown o-with-color">
              <span t-att-title="env._t('${conditionalFormattingTerms.TEXT_COLOR}')" t-attf-style="border-color:{{state.style.textColor}}"
                    t-on-click.stop="toggleMenu('textColorTool')">
                    ${TEXT_COLOR_ICON}
              </span>
              <ColorPicker t-if="state.textColorTool" dropdownDirection="'center'" t-on-color-picked="setColor('textColor')" t-key="textColor"/>
        </div>
        <div class="o-divider"/>
        <div class="o-tool o-dropdown o-with-color">
          <span t-att-title="env._t('${conditionalFormattingTerms.FILL_COLOR}')" t-attf-style="border-color:{{state.style.fillColor}}"
                t-on-click.stop="toggleMenu('fillColorTool')">
                ${FILL_COLOR_ICON}
          </span>
          <ColorPicker t-if="state.fillColorTool" dropdownDirection="'center'" t-on-color-picked="setColor('fillColor')" t-key="fillColor"/>
        </div>
    </div>
</div>
`;
    const CSS$m = css$p /* scss */ `
  .o-cf-preview-line {
    border: 1px solid darkgrey;
    padding: 10px;
  }
  .o-cell-is-operator {
    margin-bottom: 5px;
    width: 96%;
  }
  .o-cell-is-value {
    margin-bottom: 5px;
    width: 96%;
  }
  .o-color-picker {
    pointer-events: all;
  }
`;
    class CellIsRuleEditor extends Component$o {
        constructor() {
            super(...arguments);
            // @ts-ignore used in XML template
            this.cellIsOperators = cellIsOperators;
            // @ts-ignore used in XML template
            this.getTextDecoration = getTextDecoration;
            this.state = useState$j({
                condition: {
                    operator: this.props.rule && this.props.rule.operator ? this.props.rule.operator : "IsNotEmpty",
                    value1: this.props.rule && this.props.rule.values.length > 0 ? this.props.rule.values[0] : "",
                    value2: this.props.rule.values.length > 1 ? this.props.rule.values[1] : "",
                },
                textColorTool: false,
                fillColorTool: false,
                style: {
                    fillColor: this.props.rule.style.fillColor,
                    textColor: this.props.rule.style.textColor,
                    bold: this.props.rule.style.bold,
                    italic: this.props.rule.style.italic,
                    strikethrough: this.props.rule.style.strikethrough,
                    underline: this.props.rule.style.underline,
                },
            });
            useExternalListener$5(window, "click", this.closeMenus);
        }
        get isValue1Invalid() {
            var _a;
            return !!((_a = this.props.errors) === null || _a === void 0 ? void 0 : _a.includes(34 /* FirstArgMissing */));
        }
        get isValue2Invalid() {
            var _a;
            return !!((_a = this.props.errors) === null || _a === void 0 ? void 0 : _a.includes(35 /* SecondArgMissing */));
        }
        getRule() {
            const newStyle = {};
            const style = this.state.style;
            if (style.bold !== undefined) {
                newStyle.bold = style.bold;
            }
            if (style.italic !== undefined) {
                newStyle.italic = style.italic;
            }
            if (style.strikethrough !== undefined) {
                newStyle.strikethrough = style.strikethrough;
            }
            if (style.underline !== undefined) {
                newStyle.underline = style.underline;
            }
            if (style.fillColor) {
                newStyle.fillColor = style.fillColor;
            }
            if (style.textColor) {
                newStyle.textColor = style.textColor;
            }
            return {
                type: "CellIsRule",
                operator: this.state.condition.operator,
                values: [this.state.condition.value1, this.state.condition.value2],
                style: newStyle,
            };
        }
        toggleMenu(tool) {
            const current = this.state[tool];
            this.closeMenus();
            this.state[tool] = !current;
        }
        toggleTool(tool) {
            this.state.style[tool] = !this.state.style[tool];
            this.closeMenus();
        }
        setColor(target, ev) {
            const color = ev.detail.color;
            this.state.style[target] = color;
            this.closeMenus();
        }
        closeMenus() {
            this.state.textColorTool = false;
            this.state.fillColorTool = false;
        }
        /**
         * Get a default rule for "CellIsRule"
         */
        static getDefaultRule() {
            return {
                type: "CellIsRule",
                operator: "IsNotEmpty",
                values: [],
                style: { fillColor: "#b6d7a8" },
            };
        }
    }
    CellIsRuleEditor.template = TEMPLATE$o;
    CellIsRuleEditor.style = CSS$m;
    CellIsRuleEditor.components = { ColorPicker };
    CellIsRuleEditor.defaultProps = {
        errors: [],
    };

    const { Component: Component$n, useState: useState$i, hooks: hooks$3 } = owl__namespace;
    const { useExternalListener: useExternalListener$4 } = hooks$3;
    const { xml: xml$q, css: css$o } = owl__namespace.tags;
    const PREVIEW_TEMPLATE$1 = xml$q /* xml */ `
  <div class="o-cf-preview-gradient" t-attf-style="{{getPreviewGradient()}}">
    <t t-esc="env._t('${conditionalFormattingTerms.PREVIEW_TEXT}')"/>
  </div>
`;
    const THRESHOLD_TEMPLATE = xml$q /* xml */ `
  <div t-attf-class="o-threshold o-threshold-{{thresholdType}}">
      <select class="o-input" name="valueType" t-model="threshold.type" t-on-click="closeMenus">
        <option value="value" t-if="thresholdType!=='midpoint'">
          <t t-esc="env._t('${colorScale.CellValues}')"/>
        </option>
        <option value="none" t-if="thresholdType==='midpoint'">
          <t t-esc="env._t('${colorScale.None}')"/>
        </option>
        <option value="number">
          <t t-esc="env._t('${conditionalFormattingTerms.FixedNumber}')"/>
        </option>
        <option value="percentage">
          <t t-esc="env._t('${conditionalFormattingTerms.Percentage}')"/>
        </option>
        <option value="percentile">
          <t t-esc="env._t('${conditionalFormattingTerms.Percentile}')"/>
        </option>
        <option value="formula">
          <t t-esc="env._t('${conditionalFormattingTerms.Formula}')"/>
        </option>
      </select>
      <input type="text" class="o-input o-threshold-value o-required"
        t-model="stateColorScale[thresholdType].value"
        t-att-class="{ 'o-invalid': isValueInvalid(thresholdType) }"
        t-if="['number', 'percentage', 'percentile', 'formula'].includes(threshold.type)"
      />
      <input type="text" class="o-input o-threshold-value"
        t-else="" disabled="1"
      />
      <div class="o-tools">
        <div class="o-tool  o-dropdown o-with-color">
          <span title="Fill Color"  t-attf-style="border-color:#{{colorNumberString(threshold.color)}}"
                t-on-click.stop="toggleMenu(thresholdType+'ColorTool')">${FILL_COLOR_ICON}</span>
          <ColorPicker t-if="stateColorScale[thresholdType+'ColorTool']" dropdownDirection="'left'" t-on-color-picked="setColor(thresholdType)"/>
        </div>
      </div>
  </div>`;
    const TEMPLATE$n = xml$q /* xml */ `
  <div>
      <div class="o-cf-title-text">
        <t t-esc="env._t('${colorScale.Preview}')"/>
      </div>
      <t t-call="${PREVIEW_TEMPLATE$1}"/>
      <div class="o-cf-title-text">
        <t t-esc="env._t('${colorScale.Minpoint}')"/>
      </div>
      <t t-call="${THRESHOLD_TEMPLATE}">
          <t t-set="threshold" t-value="stateColorScale.minimum" ></t>
          <t t-set="thresholdType" t-value="'minimum'" ></t>
      </t>
      <div class="o-cf-title-text">
        <t t-esc="env._t('${colorScale.MidPoint}')"/>
      </div>
      <t t-call="${THRESHOLD_TEMPLATE}">
          <t t-set="threshold" t-value="stateColorScale.midpoint" ></t>
          <t t-set="thresholdType" t-value="'midpoint'" ></t>
      </t>
      <div class="o-cf-title-text">
        <t t-esc="env._t('${colorScale.MaxPoint}')"/>
      </div>
      <t t-call="${THRESHOLD_TEMPLATE}">
          <t t-set="threshold" t-value="stateColorScale.maximum" ></t>
          <t t-set="thresholdType" t-value="'maximum'" ></t>
      </t>
  </div>`;
    const CSS$l = css$o /* scss */ `
  .o-threshold {
    display: flex;
    flex-direction: horizontal;
    select {
      width: 100%;
    }
    .o-threshold-value {
      margin-left: 2%;
      width: 20%;
      min-width: 0px; // input overflows in Firefox otherwise
    }
    .o-threshold-value:disabled {
      background-color: #edebed;
    }
  }
  .o-cf-preview-gradient {
    border: 1px solid darkgrey;
    padding: 10px;
    border-radius: 4px;
  }
`;
    class ColorScaleRuleEditor extends Component$n {
        constructor() {
            super(...arguments);
            this.colorNumberString = colorNumberString;
            this.stateColorScale = useState$i({
                minimum: this.props.rule.minimum,
                maximum: this.props.rule.maximum,
                midpoint: this.props.rule.midpoint
                    ? this.props.rule.midpoint
                    : { color: 0xb6d7a8, type: "none" },
                maximumColorTool: false,
                minimumColorTool: false,
                midpointColorTool: false,
            });
            useExternalListener$4(window, "click", this.closeMenus);
        }
        getRule() {
            const minimum = { ...this.stateColorScale.minimum };
            const midpoint = { ...this.stateColorScale.midpoint };
            const maximum = { ...this.stateColorScale.maximum };
            return {
                type: "ColorScaleRule",
                minimum,
                maximum,
                midpoint: midpoint.type === "none" ? undefined : midpoint,
            };
        }
        toggleMenu(tool) {
            const current = this.stateColorScale[tool];
            this.closeMenus();
            this.stateColorScale[tool] = !current;
        }
        setColor(target, ev) {
            const color = ev.detail.color;
            this.stateColorScale[target].color = Number.parseInt(color.substr(1), 16);
            this.closeMenus();
        }
        getPreviewGradient() {
            const minColor = colorNumberString(this.stateColorScale.minimum.color);
            const midColor = colorNumberString(this.stateColorScale.midpoint.color);
            const maxColor = colorNumberString(this.stateColorScale.maximum.color);
            const baseString = "background-image: linear-gradient(to right, #";
            return this.stateColorScale.midpoint.type === "none"
                ? baseString + minColor + ", #" + maxColor + ")"
                : baseString + minColor + ", #" + midColor + ", #" + maxColor + ")";
        }
        isValueInvalid(threshold) {
            switch (threshold) {
                case "minimum":
                    return (this.props.errors.includes(41 /* MinInvalidFormula */) ||
                        this.props.errors.includes(33 /* MinBiggerThanMid */) ||
                        this.props.errors.includes(30 /* MinBiggerThanMax */) ||
                        this.props.errors.includes(36 /* MinNaN */));
                case "midpoint":
                    return (this.props.errors.includes(42 /* MidInvalidFormula */) ||
                        this.props.errors.includes(37 /* MidNaN */) ||
                        this.props.errors.includes(32 /* MidBiggerThanMax */));
                case "maximum":
                    return (this.props.errors.includes(43 /* MaxInvalidFormula */) ||
                        this.props.errors.includes(38 /* MaxNaN */));
                default:
                    return false;
            }
        }
        closeMenus() {
            this.stateColorScale.minimumColorTool = false;
            this.stateColorScale.midpointColorTool = false;
            this.stateColorScale.maximumColorTool = false;
        }
        /**
         * Get a default rule for "ColorScaleRule"
         */
        static getDefaultRule() {
            return {
                type: "ColorScaleRule",
                minimum: { type: "value", color: 0xffffff },
                midpoint: undefined,
                maximum: { type: "value", color: 0x6aa84f },
            };
        }
    }
    ColorScaleRuleEditor.template = TEMPLATE$n;
    ColorScaleRuleEditor.style = CSS$l;
    ColorScaleRuleEditor.components = { ColorPicker };
    ColorScaleRuleEditor.defaultProps = {
        errors: [],
    };

    const { Component: Component$m } = owl__namespace;
    const { css: css$n, xml: xml$p } = owl__namespace.tags;
    class IconPicker extends Component$m {
        constructor() {
            super(...arguments);
            this.icons = ICONS;
            this.iconSets = ICON_SETS;
        }
        onIconClick(icon) {
            if (icon) {
                this.trigger("icon-picked", { icon });
            }
        }
    }
    IconPicker.template = xml$p /* xml */ `
  <div class="o-icon-picker" >
    <t t-foreach="iconSets" t-as="iconSet" t-key="iconset">
      <div class="o-cf-icon-line">
        <div class="o-icon-picker-item" t-on-click="onIconClick(iconSets[iconSet].good)">
          <t t-raw="icons[iconSets[iconSet].good].svg"/>
        </div>
        <div class="o-icon-picker-item" t-on-click="onIconClick(iconSets[iconSet].neutral)">
          <t t-raw="icons[iconSets[iconSet].neutral].svg"/>
        </div>
        <div class="o-icon-picker-item" t-on-click="onIconClick(iconSets[iconSet].bad)">
          <t t-raw="icons[iconSets[iconSet].bad].svg"/>
        </div>
      </div>
    </t>
  </div>`;
    IconPicker.style = css$n /* scss */ `
    .o-icon-picker {
      position: absolute;
      z-index: 10;
      box-shadow: 1px 2px 5px 2px rgba(51, 51, 51, 0.15);
      background-color: white;
      padding: 2px 1px;
    }
    .o-cf-icon-line {
      display: flex;
      padding: 3px 6px;
    }
    .o-icon-picker-item {
      margin: 0px 2px;
      &:hover {
        background-color: rgba(0, 0, 0, 0.08);
        outline: 1px solid gray;
      }
    }
  `;

    const { Component: Component$l, useState: useState$h, hooks: hooks$2 } = owl__namespace;
    const { useExternalListener: useExternalListener$3 } = hooks$2;
    const { xml: xml$o, css: css$m } = owl__namespace.tags;
    const ICON_SETS_TEMPLATE = xml$o /* xml */ `
  <div>
  <div class="o-cf-title-text">
    <t t-esc="env._t('${iconSetRule.Icons}')"/>
  </div>
    <div class="o-cf-iconsets">
      <div class="o-cf-iconset" t-foreach="['arrows', 'smiley', 'dots']" t-as="iconSet" t-on-click="setIconSet(iconSet)">
        <div class="o-cf-icon">
          <t t-raw="icons[iconSets[iconSet].good].svg"/>
        </div>
        <div class="o-cf-icon">
          <t t-raw="icons[iconSets[iconSet].neutral].svg"/>
        </div>
        <div class="o-cf-icon">
          <t t-raw="icons[iconSets[iconSet].bad].svg"/>
        </div>
      </div>
    </div>
  </div>
`;
    const INFLECTION_POINTS_TEMPLATE_ROW = xml$o /* xml */ `
  <tr>
    <td>
      <div t-on-click.stop="toggleMenu(icon+'IconTool')">
        <div class="o-cf-icon-button">
          <t t-raw="icons[iconValue].svg"/>
        </div>
      </div>
      <IconPicker t-if="stateIconSetCF[icon+'IconTool']" t-on-icon-picked="setIcon(icon)"/>
    </td>
    <td>
      <t t-esc="env._t('${iconSetRule.WhenValueIs}')"/>
    </td>
    <td>
      <select class="o-input" name="valueType" t-model="inflectionPointValue.operator">
        <option value="gt">
          <span>&#62;</span>
        </option>
        <option value="ge">
          <span>&#8805;</span>
        </option>
      </select>
    </td>
    <td>
      <input type="text" class="o-input"
        t-att-class="{ 'o-invalid': isInflectionPointInvalid(inflectionPoint) }"
        t-model="stateIconSetCF[inflectionPoint].value"
      />
    </td>
    <td>
      <select class="o-input" name="valueType" t-model="inflectionPointValue.type">
      <option value="number">
        <t t-esc="env._t('${conditionalFormattingTerms.FixedNumber}')"/>
      </option>
      <option value="percentage">
        <t t-esc="env._t('${conditionalFormattingTerms.Percentage}')"/>
      </option>
      <option value="percentile">
        <t t-esc="env._t('${conditionalFormattingTerms.Percentile}')"/>
      </option>
      <option value="formula">
        <t t-esc="env._t('${conditionalFormattingTerms.Formula}')"/>
      </option>
      </select>
    </td>
  </tr>
`;
    const INFLECTION_POINTS_TEMPLATE = xml$o /* xml */ `
  <div class="o-inflection">
    <table>
    <tr>
      <th class="o-cf-iconset-icons"></th>
      <th class="o-cf-iconset-text"></th>
      <th class="o-cf-iconset-operator"></th>
      <th class="o-cf-iconset-value">
      <t t-esc="env._t('${iconSetRule.Value}')"/>
      </th>
      <th class="o-cf-iconset-type">
      <t t-esc="env._t('${iconSetRule.Type}')"/>
      </th>
    </tr>
    <t t-call="${INFLECTION_POINTS_TEMPLATE_ROW}">
      <t t-set="iconValue" t-value="stateIconSetCF.upperIcon" ></t>
      <t t-set="icon" t-value="'upper'" ></t>
      <t t-set="inflectionPointValue" t-value="stateIconSetCF.upperInflectionPoint" ></t>
      <t t-set="inflectionPoint" t-value="'upperInflectionPoint'" ></t>
    </t>
    <t t-call="${INFLECTION_POINTS_TEMPLATE_ROW}">
      <t t-set="iconValue" t-value="stateIconSetCF.middleIcon" ></t>
      <t t-set="icon" t-value="'middle'" ></t>
      <t t-set="inflectionPointValue" t-value="stateIconSetCF.lowerInflectionPoint" ></t>
      <t t-set="inflectionPoint" t-value="'lowerInflectionPoint'" ></t>
    </t>
    <tr>
      <td>
        <div t-on-click.stop="toggleMenu('lowerIconTool')">
          <div class="o-cf-icon-button" >
            <t t-raw="icons[stateIconSetCF.lowerIcon].svg"/>
          </div>
        </div>
        <IconPicker t-if="stateIconSetCF['lowerIconTool']" t-on-icon-picked="setIcon('lower')"/>
      </td>
      <td><t t-esc="env._t('${iconSetRule.Else}')"/></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
  </table>
  </div>`;
    const TEMPLATE$m = xml$o /* xml */ `
  <div class="o-cf-iconset-rule">
      <t t-call="${ICON_SETS_TEMPLATE}"/>
      <t t-call="${INFLECTION_POINTS_TEMPLATE}"/>
      <div class="btn btn-link o_refresh_measures o-cf-iconset-reverse" t-on-click="reverseIcons">
        <div class="mr-1 d-inline-block">
          <t t-raw="reverseIcon"/>
        </div>
        <t t-esc="env._t('${iconSetRule.ReverseIcons}')"/>
      </div>
  </div>`;
    const CSS$k = css$m /* scss */ `
  .o-cf-iconset-rule {
    font-size: 12;
    .o-cf-iconsets {
      display: flex;
      justify-content: space-between;
      .o-cf-iconset {
        border: 1px solid #dadce0;
        border-radius: 4px;
        display: inline-flex;
        padding: 5px 8px;
        width: 25%;
        cursor: pointer;
        justify-content: space-between;
        .o-cf-icon {
          display: inline;
          margin-left: 1%;
          margin-right: 1%;
        }
        svg {
          vertical-align: baseline;
        }
      }
      .o-cf-iconset:hover {
        background-color: rgba(0, 0, 0, 0.08);
      }
    }
    .o-inflection {
      .o-cf-icon-button {
        display: inline-block;
        border: 1px solid #dadce0;
        border-radius: 4px;
        cursor: pointer;
        padding: 1px 2px;
      }
      .o-cf-icon-button:hover {
        background-color: rgba(0, 0, 0, 0.08);
      }
      table {
        table-layout: fixed;
        margin-top: 2%;
        display: table;
        text-align: left;
        font-size: 12px;
        line-height: 18px;
        width: 100%;
      }
      th.o-cf-iconset-icons {
        width: 8%;
      }
      th.o-cf-iconset-text {
        width: 28%;
      }
      th.o-cf-iconset-operator {
        width: 14%;
      }
      th.o-cf-iconset-type {
        width: 28%;
      }
      th.o-cf-iconset-value {
        width: 26%;
      }
      input,
      select {
        width: 100%;
        height: 100%;
        box-sizing: border-box;
      }
    }
    .o-cf-iconset-reverse {
      margin-bottom: 2%;
      margin-top: 2%;
      .o-cf-label {
        display: inline-block;
        vertical-align: bottom;
        margin-bottom: 2px;
      }
    }
  }
`;
    class IconSetRuleEditor extends Component$l {
        constructor() {
            super(...arguments);
            this.icons = ICONS;
            this.iconSets = ICON_SETS;
            this.reverseIcon = REFRESH;
            this.stateIconSetCF = useState$h({
                reversed: false,
                upperInflectionPoint: this.props.rule.upperInflectionPoint,
                lowerInflectionPoint: this.props.rule.lowerInflectionPoint,
                upperIcon: this.props.rule.icons.upper,
                middleIcon: this.props.rule.icons.middle,
                lowerIcon: this.props.rule.icons.lower,
                upperIconTool: false,
                middleIconTool: false,
                lowerIconTool: false,
            });
            useExternalListener$3(window, "click", this.closeMenus);
        }
        isInflectionPointInvalid(inflectionPoint) {
            switch (inflectionPoint) {
                case "lowerInflectionPoint":
                    return (this.props.errors.includes(40 /* ValueLowerInflectionNaN */) ||
                        this.props.errors.includes(45 /* ValueLowerInvalidFormula */) ||
                        this.props.errors.includes(31 /* LowerBiggerThanUpper */));
                case "upperInflectionPoint":
                    return (this.props.errors.includes(39 /* ValueUpperInflectionNaN */) ||
                        this.props.errors.includes(44 /* ValueUpperInvalidFormula */) ||
                        this.props.errors.includes(31 /* LowerBiggerThanUpper */));
                default:
                    return true;
            }
        }
        toggleMenu(tool) {
            const current = this.stateIconSetCF[tool];
            this.closeMenus();
            this.stateIconSetCF[tool] = !current;
        }
        closeMenus() {
            this.stateIconSetCF.upperIconTool = false;
            this.stateIconSetCF.middleIconTool = false;
            this.stateIconSetCF.lowerIconTool = false;
        }
        setIconSet(iconSet) {
            this.stateIconSetCF.upperIcon = this.iconSets[iconSet].good;
            this.stateIconSetCF.middleIcon = this.iconSets[iconSet].neutral;
            this.stateIconSetCF.lowerIcon = this.iconSets[iconSet].bad;
        }
        setIcon(target, ev) {
            this.stateIconSetCF[target + "Icon"] = ev.detail.icon;
        }
        getRule() {
            const upperInflectionPoint = { ...this.stateIconSetCF.upperInflectionPoint };
            const lowerInflectionPoint = { ...this.stateIconSetCF.lowerInflectionPoint };
            return {
                type: "IconSetRule",
                lowerInflectionPoint,
                upperInflectionPoint,
                icons: {
                    upper: this.stateIconSetCF.upperIcon,
                    middle: this.stateIconSetCF.middleIcon,
                    lower: this.stateIconSetCF.lowerIcon,
                },
            };
        }
        getIconsSelction() {
            return Object.keys(this.icons);
        }
        reverseIcons() {
            const upperIcon = this.stateIconSetCF.upperIcon;
            this.stateIconSetCF.upperIcon = this.stateIconSetCF.lowerIcon;
            this.stateIconSetCF.lowerIcon = upperIcon;
        }
        static getDefaultRule() {
            return {
                type: "IconSetRule",
                icons: {
                    upper: "arrowGood",
                    middle: "arrowNeutral",
                    lower: "arrowBad",
                },
                upperInflectionPoint: {
                    type: "percentage",
                    value: "66",
                    operator: "gt",
                },
                lowerInflectionPoint: {
                    type: "percentage",
                    value: "33",
                    operator: "gt",
                },
            };
        }
    }
    IconSetRuleEditor.template = TEMPLATE$m;
    IconSetRuleEditor.style = CSS$k;
    IconSetRuleEditor.components = { IconPicker };

    const { Component: Component$k, useState: useState$g } = owl__namespace;
    const { xml: xml$n, css: css$l } = owl__namespace.tags;
    const { useRef: useRef$8 } = owl__namespace.hooks;
    // TODO vsc: add ordering of rules
    const PREVIEW_TEMPLATE = xml$n /* xml */ `
<div class="o-cf-preview">
  <t t-if="cf.rule.type==='IconSetRule'">
    <div class="o-cf-preview-icon">
      <t t-raw="icons[cf.rule.icons.upper].svg"/>
      <t t-raw="icons[cf.rule.icons.middle].svg"/>
      <t t-raw="icons[cf.rule.icons.lower].svg"/>
    </div>
  </t>
  <t t-else="">
    <div t-att-style="getStyle(cf.rule)" class="o-cf-preview-image">
      123
    </div>
  </t>
  <div class="o-cf-preview-description">
    <div class="o-cf-preview-ruletype">
      <div class="o-cf-preview-description-rule">
        <t t-esc="getDescription(cf)" />
      </div>
      <div class="o-cf-preview-description-values">
      <t t-if="cf.rule.values">
        <t t-esc="cf.rule.values[0]" />
        <t t-if="cf.rule.values[1]">
        <t t-esc="' ' + env._t('${GenericWords.And}')"/> <t t-esc="cf.rule.values[1]"/>
        </t>
      </t>
      </div>
    </div>
    <div class="o-cf-preview-range" t-esc="cf.ranges"/>
  </div>
  <div class="o-cf-delete">
    <div class="o-cf-delete-button" t-on-click.stop="deleteConditionalFormat(cf)" aria-label="Remove rule">
    <t t-raw="trashIcon"/>
    </div>
  </div>
</div>`;
    const TEMPLATE$l = xml$n /* xml */ `
  <div class="o-cf">
    <t t-if="state.mode === 'list'">
      <div class="o-cf-preview-list" >
        <div t-on-click="editConditionalFormat(cf)" t-foreach="conditionalFormats" t-as="cf" t-key="cf.id">
            <t t-call="${PREVIEW_TEMPLATE}"/>
        </div>
      </div>
      <div class="btn btn-link o-cf-add" t-on-click.prevent.stop="addConditionalFormat">
        <t t-esc="'+ ' + env._t('${conditionalFormattingTerms.newRule}')"/>
      </div>
    </t>
    <t t-if="state.mode === 'edit' || state.mode === 'add'" t-key="state.currentCF.id">
        <div class="o-cf-ruleEditor">
            <div class="o-section o-cf-range">
              <div class="o-section-title">Apply to range</div>
              <div class="o-selection-cf">
                <SelectionInput
                  ranges="state.currentCF.ranges"
                  class="o-range"
                  isInvalid="isRangeValid"
                  t-on-selection-changed="onRangesChanged"
                  required="true"/>
              </div>
              <div class="o-section-title" t-esc="env._t('${conditionalFormattingTerms.CF_TITLE}')"></div>
              <div class="o_field_radio o_horizontal o_field_widget o-cf-type-selector">
                <div class="custom-control custom-radio o_cf_radio_item" t-on-click="changeRuleType('CellIsRule')">
                  <input class="custom-control-input o_radio_input" t-attf-checked="{{state.currentCFType === 'CellIsRule'}}" type="radio" id="cellIsRule" name="ruleType" value="CellIsRule"/>
                  <label for="cellIsRule" class="custom-control-label o_form_label">
                    <t t-esc="env._t('${conditionalFormattingTerms.SingleColor}')"/>
                  </label>
                </div>
                <div class="custom-control custom-radio o_cf_radio_item" t-on-click="changeRuleType('ColorScaleRule')">
                  <input class="custom-control-input o_radio_input" t-attf-checked="{{state.currentCFType === 'ColorScaleRule'}}" type="radio" id="colorScaleRule" name="ruleType" value="ColorScaleRule"/>
                  <label for="colorScaleRule" class="custom-control-label o_form_label">
                  <t t-esc="env._t('${conditionalFormattingTerms.ColorScale}')"/>
                  </label>
                </div>

                <div class="custom-control custom-radio o_cf_radio_item" t-on-click="changeRuleType('IconSetRule')">
                  <input class="custom-control-input o_radio_input" t-attf-checked="{{state.currentCFType === 'IconSetRule'}}" type="radio" id="iconSetRule" name="ruleType" value="IconSetRule"/>
                  <label for="iconSetRule" class="custom-control-label o_form_label">
                  <t t-esc="env._t('${conditionalFormattingTerms.IconSet}')"/>
                  </label>
                </div>
              </div>
            </div>
            <div class="o-section o-cf-editor">
              <t t-component="editors[state.currentCFType]"
                 t-ref="editorRef"
                 errors="state.errors"
                 t-key="state.currentCF.id + state.currentCFType"
                 rule="state.rules[state.currentCFType]"/>
              <div class="o-sidePanelButtons">
                <button t-on-click="switchToList" class="o-sidePanelButton o-cf-cancel" t-esc="env._t('${conditionalFormattingTerms.CANCEL}')"></button>
                <button t-on-click="saveConditionalFormat" class="o-sidePanelButton o-cf-save" t-esc="env._t('${conditionalFormattingTerms.SAVE}')"></button>
              </div>
            </div>
            <div class="o-section">
              <div class="o-cf-error" t-foreach="state.errors || []" t-as="error">
                <t t-esc="errorMessage(error)"/>
              </div>
            </div>
        </div>
    </t>
  </div>`;
    const CSS$j = css$l /* scss */ `
  label {
    vertical-align: middle;
  }
  .o_cf_radio_item {
    margin-right: 10%;
  }
  .radio input:checked {
    color: #e9ecef;
    border-color: #00a09d;
    background-color: #00a09d;
  }
  .o-cf-editor {
    border-bottom: solid;
    border-color: lightgrey;
  }
  .o-cf {
    .o-cf-type-selector {
      *,
      ::after,
      ::before {
        box-sizing: border-box;
      }
      margin-top: 10px;
      display: flex;
    }
    .o-cf-title-text {
      color: gray;
      font-size: 12px;
      line-height: 14px;
      margin: 8px 0 4px 0;
    }
    .o-cf-title-text:first-child {
      margin-top: 0px;
    }
    .o-cf-preview {
      background-color: #fff;
      border-bottom: 1px solid #ccc;
      cursor: pointer;
      display: flex;
      height: 60px;
      padding: 10px;
      position: relative;
      &:hover {
        background-color: rgba(0, 0, 0, 0.08);
      }
      &:not(:hover) .o-cf-delete-button {
        display: none;
      }
      .o-cf-preview-image {
        border: 1px solid lightgrey;
        height: 50px;
        line-height: 50px;
        margin-right: 15px;
        position: absolute;
        text-align: center;
        width: 50px;
      }
      .o-cf-preview-icon {
        border: 1px solid lightgrey;
        position: absolute;
        height: 50px;
        line-height: 50px;
        margin-right: 15px;
        display: flex;
        justify-content: space-around;
        align-items: center;
      }
      .o-cf-preview-description {
        left: 65px;
        margin-bottom: auto;
        margin-right: 8px;
        margin-top: auto;
        position: relative;
        width: 142px;
        .o-cf-preview-description-rule {
          margin-bottom: 4px;
          overflow: hidden;
        }
        .o-cf-preview-description-values {
          overflow: hidden;
        }
        .o-cf-preview-range {
          text-overflow: ellipsis;
          font-size: 12px;
          overflow: hidden;
        }
      }
      .o-cf-delete {
        color: dimgrey;
        left: 90%;
        top: 39%;
        position: absolute;
      }
    }
    .o-cf-ruleEditor {
      font-size: 12px;
      line-height: 1.5;
      .o-selection-cf {
        margin-bottom: 3%;
      }
      .o-dropdown {
        position: relative;
        .o-dropdown-content {
          position: absolute;
          top: calc(100% + 5px);
          left: 0;
          z-index: 10;
          box-shadow: 1px 2px 5px 2px rgba(51, 51, 51, 0.15);
          background-color: #f6f6f6;

          .o-dropdown-item {
            padding: 7px 10px;
          }
          .o-dropdown-item:hover {
            background-color: rgba(0, 0, 0, 0.08);
          }
          .o-dropdown-line {
            display: flex;
            padding: 3px 6px;
            .o-line-item {
              width: 16px;
              height: 16px;
              margin: 1px 3px;
              &:hover {
                background-color: rgba(0, 0, 0, 0.08);
              }
            }
          }
        }
      }

      .o-tools {
        color: #333;
        font-size: 13px;
        cursor: default;
        display: flex;

        .o-tool {
          display: flex;
          align-items: center;
          margin: 2px;
          padding: 0 3px;
          border-radius: 2px;
        }

        .o-tool.active,
        .o-tool:not(.o-disabled):hover {
          background-color: rgba(0, 0, 0, 0.08);
        }

        .o-with-color > span {
          border-bottom: 4px solid;
          height: 16px;
          margin-top: 2px;
        }
        .o-with-color {
          .o-line-item:hover {
            outline: 1px solid gray;
          }
        }
        .o-border {
          .o-line-item {
            padding: 4px;
            margin: 1px;
          }
        }
      }
      .o-cell-content {
        font-size: 12px;
        font-weight: 500;
        padding: 0 12px;
        margin: 0;
        line-height: 35px;
      }
    }
    .o-cf-add {
      font-size: 14px;
      padding: 20px 24px 11px 24px;
      height: 44px;
      cursor: pointer;
      text-decoration: none;
    }
    .o-cf-add:hover {
      color: #003a39;
      text-decoration: none;
    }
    .o-cf-error {
      color: red;
      margin-top: 10px;
    }
  }
`;
    class ConditionalFormattingPanel extends Component$k {
        constructor(parent, props) {
            super(parent, props);
            this.icons = ICONS;
            this.trashIcon = TRASH;
            //@ts-ignore --> used in XML template
            this.cellIsOperators = cellIsOperators;
            this.editor = useRef$8("editorRef");
            this.getters = this.env.getters;
            this.state = useState$g({
                mode: "list",
                rules: {},
                errors: [],
            });
            this.editors = {
                CellIsRule: CellIsRuleEditor,
                ColorScaleRule: ColorScaleRuleEditor,
                IconSetRule: IconSetRuleEditor,
            };
            this.activeSheetId = this.getters.getActiveSheetId();
            const rules = this.getters.getRulesSelection(this.activeSheetId, props.selection || []);
            if (rules.length === 1) {
                const cf = this.conditionalFormats.find((c) => c.id === rules[0]);
                if (cf) {
                    this.editConditionalFormat(cf);
                }
            }
        }
        get conditionalFormats() {
            return this.getters.getConditionalFormats(this.getters.getActiveSheetId());
        }
        get isRangeValid() {
            return this.state.errors.includes(19 /* EmptyRange */);
        }
        errorMessage(error) {
            return this.env._t(conditionalFormattingTerms.Errors[error] || conditionalFormattingTerms.Errors.unexpected);
        }
        async willUpdateProps(nextProps) {
            const newActiveSheetId = this.getters.getActiveSheetId();
            if (newActiveSheetId !== this.activeSheetId) {
                this.activeSheetId = newActiveSheetId;
                this.switchToList();
            }
            else if (nextProps.selection !== this.props.selection) {
                const sheetId = this.getters.getActiveSheetId();
                const rules = this.getters.getRulesSelection(sheetId, nextProps.selection || []);
                if (rules.length === 1) {
                    const cf = this.conditionalFormats.find((c) => c.id === rules[0]);
                    if (cf) {
                        this.editConditionalFormat(cf);
                    }
                }
                else {
                    this.switchToList();
                }
            }
        }
        /**
         * Switch to the list view
         */
        switchToList() {
            this.state.mode = "list";
            this.state.currentCF = undefined;
            this.state.currentCFType = undefined;
            this.state.errors = [];
            this.state.rules = {};
        }
        getStyle(rule) {
            if (rule.type === "CellIsRule") {
                const fontWeight = rule.style.bold ? "bold" : "normal";
                const fontDecoration = getTextDecoration(rule.style);
                const fontStyle = rule.style.italic ? "italic" : "normal";
                const color = rule.style.textColor || "none";
                const backgroundColor = rule.style.fillColor || "none";
                return `font-weight:${fontWeight};
               text-decoration:${fontDecoration};
               font-style:${fontStyle};
               color:${color};
               background-color:${backgroundColor};`;
            }
            else if (rule.type === "ColorScaleRule") {
                const minColor = colorNumberString(rule.minimum.color);
                const midColor = rule.midpoint ? colorNumberString(rule.midpoint.color) : null;
                const maxColor = colorNumberString(rule.maximum.color);
                const baseString = "background-image: linear-gradient(to right, #";
                return midColor
                    ? baseString + minColor + ", #" + midColor + ", #" + maxColor + ")"
                    : baseString + minColor + ", #" + maxColor + ")";
            }
            return "";
        }
        getDescription(cf) {
            switch (cf.rule.type) {
                case "CellIsRule":
                    return cellIsOperators[cf.rule.operator];
                case "ColorScaleRule":
                    return this.env._t("Color scale");
                case "IconSetRule":
                    return this.env._t("Icon Set");
                default:
                    return "";
            }
        }
        saveConditionalFormat() {
            if (this.state.currentCF) {
                const invalidRanges = this.state.currentCF.ranges.some((xc) => !xc.match(rangeReference));
                if (invalidRanges) {
                    this.state.errors = [20 /* InvalidRange */];
                    return;
                }
                const result = this.env.dispatch("ADD_CONDITIONAL_FORMAT", {
                    cf: {
                        rule: this.getEditorRule(),
                        id: this.state.mode === "edit" ? this.state.currentCF.id : this.env.uuidGenerator.uuidv4(),
                    },
                    target: this.state.currentCF.ranges.map(toZone),
                    sheetId: this.getters.getActiveSheetId(),
                });
                if (!result.isSuccessful) {
                    this.state.errors = result.reasons;
                }
                else {
                    this.switchToList();
                }
            }
        }
        /**
         * Get the rule currently edited with the editor
         */
        getEditorRule() {
            return this.editor.comp.getRule();
        }
        /**
         * Create a new CF, a CellIsRule by default
         */
        addConditionalFormat() {
            this.state.mode = "add";
            this.state.currentCFType = "CellIsRule";
            this.state.rules["CellIsRule"] = CellIsRuleEditor.getDefaultRule();
            this.state.currentCF = {
                id: this.env.uuidGenerator.uuidv4(),
                ranges: this.getters
                    .getSelectedZones()
                    .map((zone) => this.getters.zoneToXC(this.getters.getActiveSheetId(), zone)),
            };
        }
        /**
         * Delete a CF
         */
        deleteConditionalFormat(cf) {
            this.env.dispatch("REMOVE_CONDITIONAL_FORMAT", {
                id: cf.id,
                sheetId: this.getters.getActiveSheetId(),
            });
        }
        /**
         * Edit an existing CF
         */
        editConditionalFormat(cf) {
            this.state.mode = "edit";
            this.state.currentCF = cf;
            this.state.currentCFType =
                cf.rule.type === "CellIsRule"
                    ? "CellIsRule"
                    : cf.rule.type === "ColorScaleRule"
                        ? "ColorScaleRule"
                        : "IconSetRule";
            this.state.rules[cf.rule.type] = cf.rule;
        }
        changeRuleType(ruleType) {
            if (this.state.currentCFType === ruleType) {
                return;
            }
            if (this.state.currentCFType) {
                this.state.rules[this.state.currentCFType] = this.getEditorRule();
            }
            this.state.errors = [];
            this.state.currentCFType = ruleType;
            if (!(ruleType in this.state.rules)) {
                switch (ruleType) {
                    case "CellIsRule":
                        this.state.rules["CellIsRule"] = CellIsRuleEditor.getDefaultRule();
                        break;
                    case "ColorScaleRule":
                        this.state.rules["ColorScaleRule"] = ColorScaleRuleEditor.getDefaultRule();
                        break;
                    case "IconSetRule":
                        this.state.rules["IconSetRule"] = IconSetRuleEditor.getDefaultRule();
                        break;
                }
            }
        }
        onRangesChanged({ detail }) {
            if (this.state.currentCF) {
                this.state.currentCF.ranges = detail.ranges;
            }
        }
    }
    ConditionalFormattingPanel.template = TEMPLATE$l;
    ConditionalFormattingPanel.style = CSS$j;
    ConditionalFormattingPanel.components = { CellIsRuleEditor, ColorScaleRuleEditor, IconSetRuleEditor, SelectionInput };

    const { Component: Component$j, useState: useState$f } = owl__namespace;
    const { xml: xml$m, css: css$k } = owl__namespace.tags;
    const TEMPLATE$k = xml$m /* xml */ `
<div class="o-find-and-replace" tabindex="0" t-on-focusin="onFocusSidePanel">
  <div class="o-section">
    <div class="o-section-title" t-esc="env._t('${FindAndReplaceTerms.Search}')"/>
    <div class="o-input-search-container">
      <input type="text" class="o-input o-input-with-count" t-on-input="onInput" t-on-keydown="onKeydownSearch"/>
      <div class="o-input-count" t-if="hasSearchResult">
        <t t-esc="env.getters.getCurrentSelectedMatchIndex()+1"/>
        /
        <t t-esc="env.getters.getSearchMatches().length"/>
      </div>
    </div>
    <div>
      <div class="o-far-item">
        <label class="o-far-checkbox">
          <input t-model="state.searchOptions.matchCase" t-on-change="updateSearch()" class="o-far-input" type="checkbox"/>
          <span class="o-far-label"><t t-esc="env._t('${FindAndReplaceTerms.MatchCase}')"/></span>
        </label>
      </div>
      <div class="o-far-item">
        <label class="o-far-checkbox">
          <input t-model="state.searchOptions.exactMatch" t-on-change="updateSearch()" class="o-far-input" type="checkbox"/>
          <span class="o-far-label"><t t-esc="env._t('${FindAndReplaceTerms.ExactMatch}')"/></span>
        </label>
      </div>
      <div class="o-far-item">
        <label class="o-far-checkbox">
          <input t-model="state.searchOptions.searchFormulas" t-on-change="searchFormulas" class="o-far-input" type="checkbox" />
          <span class="o-far-label"><t t-esc="env._t('${FindAndReplaceTerms.SearchFormulas}')"/></span>
        </label>
      </div>
    </div>
  </div>
  <div class="o-sidePanelButtons">
    <button t-att-disabled="!hasSearchResult"
            t-on-click="onSelectPreviousCell"
            class="o-sidePanelButton"
            t-esc="env._t('${FindAndReplaceTerms.Previous}')"/>
    <button t-att-disabled="!hasSearchResult"
            t-on-click="onSelectNextCell"
            class="o-sidePanelButton"
            t-esc="env._t('${FindAndReplaceTerms.Next}')"/>
  </div>
  <div class="o-section" t-if="!getters.isReadonly()">
    <div t-esc="env._t('${FindAndReplaceTerms.Replace}')" class="o-section-title"/>
    <div class="o-input-search-container">
      <input type="text" class="o-input o-input-without-count" t-model="state.replaceWith" t-on-keydown="onKeydownReplace"/>
    </div>

    <div class="o-far-item">
      <label class="o-far-checkbox">
        <input class="o-far-input" t-att-disabled="state.searchOptions.searchFormulas" type="checkbox"
        t-model="state.replaceOptions.modifyFormulas"/>
        <span class="o-far-label"><t t-esc="env._t('${FindAndReplaceTerms.ReplaceFormulas}')"/></span>
      </label>
    </div>
  </div>

  <div class="o-sidePanelButtons" t-if="!getters.isReadonly()">
    <button t-att-disabled="env.getters.getCurrentSelectedMatchIndex() === null" t-on-click="replace"
            class="o-sidePanelButton" t-esc="env._t('${FindAndReplaceTerms.Replace}')"/>
    <button t-att-disabled="env.getters.getCurrentSelectedMatchIndex() === null" t-on-click="replaceAll"
            class="o-sidePanelButton" t-esc="env._t('${FindAndReplaceTerms.ReplaceAll}')"/>
  </div>

</div>
`;
    const CSS$i = css$k /* scss */ `
  .o-find-and-replace {
    .o-far-item {
      display: block;
      .o-far-checkbox {
        display: inline-block;
        .o-far-input {
          vertical-align: middle;
        }
        .o-far-label {
          position: relative;
          top: 1.5px;
          padding-left: 4px;
        }
      }
    }
    outline: none;
    height: 100%;
    .o-input-search-container {
      display: flex;
      .o-input-with-count {
        flex-grow: 1;
        width: auto;
      }
      .o-input-without-count {
        width: 100%;
      }
      .o-input-count {
        width: fit-content;
        padding: 4 0 4 4;
      }
    }
  }
`;
    class FindAndReplacePanel extends Component$j {
        constructor() {
            super(...arguments);
            this.getters = this.env.getters;
            this.state = useState$f(this.initialState());
        }
        get hasSearchResult() {
            return this.env.getters.getCurrentSelectedMatchIndex() !== null;
        }
        mounted() {
            this.focusInput();
        }
        async willUnmount() {
            this.env.dispatch("CLEAR_SEARCH");
        }
        onInput(ev) {
            this.state.toSearch = ev.target.value;
            this.debouncedUpdateSearch();
        }
        onKeydownSearch(ev) {
            if (ev.key === "Enter") {
                ev.preventDefault();
                this.onSelectNextCell();
            }
        }
        onKeydownReplace(ev) {
            if (ev.key === "Enter") {
                ev.preventDefault();
                this.replace();
            }
        }
        onFocusSidePanel() {
            this.state.searchOptions.searchFormulas = this.getters.shouldShowFormulas();
            this.state.replaceOptions.modifyFormulas = this.state.searchOptions.searchFormulas
                ? this.state.searchOptions.searchFormulas
                : this.state.replaceOptions.modifyFormulas;
            this.env.dispatch("REFRESH_SEARCH");
        }
        searchFormulas() {
            this.env.dispatch("SET_FORMULA_VISIBILITY", { show: this.state.searchOptions.searchFormulas });
            this.state.replaceOptions.modifyFormulas = this.state.searchOptions.searchFormulas;
            this.updateSearch();
        }
        onSelectPreviousCell() {
            this.env.dispatch("SELECT_SEARCH_PREVIOUS_MATCH");
        }
        onSelectNextCell() {
            this.env.dispatch("SELECT_SEARCH_NEXT_MATCH");
        }
        updateSearch() {
            if (this.state.toSearch) {
                this.env.dispatch("UPDATE_SEARCH", {
                    toSearch: this.state.toSearch,
                    searchOptions: this.state.searchOptions,
                });
            }
        }
        debouncedUpdateSearch() {
            clearTimeout(this.inDebounce);
            this.inDebounce = setTimeout(() => this.updateSearch.call(this), 400);
        }
        replace() {
            this.env.dispatch("REPLACE_SEARCH", {
                replaceWith: this.state.replaceWith,
                replaceOptions: this.state.replaceOptions,
            });
        }
        replaceAll() {
            this.env.dispatch("REPLACE_ALL_SEARCH", {
                replaceWith: this.state.replaceWith,
                replaceOptions: this.state.replaceOptions,
            });
        }
        // ---------------------------------------------------------------------------
        // Private
        // ---------------------------------------------------------------------------
        focusInput() {
            const input = this.el.querySelector(`input`);
            if (input) {
                input.focus();
            }
        }
        initialState() {
            return {
                toSearch: "",
                replaceWith: "",
                searchOptions: {
                    matchCase: false,
                    exactMatch: false,
                    searchFormulas: false,
                },
                replaceOptions: {
                    modifyFormulas: false,
                },
            };
        }
    }
    FindAndReplacePanel.template = TEMPLATE$k;
    FindAndReplacePanel.style = CSS$i;

    const sidePanelRegistry = new Registry();
    sidePanelRegistry.add("ConditionalFormatting", {
        title: _lt("Conditional formatting"),
        Body: ConditionalFormattingPanel,
    });
    sidePanelRegistry.add("ChartPanel", {
        title: _lt("Chart"),
        Body: ChartPanel,
    });
    sidePanelRegistry.add("FindAndReplace", {
        title: _lt("Find and Replace"),
        Body: FindAndReplacePanel,
    });

    const topbarComponentRegistry = new Registry();

    /**
     * UI plugins handle any transient data required to display a spreadsheet.
     * They can draw on the grid canvas.
     */
    class UIPlugin extends BasePlugin {
        constructor(getters, state, dispatch, config) {
            super(state, dispatch, config);
            this.getters = getters;
            this.ui = config;
        }
        // ---------------------------------------------------------------------------
        // Grid rendering
        // ---------------------------------------------------------------------------
        drawGrid(ctx, layer) { }
    }
    UIPlugin.layers = [];

    /**
     * This plugin manage the autofill.
     *
     * The way it works is the next one:
     * For each line (row if the direction is left/right, col otherwise), we create
     * a "AutofillGenerator" object which is used to compute the cells to
     * autofill.
     *
     * When we need to autofill a cell, we compute the origin cell in the source.
     *  EX: from A1:A2, autofill A3->A6.
     *      Target | Origin cell
     *        A3   |   A1
     *        A4   |   A2
     *        A5   |   A1
     *        A6   |   A2
     * When we have the origin, we take the associated cell in the AutofillGenerator
     * and we apply the modifier (AutofillModifier) associated to the content of the
     * cell.
     */
    /**
     * This class is used to generate the next values to autofill.
     * It's done from a selection (the source) and describe how the next values
     * should be computed.
     */
    class AutofillGenerator {
        constructor(cells, getters, direction) {
            this.index = 0;
            this.cells = cells;
            this.getters = getters;
            this.direction = direction;
        }
        /**
         * Get the next value to autofill
         */
        next() {
            const genCell = this.cells[this.index++ % this.cells.length];
            const rule = genCell.rule;
            const { cellData, tooltip } = autofillModifiersRegistry
                .get(rule.type)
                .apply(rule, genCell.data, this.getters, this.direction);
            return {
                cellData,
                tooltip,
                origin: {
                    col: genCell.data.col,
                    row: genCell.data.row,
                },
            };
        }
    }
    /**
     * Autofill Plugin
     *
     */
    class AutofillPlugin extends UIPlugin {
        constructor() {
            super(...arguments);
            this.lastCellSelected = {};
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        allowDispatch(cmd) {
            switch (cmd.type) {
                case "AUTOFILL_SELECT":
                    const sheetId = this.getters.getActiveSheetId();
                    this.lastCellSelected.col =
                        cmd.col === -1
                            ? this.lastCellSelected.col
                            : clip(cmd.col, 0, this.getters.getSheet(sheetId).cols.length);
                    this.lastCellSelected.row =
                        cmd.row === -1
                            ? this.lastCellSelected.row
                            : clip(cmd.row, 0, this.getters.getSheet(sheetId).rows.length);
                    if (this.lastCellSelected.col !== undefined && this.lastCellSelected.row !== undefined) {
                        return 0 /* Success */;
                    }
                    return 28 /* InvalidAutofillSelection */;
                case "AUTOFILL_AUTO":
                    const zone = this.getters.getSelectedZone();
                    return zone.top === zone.bottom
                        ? 0 /* Success */
                        : 1 /* CancelledForUnknownReason */;
            }
            return 0 /* Success */;
        }
        handle(cmd) {
            switch (cmd.type) {
                case "AUTOFILL":
                    this.autofill(true);
                    break;
                case "AUTOFILL_SELECT":
                    this.select(cmd.col, cmd.row);
                    break;
                case "AUTOFILL_AUTO":
                    this.autofillAuto();
                    break;
                case "AUTOFILL_CELL":
                    this.autoFillMerge(cmd.originCol, cmd.originRow, cmd.col, cmd.row);
                    const sheetId = this.getters.getActiveSheetId();
                    this.dispatch("UPDATE_CELL", {
                        sheetId,
                        col: cmd.col,
                        row: cmd.row,
                        style: cmd.style || null,
                        content: cmd.content || "",
                        format: cmd.format || "",
                    });
                    this.dispatch("SET_BORDER", {
                        sheetId,
                        col: cmd.col,
                        row: cmd.row,
                        border: cmd.border,
                    });
            }
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        getAutofillTooltip() {
            return this.tooltip;
        }
        // ---------------------------------------------------------------------------
        // Private methods
        // ---------------------------------------------------------------------------
        /**
         * Autofill the autofillZone from the current selection
         * @param apply Flag set to true to apply the autofill in the model. It's
         *              useful to set it to false when we need to fill the tooltip
         */
        autofill(apply) {
            if (!this.autofillZone || this.direction === undefined) {
                this.tooltip = undefined;
                return;
            }
            const source = this.getters.getSelectedZone();
            const target = this.autofillZone;
            switch (this.direction) {
                case 1 /* DOWN */:
                    for (let col = source.left; col <= source.right; col++) {
                        const xcs = [];
                        for (let row = source.top; row <= source.bottom; row++) {
                            xcs.push(toXC(col, row));
                        }
                        const generator = this.createGenerator(xcs);
                        for (let row = target.top; row <= target.bottom; row++) {
                            this.computeNewCell(generator, col, row, apply);
                        }
                    }
                    break;
                case 0 /* UP */:
                    for (let col = source.left; col <= source.right; col++) {
                        const xcs = [];
                        for (let row = source.bottom; row >= source.top; row--) {
                            xcs.push(toXC(col, row));
                        }
                        const generator = this.createGenerator(xcs);
                        for (let row = target.bottom; row >= target.top; row--) {
                            this.computeNewCell(generator, col, row, apply);
                        }
                    }
                    break;
                case 2 /* LEFT */:
                    for (let row = source.top; row <= source.bottom; row++) {
                        const xcs = [];
                        for (let col = source.right; col >= source.left; col--) {
                            xcs.push(toXC(col, row));
                        }
                        const generator = this.createGenerator(xcs);
                        for (let col = target.right; col >= target.left; col--) {
                            this.computeNewCell(generator, col, row, apply);
                        }
                    }
                    break;
                case 3 /* RIGHT */:
                    for (let row = source.top; row <= source.bottom; row++) {
                        const xcs = [];
                        for (let col = source.left; col <= source.right; col++) {
                            xcs.push(toXC(col, row));
                        }
                        const generator = this.createGenerator(xcs);
                        for (let col = target.left; col <= target.right; col++) {
                            this.computeNewCell(generator, col, row, apply);
                        }
                    }
                    break;
            }
            if (apply) {
                const zone = union(this.getters.getSelectedZone(), this.autofillZone);
                this.autofillZone = undefined;
                this.lastCellSelected = {};
                this.direction = undefined;
                this.tooltip = undefined;
                this.dispatch("SET_SELECTION", {
                    zones: [zone],
                    anchor: [zone.left, zone.top],
                    anchorZone: zone,
                });
            }
        }
        /**
         * Select a cell which becomes the last cell of the autofillZone
         */
        select(col, row) {
            const source = this.getters.getSelectedZone();
            if (isInside(col, row, source)) {
                this.autofillZone = undefined;
                return;
            }
            this.direction = this.getDirection(col, row);
            switch (this.direction) {
                case 0 /* UP */:
                    this.saveZone(row, source.top - 1, source.left, source.right);
                    break;
                case 1 /* DOWN */:
                    this.saveZone(source.bottom + 1, row, source.left, source.right);
                    break;
                case 2 /* LEFT */:
                    this.saveZone(source.top, source.bottom, col, source.left - 1);
                    break;
                case 3 /* RIGHT */:
                    this.saveZone(source.top, source.bottom, source.right + 1, col);
                    break;
            }
            this.autofill(false);
        }
        /**
         * Computes the autofillZone to autofill when the user double click on the
         * autofiller
         */
        autofillAuto() {
            const zone = this.getters.getSelectedZone();
            const sheetId = this.getters.getActiveSheetId();
            let col = zone.left;
            let row = zone.bottom;
            if (col > 0) {
                let left = this.getters.getCell(sheetId, col - 1, row);
                while (left && !left.isEmpty()) {
                    row += 1;
                    left = this.getters.getCell(sheetId, col - 1, row);
                }
            }
            if (row === zone.bottom) {
                col = zone.right;
                if (col <= this.getters.getActiveSheet().cols.length) {
                    let right = this.getters.getCell(sheetId, col + 1, row);
                    while (right && !right.isEmpty()) {
                        row += 1;
                        right = this.getters.getCell(sheetId, col + 1, row);
                    }
                }
            }
            if (row !== zone.bottom) {
                this.select(zone.left, row - 1);
                this.autofill(true);
            }
        }
        /**
         * Generate the next cell
         */
        computeNewCell(generator, col, row, apply) {
            const { cellData, tooltip, origin } = generator.next();
            const { content, style, border, format } = cellData;
            this.tooltip = tooltip;
            if (apply) {
                this.dispatch("AUTOFILL_CELL", {
                    originCol: origin.col,
                    originRow: origin.row,
                    col,
                    row,
                    content,
                    style,
                    border,
                    format,
                });
            }
        }
        /**
         * Get the rule associated to the current cell
         */
        getRule(cell, cells) {
            const rules = autofillRulesRegistry.getAll().sort((a, b) => a.sequence - b.sequence);
            const rule = rules.find((rule) => rule.condition(cell, cells));
            return rule && rule.generateRule(cell, cells);
        }
        /**
         * Create the generator to be able to autofill the next cells.
         */
        createGenerator(source) {
            const nextCells = [];
            const cellsData = [];
            const sheetId = this.getters.getActiveSheetId();
            for (let xc of source) {
                const [col, row] = toCartesian(xc);
                const cell = this.getters.getCell(sheetId, col, row);
                cellsData.push({
                    col,
                    row,
                    cell,
                    sheetId,
                });
            }
            const cells = cellsData.map((cellData) => cellData.cell);
            for (let cellData of cellsData) {
                let rule = { type: "COPY_MODIFIER" };
                if (cellData && cellData.cell) {
                    const newRule = this.getRule(cellData.cell, cells);
                    rule = newRule || rule;
                }
                const { sheetId, col, row } = cellData;
                const border = this.getters.getCellBorder(sheetId, col, row) || undefined;
                nextCells.push({
                    data: { ...cellData, border },
                    rule,
                });
            }
            return new AutofillGenerator(nextCells, this.getters, this.direction);
        }
        saveZone(top, bottom, left, right) {
            this.autofillZone = { top, bottom, left, right };
        }
        /**
         * Compute the direction of the autofill from the last selected zone and
         * a given cell (col, row)
         */
        getDirection(col, row) {
            const source = this.getters.getSelectedZone();
            const position = {
                up: { number: source.top - row, value: 0 /* UP */ },
                down: { number: row - source.bottom, value: 1 /* DOWN */ },
                left: { number: source.left - col, value: 2 /* LEFT */ },
                right: { number: col - source.right, value: 3 /* RIGHT */ },
            };
            if (Object.values(position)
                .map((x) => (x.number > 0 ? 1 : 0))
                .reduce((acc, value) => acc + value) === 1) {
                return Object.values(position).find((x) => (x.number > 0 ? 1 : 0)).value;
            }
            const first = position.up.number > 0 ? "up" : "down";
            const second = position.left.number > 0 ? "left" : "right";
            return Math.abs(position[first].number) >= Math.abs(position[second].number)
                ? position[first].value
                : position[second].value;
        }
        autoFillMerge(originCol, originRow, col, row) {
            const activeSheet = this.getters.getActiveSheet();
            if (this.getters.isInMerge(activeSheet.id, col, row) &&
                !this.getters.isInMerge(activeSheet.id, originCol, originRow)) {
                const zone = this.getters.getMerge(activeSheet.id, col, row);
                if (zone) {
                    this.dispatch("REMOVE_MERGE", {
                        sheetId: activeSheet.id,
                        target: [zone],
                    });
                }
            }
            const originMerge = this.getters.getMerge(activeSheet.id, originCol, originRow);
            if ((originMerge === null || originMerge === void 0 ? void 0 : originMerge.topLeft.col) === originCol && (originMerge === null || originMerge === void 0 ? void 0 : originMerge.topLeft.row) === originRow) {
                this.dispatch("ADD_MERGE", {
                    sheetId: activeSheet.id,
                    target: [
                        {
                            top: row,
                            bottom: row + originMerge.bottom - originMerge.top,
                            left: col,
                            right: col + originMerge.right - originMerge.left,
                        },
                    ],
                });
            }
        }
        // ---------------------------------------------------------------------------
        // Grid rendering
        // ---------------------------------------------------------------------------
        drawGrid(renderingContext) {
            if (!this.autofillZone) {
                return;
            }
            const { viewport, ctx, thinLineWidth } = renderingContext;
            const [x, y, width, height] = this.getters.getRect(this.autofillZone, viewport);
            if (width > 0 && height > 0) {
                ctx.strokeStyle = "black";
                ctx.lineWidth = thinLineWidth;
                ctx.setLineDash([3]);
                ctx.strokeRect(x, y, width, height);
                ctx.setLineDash([]);
            }
        }
    }
    AutofillPlugin.layers = [6 /* Autofill */];
    AutofillPlugin.getters = ["getAutofillTooltip"];
    AutofillPlugin.modes = ["normal"];

    class AutomaticSumPlugin extends UIPlugin {
        handle(cmd) {
            switch (cmd.type) {
                case "SUM_SELECTION":
                    const sheetId = this.getters.getActiveSheetId();
                    const { zones, anchor } = this.getters.getSelection();
                    for (const zone of zones) {
                        const sums = this.getAutomaticSums(sheetId, zone, anchor);
                        this.dispatchCellUpdates(sheetId, sums);
                    }
                    break;
            }
        }
        getAutomaticSums(sheetId, zone, anchor) {
            return this.shouldFindData(sheetId, zone)
                ? this.sumAdjacentData(sheetId, zone, anchor)
                : this.sumData(sheetId, zone);
        }
        // ---------------------------------------------------------------------------
        // Private methods
        // ---------------------------------------------------------------------------
        sumData(sheetId, zone) {
            const dimensions = this.dimensionsToSum(sheetId, zone);
            const sums = this.sumDimensions(sheetId, zone, dimensions).filter(({ zone }) => !this.getters.isEmpty(sheetId, zone));
            if (dimensions.has("ROW") && dimensions.has("COL")) {
                sums.push(this.sumTotal(zone));
            }
            return sums;
        }
        sumAdjacentData(sheetId, zone, anchor) {
            const [col, row] = isInside(anchor[0], anchor[1], zone) ? anchor : [zone.left, zone.top];
            const dataZone = this.findAdjacentData(sheetId, col, row);
            if (!dataZone) {
                return [];
            }
            if (this.getters.isSingleCellOrMerge(sheetId, zone) ||
                isOneDimensional(union(dataZone, zone))) {
                return [{ position: [col, row], zone: dataZone }];
            }
            else {
                return this.sumDimensions(sheetId, union(dataZone, zone), this.transpose(this.dimensionsToSum(sheetId, zone)));
            }
        }
        /**
         * Find a zone to automatically sum a column or row of numbers.
         *
         * We first decide which direction will be summed (column or row).
         * Here is the strategy:
         *  1. If the left cell is a number and the top cell is not: choose horizontal
         *  2. Try to find a valid vertical zone. If it's valid: choose vertical
         *  3. Try to find a valid horizontal zone. If it's valid: choose horizontal
         *  4. Otherwise, no zone is returned
         *
         * Now, how to find a valid zone?
         * The zone starts directly above or on the left of the starting point
         * (depending on the direction).
         * The zone ends where the first continuous sequence of numbers ends.
         * Empty or text cells can be part of the zone while no number has been found.
         * Other kind of cells (boolean, dates, etc.) are not valid in the zone and the
         * search stops immediately if one is found.
         *
         *  -------                                       -------
         * |   1   |                                     |   1   |
         *  -------                                       -------
         * |       |                                     |       |
         *  -------  <= end of the sequence, stop here    -------
         * |   2   |                                     |   2   |
         *  -------                                       -------
         * |   3   | <= start of the number sequence     |   3   |
         *  -------                                       -------
         * |       | <= ignored                          | FALSE | <= invalid, no zone is found
         *  -------                                       -------
         * |   A   | <= ignored                          |   A   | <= ignored
         *  -------                                       -------
         */
        findAdjacentData(sheetId, col, row) {
            const sheet = this.getters.getSheet(sheetId);
            const zone = this.findSuitableZoneToSum(sheet, ...this.getters.getMainCell(sheetId, col, row));
            if (zone) {
                return this.getters.expandZone(sheetId, zone);
            }
            return undefined;
        }
        /**
         * Return the zone to sum if a valid one is found.
         * @see getAutomaticSumZone
         */
        findSuitableZoneToSum(sheet, col, row) {
            const topCell = this.getters.getCell(sheet.id, col, row - 1);
            const leftCell = this.getters.getCell(sheet.id, col - 1, row);
            if (this.isNumber(leftCell) && !this.isNumber(topCell)) {
                return this.findHorizontalZone(sheet, col, row);
            }
            const verticalZone = this.findVerticalZone(sheet, col, row);
            if (this.isZoneValid(verticalZone)) {
                return verticalZone;
            }
            const horizontalZone = this.findHorizontalZone(sheet, col, row);
            if (this.isZoneValid(horizontalZone)) {
                return horizontalZone;
            }
            return undefined;
        }
        findVerticalZone(sheet, col, row) {
            const zone = {
                top: 0,
                bottom: row - 1,
                left: col,
                right: col,
            };
            const top = this.reduceZoneStart(sheet, zone, zone.bottom);
            return { ...zone, top };
        }
        findHorizontalZone(sheet, col, row) {
            const zone = {
                top: row,
                bottom: row,
                left: 0,
                right: col - 1,
            };
            const left = this.reduceZoneStart(sheet, zone, zone.right);
            return { ...zone, left };
        }
        /**
         * Reduces a column or row zone to a valid zone for the automatic sum.
         * @see getAutomaticSumZone
         * @param sheet
         * @param zone one dimensional zone (a single row or a single column). The zone is
         *             assumed to start at the beginning of the column (top=0) or the row (left=0)
         * @param end end index of the zone (`bottom` or `right` depending on the dimension)
         * @returns the starting position of the valid zone or Infinity if the zone is not valid.
         */
        reduceZoneStart(sheet, zone, end) {
            const cells = mapCellsInZone(zone, sheet, (cell) => cell, undefined).flat();
            const cellPositions = range(end, -1, -1);
            const invalidCells = cellPositions.filter((position) => { var _a; return cells[position] && !((_a = cells[position]) === null || _a === void 0 ? void 0 : _a.isAutoSummable); });
            const maxValidPosition = Math.max(...invalidCells);
            const numberSequences = groupConsecutive(cellPositions.filter((position) => this.isNumber(cells[position])));
            const firstSequence = numberSequences[0] || [];
            if (Math.max(...firstSequence) < maxValidPosition) {
                return Infinity;
            }
            return Math.min(...firstSequence);
        }
        shouldFindData(sheetId, zone) {
            return this.getters.isEmpty(sheetId, zone) || this.getters.isSingleCellOrMerge(sheetId, zone);
        }
        isNumber(cell) {
            var _a;
            return (cell === null || cell === void 0 ? void 0 : cell.evaluated.type) === CellValueType.number && !((_a = cell.format) === null || _a === void 0 ? void 0 : _a.match(DATETIME_FORMAT));
        }
        isZoneValid(zone) {
            return zone.bottom >= zone.top && zone.right >= zone.left;
        }
        lastColIsEmpty(sheetId, zone) {
            return this.getters.isEmpty(sheetId, { ...zone, left: zone.right });
        }
        lastRowIsEmpty(sheetId, zone) {
            return this.getters.isEmpty(sheetId, { ...zone, top: zone.bottom });
        }
        /**
         * Decides which dimensions (columns or rows) should be summed
         * based on its shape and what's inside the zone.
         */
        dimensionsToSum(sheetId, zone) {
            const dimensions = new Set();
            if (isOneDimensional(zone)) {
                dimensions.add(zoneToDimension(zone).width === 1 ? "COL" : "ROW");
                return dimensions;
            }
            if (this.lastColIsEmpty(sheetId, zone)) {
                dimensions.add("ROW");
            }
            if (this.lastRowIsEmpty(sheetId, zone)) {
                dimensions.add("COL");
            }
            if (dimensions.size === 0) {
                dimensions.add("COL");
            }
            return dimensions;
        }
        /**
         * Sum each column and/or row in the zone in the appropriate cells,
         * depending on the available space.
         */
        sumDimensions(sheetId, zone, dimensions) {
            return [
                ...(dimensions.has("COL") ? this.sumColumns(zone, sheetId) : []),
                ...(dimensions.has("ROW") ? this.sumRows(zone, sheetId) : []),
            ];
        }
        /**
         * Sum the total of the zone in the bottom right cell, assuming
         * the last row contains summed columns.
         */
        sumTotal(zone) {
            const { bottom, right } = zone;
            return { position: [right, bottom], zone: { ...zone, top: bottom, right: right - 1 } };
        }
        sumColumns(zone, sheetId) {
            const target = this.nextEmptyRow(sheetId, { ...zone, bottom: zone.bottom - 1 });
            zone = { ...zone, bottom: Math.min(zone.bottom, target.bottom - 1) };
            return positions(target).map((position) => ({
                position,
                zone: { ...zone, right: position[0], left: position[0] },
            }));
        }
        sumRows(zone, sheetId) {
            const target = this.nextEmptyCol(sheetId, { ...zone, right: zone.right - 1 });
            zone = { ...zone, right: Math.min(zone.right, target.right - 1) };
            return positions(target).map((position) => ({
                position,
                zone: { ...zone, top: position[1], bottom: position[1] },
            }));
        }
        dispatchCellUpdates(sheetId, sums) {
            for (const sum of sums) {
                const [col, row] = sum.position;
                this.dispatch("UPDATE_CELL", {
                    sheetId,
                    col,
                    row,
                    content: `=SUM(${this.getters.zoneToXC(sheetId, sum.zone)})`,
                });
            }
        }
        /**
         * Find the first row where all cells below the zone are empty.
         */
        nextEmptyRow(sheetId, zone) {
            let start = zone.bottom + 1;
            const { left, right } = zone;
            while (!this.getters.isEmpty(sheetId, { bottom: start, top: start, left, right })) {
                start++;
            }
            return {
                ...zone,
                top: start,
                bottom: start,
            };
        }
        /**
         * Find the first column where all cells right of the zone are empty.
         */
        nextEmptyCol(sheetId, zone) {
            let start = zone.right + 1;
            const { top, bottom } = zone;
            while (!this.getters.isEmpty(sheetId, { left: start, right: start, top, bottom })) {
                start++;
            }
            return {
                ...zone,
                left: start,
                right: start,
            };
        }
        /**
         * Transpose the given dimensions.
         * COL becomes ROW
         * ROW becomes COL
         */
        transpose(dimensions) {
            return new Set([...dimensions.values()].map((dimension) => (dimension === "COL" ? "ROW" : "COL")));
        }
    }
    AutomaticSumPlugin.getters = ["getAutomaticSums"];
    AutomaticSumPlugin.modes = ["normal", "headless"];

    /**
     * Clipboard Plugin
     *
     * This clipboard manages all cut/copy/paste interactions internal to the
     * application, and with the OS clipboard as well.
     */
    class ClipboardPlugin extends UIPlugin {
        constructor() {
            super(...arguments);
            this.status = "invisible";
            this._isPaintingFormat = false;
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        allowDispatch(cmd) {
            switch (cmd.type) {
                case "PASTE":
                    return this.isPasteAllowed(this.state, cmd.target, !!cmd.force);
                case "INSERT_CELL": {
                    const { cut, paste } = this.getInsertCellsTargets(cmd.zone, cmd.shiftDimension);
                    const state = this.getClipboardState(cut, "CUT");
                    return this.isPasteAllowed(state, paste, false);
                }
                case "DELETE_CELL": {
                    const { cut, paste } = this.getDeleteCellsTargets(cmd.zone, cmd.shiftDimension);
                    const state = this.getClipboardState(cut, "CUT");
                    return this.isPasteAllowed(state, paste, false);
                }
            }
            return 0 /* Success */;
        }
        handle(cmd) {
            var _a, _b;
            switch (cmd.type) {
                case "COPY":
                case "CUT":
                    this.state = this.getClipboardState(cmd.target, cmd.type);
                    this.status = "visible";
                    break;
                case "PASTE":
                    if (!this.state) {
                        break;
                    }
                    const pasteOption = cmd.pasteOption || (this._isPaintingFormat ? "onlyFormat" : undefined);
                    this._isPaintingFormat = false;
                    if (cmd.interactive) {
                        this.interactivePaste(this.state, cmd.target, cmd);
                    }
                    else {
                        const height = this.state.cells.length;
                        const width = this.state.cells[0].length;
                        this.paste(this.state, cmd.target, pasteOption);
                        this.selectPastedZone(width, height, cmd.target);
                        this.status = "invisible";
                    }
                    break;
                case "DELETE_CELL": {
                    const { cut, paste } = this.getDeleteCellsTargets(cmd.zone, cmd.shiftDimension);
                    const state = this.getClipboardState(cut, "CUT");
                    if (cmd.interactive) {
                        this.interactivePaste(state, paste, cmd);
                    }
                    else {
                        this.paste(state, paste);
                    }
                    break;
                }
                case "INSERT_CELL": {
                    const { cut, paste } = this.getInsertCellsTargets(cmd.zone, cmd.shiftDimension);
                    const state = this.getClipboardState(cut, "CUT");
                    if (cmd.interactive) {
                        this.interactivePaste(state, paste, cmd);
                    }
                    else {
                        this.paste(state, paste);
                    }
                    break;
                }
                case "ADD_COLUMNS_ROWS": {
                    this.status = "invisible";
                    // If we add a col/row inside or before the cut area, we invalidate the clipboard
                    if (((_a = this.state) === null || _a === void 0 ? void 0 : _a.operation) !== "CUT") {
                        return;
                    }
                    const isClipboardDirty = this.isColRowDirtyingClipboard(cmd.position === "before" ? cmd.base : cmd.base + 1, cmd.dimension);
                    if (isClipboardDirty) {
                        this.state = undefined;
                    }
                    break;
                }
                case "REMOVE_COLUMNS_ROWS": {
                    this.status = "invisible";
                    // If we remove a col/row inside or before the cut area, we invalidate the clipboard
                    if (((_b = this.state) === null || _b === void 0 ? void 0 : _b.operation) !== "CUT") {
                        return;
                    }
                    for (let el of cmd.elements) {
                        const isClipboardDirty = this.isColRowDirtyingClipboard(el, cmd.dimension);
                        if (isClipboardDirty) {
                            this.state = undefined;
                            break;
                        }
                    }
                    this.status = "invisible";
                    break;
                }
                case "PASTE_FROM_OS_CLIPBOARD":
                    this.pasteFromClipboard(cmd.target, cmd.text);
                    break;
                case "ACTIVATE_PAINT_FORMAT":
                    this.state = this.getClipboardState(cmd.target, "COPY");
                    this._isPaintingFormat = true;
                    this.status = "visible";
                    break;
                default:
                    if (isCoreCommand(cmd)) {
                        this.status = "invisible";
                    }
            }
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        /**
         * Format the current clipboard to a string suitable for being pasted in other
         * programs.
         *
         * - add a tab character between each consecutive cells
         * - add a newline character between each line
         *
         * Note that it returns \t if the clipboard is empty. This is necessary for the
         * clipboard copy event to add it as data, otherwise an empty string is not
         * considered as a copy content.
         */
        getClipboardContent() {
            if (!this.state || !this.state.cells.length) {
                return "\t";
            }
            return (this.state.cells
                .map((cells) => {
                return cells
                    .map((c) => c.cell ? this.getters.getCellText(c.cell, this.getters.shouldShowFormulas()) : "")
                    .join("\t");
            })
                .join("\n") || "\t");
        }
        isPaintingFormat() {
            return this._isPaintingFormat;
        }
        // ---------------------------------------------------------------------------
        // Private methods
        // ---------------------------------------------------------------------------
        getDeleteCellsTargets(zone, dimension) {
            const sheet = this.getters.getActiveSheet();
            let cut;
            if (dimension === "COL") {
                cut = {
                    ...zone,
                    left: zone.right + 1,
                    right: sheet.cols.length - 1,
                };
            }
            else {
                cut = {
                    ...zone,
                    top: zone.bottom + 1,
                    bottom: sheet.rows.length - 1,
                };
            }
            return { cut: [cut], paste: [zone] };
        }
        getInsertCellsTargets(zone, dimension) {
            const sheet = this.getters.getActiveSheet();
            let cut;
            let paste;
            if (dimension === "COL") {
                cut = {
                    ...zone,
                    right: sheet.cols.length - 1,
                };
                paste = {
                    ...zone,
                    left: zone.right + 1,
                    right: zone.right + 1,
                };
            }
            else {
                cut = {
                    ...zone,
                    bottom: sheet.rows.length - 1,
                };
                paste = { ...zone, top: zone.bottom + 1, bottom: sheet.rows.length - 1 };
            }
            return { cut: [cut], paste: [paste] };
        }
        /**
         * If the position is the top-left of an existing merge, remove it
         */
        removeMergeIfTopLeft(position) {
            const { sheetId, col, row } = position;
            const [left, top] = this.getters.getMainCell(sheetId, col, row);
            if (top === row && left === col) {
                const merge = this.getters.getMerge(sheetId, col, row);
                if (merge) {
                    this.dispatch("REMOVE_MERGE", { sheetId, target: [merge] });
                }
            }
        }
        /**
         * If the origin position given is the top left of a merge, merge the target
         * position.
         */
        pasteMergeIfExist(origin, target) {
            let { sheetId, col, row } = origin;
            const [mainCellColOrigin, mainCellRowOrigin] = this.getters.getMainCell(sheetId, col, row);
            if (mainCellColOrigin === col && mainCellRowOrigin === row) {
                const merge = this.getters.getMerge(sheetId, col, row);
                if (!merge) {
                    return;
                }
                ({ sheetId, col, row } = target);
                this.dispatch("ADD_MERGE", {
                    sheetId,
                    force: true,
                    target: [
                        {
                            left: col,
                            top: row,
                            right: col + merge.right - merge.left,
                            bottom: row + merge.bottom - merge.top,
                        },
                    ],
                });
            }
        }
        /**
         * Compute the complete zones where to paste the current clipboard
         */
        getPasteZones(target, cells) {
            if (!cells.length || !cells[0].length) {
                return target;
            }
            const pasteZones = [];
            const height = cells.length;
            const width = cells[0].length;
            const selection = target[target.length - 1];
            const col = selection.left;
            const row = selection.top;
            const repetitionCol = Math.max(1, Math.floor((selection.right + 1 - col) / width));
            const repetitionRow = Math.max(1, Math.floor((selection.bottom + 1 - row) / height));
            for (let x = 1; x <= repetitionCol; x++) {
                for (let y = 1; y <= repetitionRow; y++) {
                    pasteZones.push({
                        left: col,
                        top: row,
                        right: col - 1 + x * width,
                        bottom: row - 1 + y * height,
                    });
                }
            }
            return pasteZones;
        }
        /**
         * Get the clipboard state from the given zones.
         */
        getClipboardState(zones, operation) {
            const tops = new Set(zones.map((z) => z.top));
            const bottoms = new Set(zones.map((z) => z.bottom));
            const areZonesCompatible = tops.size === 1 && bottoms.size === 1;
            let clippedZones = areZonesCompatible ? zones : [zones[zones.length - 1]];
            clippedZones = clippedZones.map((zone) => ({ ...zone }));
            const rows = [];
            const merges = [];
            const sheetId = this.getters.getActiveSheetId();
            const { top, bottom } = clippedZones[0];
            for (let row = top; row <= bottom; row++) {
                const cells = [];
                rows.push(cells);
                for (let zone of clippedZones) {
                    for (let col = zone.left; col <= zone.right; col++) {
                        const cell = this.getters.getCell(sheetId, col, row);
                        const border = this.getters.getCellBorder(sheetId, col, row) || undefined;
                        cells.push({ cell, border, position: { col, row, sheetId } });
                        const merge = this.getters.getMerge(sheetId, col, row);
                        if (merge && merge.top === row && merge.left === col) {
                            merges.push(merge);
                        }
                    }
                }
            }
            return {
                cells: rows,
                operation,
                sheetId,
                zones: clippedZones,
                merges,
            };
        }
        pasteFromClipboard(target, content) {
            this.status = "invisible";
            const values = content
                .replace(/\r/g, "")
                .split("\n")
                .map((vals) => vals.split("\t"));
            const { left: activeCol, top: activeRow } = target[0];
            const width = Math.max.apply(Math, values.map((a) => a.length));
            const height = values.length;
            const sheet = this.getters.getActiveSheet();
            this.addMissingDimensions(sheet, width, height, activeCol, activeRow);
            for (let i = 0; i < values.length; i++) {
                for (let j = 0; j < values[i].length; j++) {
                    this.dispatch("UPDATE_CELL", {
                        row: activeRow + i,
                        col: activeCol + j,
                        content: values[i][j],
                        sheetId: sheet.id,
                    });
                }
            }
            const zone = {
                left: activeCol,
                top: activeRow,
                right: activeCol + width - 1,
                bottom: activeRow + height - 1,
            };
            this.dispatch("SET_SELECTION", {
                anchor: [activeCol, activeRow],
                zones: [zone],
                anchorZone: zone,
            });
        }
        isPasteAllowed(state, target, force) {
            const sheetId = this.getters.getActiveSheetId();
            if (!state) {
                return 18 /* EmptyClipboard */;
            }
            if (target.length > 1) {
                // cannot paste if we have a clipped zone larger than a cell and multiple
                // zones selected
                if (state.cells.length > 1 || state.cells[0].length > 1) {
                    return 17 /* WrongPasteSelection */;
                }
            }
            if (!force) {
                for (let zone of this.getPasteZones(target, state.cells)) {
                    if (this.getters.doesIntersectMerge(sheetId, zone)) {
                        return 2 /* WillRemoveExistingMerge */;
                    }
                }
            }
            return 0 /* Success */;
        }
        /**
         * Paste the clipboard content in the given target
         */
        paste(state, target, options) {
            if (state.operation === "CUT") {
                this.clearClippedZones(state);
            }
            if (target.length > 1) {
                for (const zone of target) {
                    for (let col = zone.left; col <= zone.right; col++) {
                        for (let row = zone.top; row <= zone.bottom; row++) {
                            this.pasteZone(state, col, row, options);
                        }
                    }
                }
            }
            else {
                const height = state.cells.length;
                const width = state.cells[0].length;
                const selection = target[0];
                const repX = Math.max(1, Math.floor((selection.right + 1 - selection.left) / width));
                const repY = Math.max(1, Math.floor((selection.bottom + 1 - selection.top) / height));
                for (let x = 0; x < repX; x++) {
                    for (let y = 0; y < repY; y++) {
                        this.pasteZone(state, selection.left + x * width, selection.top + y * height, options);
                    }
                }
            }
            if (state.operation === "CUT") {
                this.dispatch("REMOVE_MERGE", { sheetId: state.sheetId, target: state.merges });
                this.state = undefined;
            }
        }
        /**
         * Update the selection with the newly pasted zone
         */
        selectPastedZone(width, height, target) {
            const selection = target[0];
            const col = selection.left;
            const row = selection.top;
            const repX = Math.max(1, Math.floor((selection.right + 1 - selection.left) / width));
            const repY = Math.max(1, Math.floor((selection.bottom + 1 - selection.top) / height));
            if (height > 1 || width > 1) {
                const newSelection = {
                    left: col,
                    top: row,
                    right: col + repX * width - 1,
                    bottom: row + repY * height - 1,
                };
                const [anchorCol, anchorRow] = this.getters.getSelection().anchor;
                const newCol = clip(anchorCol, col, col + repX * width - 1);
                const newRow = clip(anchorRow, row, row + repY * height - 1);
                this.dispatch("SET_SELECTION", {
                    anchor: [newCol, newRow],
                    zones: [newSelection],
                    anchorZone: newSelection,
                });
            }
        }
        /**
         * Clear the clipped zones: remove the cells and clear the formatting
         */
        clearClippedZones(state) {
            for (const row of state.cells) {
                for (const cell of row) {
                    if (cell.cell) {
                        this.dispatch("CLEAR_CELL", cell.position);
                    }
                }
            }
            this.dispatch("CLEAR_FORMATTING", {
                sheetId: state.sheetId,
                target: state.zones,
            });
        }
        pasteZone(state, col, row, pasteOption) {
            const height = state.cells.length;
            const width = state.cells[0].length;
            // This condition is used to determine if we have to paste the CF or not.
            // We have to do it when the command handled is "PASTE", not "INSERT_CELL"
            // or "DELETE_CELL". So, the state should be the local state
            const shouldPasteCF = pasteOption !== "onlyValue" && this.state && this.state === state;
            const sheet = this.getters.getActiveSheet();
            // first, add missing cols/rows if needed
            this.addMissingDimensions(sheet, width, height, col, row);
            // then, perform the actual paste operation
            for (let r = 0; r < height; r++) {
                const rowCells = state.cells[r];
                for (let c = 0; c < width; c++) {
                    const origin = rowCells[c];
                    const position = { col: col + c, row: row + r, sheetId: sheet.id };
                    this.removeMergeIfTopLeft(position);
                    this.pasteMergeIfExist(origin.position, position);
                    this.pasteCell(origin, position, state.operation, state.zones, pasteOption);
                    if (shouldPasteCF) {
                        this.dispatch("PASTE_CONDITIONAL_FORMAT", {
                            origin: origin.position,
                            target: position,
                            operation: state.operation,
                        });
                    }
                }
            }
        }
        /**
         * Add columns and/or rows to ensure that col + width and row + height are still
         * in the sheet
         */
        addMissingDimensions(sheet, width, height, col, row) {
            const { cols, rows, id: sheetId } = sheet;
            const missingRows = height + row - rows.length;
            if (missingRows > 0) {
                this.dispatch("ADD_COLUMNS_ROWS", {
                    dimension: "ROW",
                    base: rows.length - 1,
                    sheetId,
                    quantity: missingRows,
                    position: "after",
                });
            }
            const missingCols = width + col - cols.length;
            if (missingCols > 0) {
                this.dispatch("ADD_COLUMNS_ROWS", {
                    dimension: "COL",
                    base: cols.length - 1,
                    sheetId,
                    quantity: missingCols,
                    position: "after",
                });
            }
        }
        /**
         * Paste the cell at the given position to the target position
         */
        pasteCell(origin, target, operation, zones, pasteOption) {
            const { sheetId, col, row } = target;
            const targetCell = this.getters.getCell(sheetId, col, row);
            if (pasteOption !== "onlyValue") {
                this.dispatch("SET_BORDER", { sheetId, col, row, border: origin.border });
            }
            if (origin.cell) {
                if (pasteOption === "onlyFormat") {
                    this.dispatch("UPDATE_CELL", {
                        ...target,
                        style: origin.cell.style,
                        format: origin.cell.format,
                    });
                    return;
                }
                if (pasteOption === "onlyValue") {
                    const content = formatValue(origin.cell.evaluated.value);
                    this.dispatch("UPDATE_CELL", { ...target, content });
                    return;
                }
                let content = origin.cell.content;
                if (origin.cell.isFormula()) {
                    const offsetX = col - origin.position.col;
                    const offsetY = row - origin.position.row;
                    content = this.getUpdatedContent(sheetId, origin.cell, offsetX, offsetY, zones, operation);
                }
                this.dispatch("UPDATE_CELL", {
                    ...target,
                    content,
                    style: origin.cell.style || null,
                    format: origin.cell.format,
                });
            }
            else if (targetCell) {
                if (pasteOption === "onlyValue") {
                    this.dispatch("UPDATE_CELL", { ...target, content: "" });
                }
                else if (pasteOption === "onlyFormat") {
                    this.dispatch("UPDATE_CELL", { ...target, style: null, format: "" });
                }
                else {
                    this.dispatch("CLEAR_CELL", target);
                }
            }
        }
        /**
         * Get the newly updated formula, after applying offsets
         */
        getUpdatedContent(sheetId, cell, offsetX, offsetY, zones, operation) {
            if (operation === "CUT") {
                const ranges = [];
                for (const range of cell.dependencies.references) {
                    if (this.isZoneOverlapClippedZone(zones, range.zone)) {
                        ranges.push(...this.getters.createAdaptedRanges([range], offsetX, offsetY, sheetId));
                    }
                    else {
                        ranges.push(range);
                    }
                }
                const dependencies = { ...cell.dependencies, references: ranges };
                return this.getters.buildFormulaContent(sheetId, cell.normalizedText, dependencies);
            }
            const ranges = this.getters.createAdaptedRanges(cell.dependencies.references, offsetX, offsetY, sheetId);
            const dependencies = { ...cell.dependencies, references: ranges };
            return this.getters.buildFormulaContent(sheetId, cell.normalizedText, dependencies);
        }
        /**
         * Check if the given zone and at least one of the clipped zones overlap
         */
        isZoneOverlapClippedZone(zones, zone) {
            return zones.some((clippedZone) => overlap(zone, clippedZone));
        }
        interactivePaste(state, target, cmd) {
            const result = this.isPasteAllowed(state, target, false);
            if (result !== 0 /* Success */) {
                if (result === 17 /* WrongPasteSelection */) {
                    this.ui.notifyUser(_lt("This operation is not allowed with multiple selections."));
                }
                if (result === 2 /* WillRemoveExistingMerge */) {
                    this.ui.notifyUser(_lt("This operation is not possible due to a merge. Please remove the merges first than try again."));
                }
            }
            else {
                this.dispatch(cmd.type, { ...cmd, interactive: false });
            }
        }
        /**
         * Check if a col/row added/removed at the given position is dirtying the clipboard
         */
        isColRowDirtyingClipboard(position, dimension) {
            if (!this.state || !this.state.zones)
                return false;
            for (let zone of this.state.zones) {
                if (dimension === "COL" && position <= zone.right) {
                    return true;
                }
                if (dimension === "ROW" && position <= zone.bottom) {
                    return true;
                }
            }
            return false;
        }
        // ---------------------------------------------------------------------------
        // Grid rendering
        // ---------------------------------------------------------------------------
        drawGrid(renderingContext) {
            const { viewport, ctx, thinLineWidth } = renderingContext;
            if (this.status !== "visible" ||
                !this.state ||
                !this.state.zones ||
                !this.state.zones.length ||
                this.state.sheetId !== this.getters.getActiveSheetId()) {
                return;
            }
            ctx.setLineDash([8, 5]);
            ctx.strokeStyle = SELECTION_BORDER_COLOR;
            ctx.lineWidth = 3.3 * thinLineWidth;
            for (const zone of this.state.zones) {
                const [x, y, width, height] = this.getters.getRect(zone, viewport);
                if (width > 0 && height > 0) {
                    ctx.strokeRect(x, y, width, height);
                }
            }
        }
    }
    ClipboardPlugin.layers = [2 /* Clipboard */];
    ClipboardPlugin.getters = ["getClipboardContent", "isPaintingFormat"];
    ClipboardPlugin.modes = ["normal"];

    var SelectionMode;
    (function (SelectionMode) {
        SelectionMode[SelectionMode["idle"] = 0] = "idle";
        SelectionMode[SelectionMode["selecting"] = 1] = "selecting";
        SelectionMode[SelectionMode["readyToExpand"] = 2] = "readyToExpand";
        SelectionMode[SelectionMode["expanding"] = 3] = "expanding";
    })(SelectionMode || (SelectionMode = {}));
    /**
     * SelectionPlugin
     */
    class SelectionPlugin extends UIPlugin {
        constructor(getters, state, dispatch, config) {
            super(getters, state, dispatch, config);
            this.selection = {
                zones: [{ top: 0, left: 0, bottom: 0, right: 0 }],
                anchor: [0, 0],
                anchorZone: { top: 0, left: 0, bottom: 0, right: 0 },
            };
            this.selectedFigureId = null;
            this.activeCol = 0;
            this.activeRow = 0;
            this.mode = SelectionMode.idle;
            this.sheetsData = {};
            // This flag is used to avoid to historize the ACTIVE_SHEET command when it's
            // the main command.
            this.activeSheet = null;
            this.moveClient = config.moveClient;
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        allowDispatch(cmd) {
            switch (cmd.type) {
                case "SET_SELECTION": {
                    if (cmd.zones.findIndex((z) => isEqual(z, cmd.anchorZone)) === -1) {
                        return 14 /* InvalidAnchorZone */;
                    }
                    break;
                }
                case "ALTER_SELECTION":
                    if (cmd.delta) {
                        const { left, right, top, bottom } = this.getSelectedZone();
                        const sheet = this.getters.getActiveSheet();
                        const refCol = findVisibleHeader(sheet, "cols", range(left, right + 1));
                        const refRow = findVisibleHeader(sheet, "rows", range(top, bottom + 1));
                        if ((cmd.delta[0] !== 0 && refRow === undefined) ||
                            (cmd.delta[1] !== 0 && refCol === undefined)) {
                            return 15 /* SelectionOutOfBound */;
                        }
                    }
                    break;
                case "MOVE_POSITION": {
                    const { cols, rows } = this.getters.getActiveSheet();
                    if ((cmd.deltaX !== 0 && rows[this.activeRow].isHidden) ||
                        (cmd.deltaY !== 0 && cols[this.activeCol].isHidden)) {
                        return 15 /* SelectionOutOfBound */;
                    }
                    const { col: targetCol, row: targetRow } = this.getNextAvailablePosition(cmd.deltaX, cmd.deltaY);
                    const outOfBound = targetRow < 0 ||
                        targetRow > rows.length - 1 ||
                        targetCol < 0 ||
                        targetCol > cols.length - 1;
                    if (outOfBound) {
                        return 15 /* SelectionOutOfBound */;
                    }
                    break;
                }
                case "SELECT_COLUMN": {
                    const { index } = cmd;
                    if (index < 0 || index >= this.getters.getActiveSheet().cols.length) {
                        return 15 /* SelectionOutOfBound */;
                    }
                    break;
                }
                case "SELECT_ROW": {
                    const { index } = cmd;
                    if (index < 0 || index >= this.getters.getActiveSheet().rows.length) {
                        return 15 /* SelectionOutOfBound */;
                    }
                    break;
                }
                case "ACTIVATE_SHEET":
                    try {
                        this.getters.getSheet(cmd.sheetIdTo);
                        break;
                    }
                    catch (error) {
                        return 21 /* InvalidSheetId */;
                    }
                case "MOVE_COLUMNS_ROWS":
                    const result = this.isMoveElementAllowed(cmd);
                    if (result === 2 /* WillRemoveExistingMerge */) {
                        this.ui.notifyUser(_lt("Merged cells are preventing this operation. Unmerge those cells and try again."));
                    }
                    return result;
            }
            return 0 /* Success */;
        }
        handle(cmd) {
            switch (cmd.type) {
                // some commands should not remove the current selection
                case "CREATE_SHEET":
                case "DELETE_SHEET":
                case "CREATE_FIGURE":
                case "CREATE_CHART":
                case "UPDATE_FIGURE":
                case "EVALUATE_CELLS":
                case "DISABLE_SELECTION_INPUT":
                case "ENABLE_NEW_SELECTION_INPUT":
                case "RESIZE_VIEWPORT":
                    break;
                case "DELETE_FIGURE":
                    if (this.selectedFigureId === cmd.id) {
                        this.selectedFigureId = null;
                    }
                    break;
                default:
                    this.selectedFigureId = null;
            }
            switch (cmd.type) {
                case "START":
                    const firstSheet = this.getters.getSheets()[0];
                    const firstVisiblePosition = getNextVisibleCellCoords(firstSheet, 0, 0);
                    this.activeCol = firstVisiblePosition[0];
                    this.activeRow = firstVisiblePosition[1];
                    this.dispatch("ACTIVATE_SHEET", {
                        sheetIdTo: this.getters.getSheets()[0].id,
                        sheetIdFrom: this.getters.getSheets()[0].id,
                    });
                    this.selectCell(...firstVisiblePosition);
                    break;
                case "ACTIVATE_SHEET":
                    //TODO Change the way selectCell work, perhaps take the sheet as argument ?
                    this.setActiveSheet(cmd.sheetIdTo);
                    this.sheetsData[cmd.sheetIdFrom] = {
                        selection: JSON.parse(JSON.stringify(this.selection)),
                        activeCol: this.activeCol,
                        activeRow: this.activeRow,
                    };
                    if (cmd.sheetIdTo in this.sheetsData) {
                        Object.assign(this, this.sheetsData[cmd.sheetIdTo]);
                    }
                    else {
                        this.selectCell(...getNextVisibleCellCoords(this.getters.getSheet(cmd.sheetIdTo), 0, 0));
                    }
                    break;
                case "SET_SELECTION":
                    this.setSelection(cmd.anchor, cmd.zones, cmd.anchorZone, cmd.strict);
                    break;
                case "START_SELECTION":
                    this.mode = SelectionMode.selecting;
                    break;
                case "PREPARE_SELECTION_EXPANSION":
                    this.mode = SelectionMode.readyToExpand;
                    break;
                case "START_SELECTION_EXPANSION":
                    this.mode = SelectionMode.expanding;
                    break;
                case "STOP_SELECTION":
                    this.mode = SelectionMode.idle;
                    break;
                case "MOVE_POSITION":
                    this.movePosition(cmd.deltaX, cmd.deltaY);
                    break;
                case "SELECT_CELL":
                    this.selectCell(cmd.col, cmd.row);
                    break;
                case "SELECT_COLUMN":
                    this.selectColumn(cmd.index, cmd.createRange || false, cmd.updateRange || false);
                    break;
                case "SELECT_ROW":
                    this.selectRow(cmd.index, cmd.createRange || false, cmd.updateRange || false);
                    break;
                case "SELECT_ALL":
                    this.selectAll();
                    break;
                case "ALTER_SELECTION":
                    if (cmd.delta) {
                        this.moveSelection(cmd.delta[0], cmd.delta[1]);
                    }
                    if (cmd.cell) {
                        this.addCellToSelection(...cmd.cell);
                    }
                    break;
                case "UNDO":
                case "REDO":
                case "DELETE_SHEET":
                    if (!this.getters.tryGetSheet(this.getActiveSheetId())) {
                        const currentSheets = this.getters.getVisibleSheets();
                        this.activeSheet = this.getters.getSheet(currentSheets[0]);
                        this.selectCell(0, 0);
                    }
                    this.ensureSelectionValidity();
                    break;
                case "REMOVE_COLUMNS_ROWS":
                    if (cmd.sheetId === this.getActiveSheetId()) {
                        if (cmd.dimension === "COL") {
                            this.onColumnsRemoved(cmd);
                        }
                        else {
                            this.onRowsRemoved(cmd);
                        }
                    }
                    break;
                case "ADD_COLUMNS_ROWS":
                    if (cmd.sheetId === this.getActiveSheetId()) {
                        this.onAddElements(cmd);
                    }
                    break;
                case "MOVE_COLUMNS_ROWS":
                    if (cmd.sheetId === this.getActiveSheetId()) {
                        this.onMoveElements(cmd);
                    }
                    break;
                case "UPDATE_CHART":
                case "SELECT_FIGURE":
                    this.selectedFigureId = cmd.id;
                    break;
                case "ACTIVATE_NEXT_SHEET":
                    this.activateNextSheet("right");
                    break;
                case "ACTIVATE_PREVIOUS_SHEET":
                    this.activateNextSheet("left");
                    break;
            }
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        getActiveSheet() {
            return this.activeSheet;
        }
        getActiveSheetId() {
            return this.activeSheet.id;
        }
        getActiveCell() {
            const sheetId = this.getters.getActiveSheetId();
            const [mainCol, mainRow] = this.getters.getMainCell(sheetId, this.activeCol, this.activeRow);
            return this.getters.getCell(sheetId, mainCol, mainRow);
        }
        getActiveCols() {
            const activeCols = new Set();
            for (let zone of this.selection.zones) {
                if (zone.top === 0 && zone.bottom === this.getters.getActiveSheet().rows.length - 1) {
                    for (let i = zone.left; i <= zone.right; i++) {
                        activeCols.add(i);
                    }
                }
            }
            return activeCols;
        }
        getActiveRows() {
            const activeRows = new Set();
            for (let zone of this.selection.zones) {
                if (zone.left === 0 && zone.right === this.getters.getActiveSheet().cols.length - 1) {
                    for (let i = zone.top; i <= zone.bottom; i++) {
                        activeRows.add(i);
                    }
                }
            }
            return activeRows;
        }
        getCurrentStyle() {
            const cell = this.getters.getActiveCell();
            return cell ? this.getters.getCellStyle(cell) : {};
        }
        getSelectedZones() {
            return this.selection.zones;
        }
        getSelectedZone() {
            return this.selection.anchorZone;
        }
        getSelection() {
            return this.selection;
        }
        getSelectedFigureId() {
            return this.selectedFigureId;
        }
        getPosition() {
            return [this.activeCol, this.activeRow];
        }
        getSheetPosition(sheetId) {
            if (sheetId === this.getters.getActiveSheetId()) {
                return this.getPosition();
            }
            else {
                const sheetData = this.sheetsData[sheetId];
                return sheetData
                    ? [sheetData.activeCol, sheetData.activeRow]
                    : getNextVisibleCellCoords(this.getters.getSheet(sheetId), 0, 0);
            }
        }
        getAggregate() {
            let aggregate = 0;
            let n = 0;
            for (let zone of this.selection.zones) {
                for (let row = zone.top; row <= zone.bottom; row++) {
                    const r = this.getters.getRow(this.getters.getActiveSheetId(), row);
                    if (r === undefined) {
                        continue;
                    }
                    for (let col = zone.left; col <= zone.right; col++) {
                        const cell = r.cells[col];
                        if ((cell === null || cell === void 0 ? void 0 : cell.evaluated.type) === CellValueType.number) {
                            n++;
                            aggregate += cell.evaluated.value;
                        }
                    }
                }
            }
            return n < 2 ? null : formatStandardNumber(aggregate);
        }
        getSelectionMode() {
            return this.mode;
        }
        isSelected(zone) {
            return !!this.getters.getSelectedZones().find((z) => isEqual(z, zone));
        }
        getVisibleFigures(sheetId) {
            const result = [];
            const figures = this.getters.getFigures(sheetId);
            const { offsetX, offsetY } = this.getters.getSnappedViewport(sheetId);
            const { width, height } = this.getters.getViewportDimension();
            for (let figure of figures) {
                if (figure.x >= offsetX + width || figure.x + figure.width <= offsetX) {
                    continue;
                }
                if (figure.y >= offsetY + height || figure.y + figure.height <= offsetY) {
                    continue;
                }
                result.push(figure);
            }
            return result;
        }
        /**
         * Returns a sorted array of indexes of all columns (respectively rows depending
         * on the dimension parameter) intersected by the currently selected zones.
         *
         * example:
         * assume selectedZones: [{left:0, right: 2, top :2, bottom: 4}, {left:5, right: 6, top :3, bottom: 5}]
         *
         * if dimension === "COL" => [0,1,2,5,6]
         * if dimension === "ROW" => [2,3,4,5]
         */
        getElementsFromSelection(dimension) {
            if (dimension === "COL" && this.getters.getActiveCols().size === 0) {
                return [];
            }
            if (dimension === "ROW" && this.getters.getActiveRows().size === 0) {
                return [];
            }
            const zones = this.getters.getSelectedZones();
            let elements = [];
            const start = dimension === "COL" ? "left" : "top";
            const end = dimension === "COL" ? "right" : "bottom";
            for (const zone of zones) {
                const zoneRows = Array.from({ length: zone[end] - zone[start] + 1 }, (_, i) => zone[start] + i);
                elements = elements.concat(zoneRows);
            }
            return [...new Set(elements)].sort();
        }
        // ---------------------------------------------------------------------------
        // Other
        // ---------------------------------------------------------------------------
        selectColumn(index, createRange, updateRange) {
            const bottom = this.getters.getActiveSheet().rows.length - 1;
            let zone = { left: index, right: index, top: 0, bottom };
            const current = this.selection.zones;
            let newZones, anchor;
            const top = this.getters.getActiveSheet().rows.findIndex((row) => !row.isHidden);
            if (updateRange) {
                const [col, row] = this.selection.anchor;
                zone = union(zone, { left: col, right: col, top, bottom });
                newZones = this.updateSelectionZones(zone);
                anchor = [col, row];
            }
            else {
                newZones = createRange ? current.concat(zone) : [zone];
                anchor = [index, top];
            }
            this.dispatch("SET_SELECTION", { zones: newZones, anchor, strict: true, anchorZone: zone });
        }
        selectRow(index, createRange, updateRange) {
            const right = this.getters.getActiveSheet().cols.length - 1;
            let zone = { top: index, bottom: index, left: 0, right };
            const current = this.selection.zones;
            let zones, anchor;
            const left = this.getters.getActiveSheet().cols.findIndex((col) => !col.isHidden);
            if (updateRange) {
                const [col, row] = this.selection.anchor;
                zone = union(zone, { left, right, top: row, bottom: row });
                zones = this.updateSelectionZones(zone);
                anchor = [col, row];
            }
            else {
                zones = createRange ? current.concat(zone) : [zone];
                anchor = [left, index];
            }
            this.dispatch("SET_SELECTION", { zones, anchor, strict: true, anchorZone: zone });
        }
        selectAll() {
            const bottom = this.getters.getActiveSheet().rows.length - 1;
            const right = this.getters.getActiveSheet().cols.length - 1;
            const zone = { left: 0, top: 0, bottom, right };
            this.dispatch("SET_SELECTION", { zones: [zone], anchor: [0, 0], anchorZone: zone });
        }
        /**
         * Change the anchor of the selection active cell to an absolute col and row index.
         *
         * This is a non trivial task. We need to stop the editing process and update
         * properly the current selection.  Also, this method can optionally create a new
         * range in the selection.
         */
        selectCell(col, row) {
            const sheet = this.getters.getActiveSheet();
            this.moveClient({ sheetId: sheet.id, col, row });
            let zone = this.getters.expandZone(sheet.id, { left: col, right: col, top: row, bottom: row });
            if (this.mode === SelectionMode.expanding) {
                this.selection.zones.push(zone);
            }
            else {
                this.selection.zones = [zone];
            }
            this.selection.zones = uniqueZones(this.selection.zones);
            this.selection.anchorZone = zone;
            this.selection.anchor = [col, row];
            this.activeCol = col;
            this.activeRow = row;
        }
        setActiveSheet(id) {
            const sheet = this.getters.getSheet(id);
            this.activeSheet = sheet;
        }
        /** Computes the next cell position in the direction of deltaX and deltaY
         * by crossing through merges and skipping hidden cells.
         * Note that the resulting position might be out of the sheet, it needs to be validated.
         */
        getNextAvailablePosition(deltaX, deltaY) {
            return {
                col: this.getNextAvailableCol(deltaX, this.activeCol, this.activeRow),
                row: this.getNextAvailableRow(deltaY, this.activeCol, this.activeRow),
            };
        }
        getNextAvailableCol(delta, colIndex, rowIndex) {
            const { cols, id: sheetId } = this.getActiveSheet();
            const position = { col: colIndex, row: rowIndex };
            const isInPositionMerge = (nextCol) => this.getters.isInSameMerge(sheetId, colIndex, rowIndex, nextCol, rowIndex);
            return this.getNextAvailableHeader(delta, cols, colIndex, position, isInPositionMerge);
        }
        getNextAvailableRow(delta, colIndex, rowIndex) {
            const { rows, id: sheetId } = this.getActiveSheet();
            const position = { col: colIndex, row: rowIndex };
            const isInPositionMerge = (nextRow) => this.getters.isInSameMerge(sheetId, colIndex, rowIndex, colIndex, nextRow);
            return this.getNextAvailableHeader(delta, rows, rowIndex, position, isInPositionMerge);
        }
        getNextAvailableHeader(delta, headers, startingHeaderIndex, position, isInPositionMerge) {
            var _a, _b, _c;
            const sheetId = this.getters.getActiveSheetId();
            const { col, row } = position;
            if (delta === 0) {
                return startingHeaderIndex;
            }
            let header = startingHeaderIndex + delta;
            if (this.getters.isInMerge(sheetId, col, row)) {
                while (isInPositionMerge(header)) {
                    header += delta;
                }
                while ((_a = headers[header]) === null || _a === void 0 ? void 0 : _a.isHidden) {
                    header += delta;
                }
            }
            else if ((_b = headers[header]) === null || _b === void 0 ? void 0 : _b.isHidden) {
                while ((_c = headers[header]) === null || _c === void 0 ? void 0 : _c.isHidden) {
                    header += delta;
                }
            }
            const outOfBound = header < 0 || header > headers.length - 1;
            if (outOfBound) {
                if (headers[startingHeaderIndex].isHidden) {
                    return this.getNextAvailableHeader(-delta, headers, startingHeaderIndex, position, isInPositionMerge);
                }
                else {
                    return startingHeaderIndex;
                }
            }
            return header;
        }
        /**
         * Moves the position of either the active cell of the anchor of the current selection by a number of rows / cols delta
         */
        movePosition(deltaX, deltaY) {
            const { col: targetCol, row: targetRow } = this.getNextAvailablePosition(deltaX, deltaY);
            this.selectCell(targetCol, targetRow);
        }
        setSelection(anchor, zones, anchorZone, strict = false) {
            this.selectCell(...anchor);
            const sheetId = this.getters.getActiveSheetId();
            let selection;
            zones = uniqueZones(zones);
            if (strict) {
                selection = { zones, anchorZone, anchor };
            }
            else {
                selection = {
                    anchor,
                    zones: zones.map((zone) => this.getters.expandZone(sheetId, zone)),
                    anchorZone: this.getters.expandZone(sheetId, anchorZone),
                };
            }
            this.selection = this.clipSelection(sheetId, selection);
        }
        /**
         * Finds a visible cell in the currently selected zone starting with the anchor.
         * If the anchor is hidden, browses from left to right and top to bottom to
         * find a visible cell.
         */
        getReferencePosition() {
            const sheet = this.getters.getActiveSheet();
            const selection = this.selection;
            const { left, right, top, bottom } = selection.anchorZone;
            const [anchorCol, anchorRow] = selection.anchor;
            return {
                col: sheet.cols[anchorCol].isHidden
                    ? findVisibleHeader(sheet, "cols", range(left, right + 1)) || anchorCol
                    : anchorCol,
                row: sheet.rows[anchorRow].isHidden
                    ? findVisibleHeader(sheet, "rows", range(top, bottom + 1)) || anchorRow
                    : anchorRow,
            };
        }
        moveSelection(deltaX, deltaY) {
            const selection = this.selection;
            let newZones = [];
            const [anchorCol, anchorRow] = selection.anchor;
            const { left, right, top, bottom } = selection.anchorZone;
            let result = selection.anchorZone;
            const activeSheet = this.getters.getActiveSheet();
            const expand = (z) => {
                const { left, right, top, bottom } = this.getters.expandZone(activeSheet.id, z);
                return {
                    left: Math.max(0, left),
                    right: Math.min(activeSheet.cols.length - 1, right),
                    top: Math.max(0, top),
                    bottom: Math.min(activeSheet.rows.length - 1, bottom),
                };
            };
            const { col: refCol, row: refRow } = this.getReferencePosition();
            // check if we can shrink selection
            let n = 0;
            while (result !== null) {
                n++;
                if (deltaX < 0) {
                    const newRight = this.getNextAvailableCol(deltaX, right - (n - 1), refRow);
                    result = refCol <= right - n ? expand({ top, left, bottom, right: newRight }) : null;
                }
                if (deltaX > 0) {
                    const newLeft = this.getNextAvailableCol(deltaX, left + (n - 1), refRow);
                    result = left + n <= refCol ? expand({ top, left: newLeft, bottom, right }) : null;
                }
                if (deltaY < 0) {
                    const newBottom = this.getNextAvailableRow(deltaY, refCol, bottom - (n - 1));
                    result = refRow <= bottom - n ? expand({ top, left, bottom: newBottom, right }) : null;
                }
                if (deltaY > 0) {
                    const newTop = this.getNextAvailableRow(deltaY, refCol, top + (n - 1));
                    result = top + n <= refRow ? expand({ top: newTop, left, bottom, right }) : null;
                }
                result = result ? organizeZone(result) : result;
                if (result && !isEqual(result, selection.anchorZone)) {
                    newZones = this.updateSelectionZones(result);
                    this.dispatch("SET_SELECTION", {
                        zones: newZones,
                        anchor: [anchorCol, anchorRow],
                        anchorZone: result,
                    });
                    return;
                }
            }
            const currentZone = { top: anchorRow, bottom: anchorRow, left: anchorCol, right: anchorCol };
            const zoneWithDelta = organizeZone({
                top: this.getNextAvailableRow(deltaY, refCol, top),
                left: this.getNextAvailableCol(deltaX, left, refRow),
                bottom: this.getNextAvailableRow(deltaY, refCol, bottom),
                right: this.getNextAvailableCol(deltaX, right, refRow),
            });
            result = expand(union(currentZone, zoneWithDelta));
            if (!isEqual(result, selection.anchorZone)) {
                newZones = this.updateSelectionZones(result);
                this.dispatch("SET_SELECTION", {
                    zones: newZones,
                    anchor: [anchorCol, anchorRow],
                    anchorZone: result,
                });
            }
        }
        addCellToSelection(col, row) {
            const selection = this.selection;
            const [anchorCol, anchorRow] = selection.anchor;
            const zone = {
                left: Math.min(anchorCol, col),
                top: Math.min(anchorRow, row),
                right: Math.max(anchorCol, col),
                bottom: Math.max(anchorRow, row),
            };
            const newZones = this.updateSelectionZones(zone);
            this.dispatch("SET_SELECTION", {
                zones: newZones,
                anchor: [anchorCol, anchorRow],
                anchorZone: zone,
            });
        }
        /**
         * Ensure selections are not outside sheet boundaries.
         * They are clipped to fit inside the sheet if needed.
         */
        ensureSelectionValidity() {
            const { anchor, zones, anchorZone } = this.clipSelection(this.getActiveSheetId(), this.selection);
            this.setSelection(anchor, zones, anchorZone);
            const deletedSheetIds = Object.keys(this.sheetsData).filter((sheetId) => !this.getters.tryGetSheet(sheetId));
            for (const sheetId of deletedSheetIds) {
                delete this.sheetsData[sheetId];
            }
            for (const sheetId in this.sheetsData) {
                const { anchor, zones, anchorZone } = this.clipSelection(sheetId, this.sheetsData[sheetId].selection);
                this.sheetsData[sheetId] = {
                    selection: { anchor, zones, anchorZone },
                    activeCol: anchor[0],
                    activeRow: anchor[1],
                };
            }
        }
        /**
         * Clip the selection if it spans outside the sheet
         */
        clipSelection(sheetId, selection) {
            const sheet = this.getters.getSheet(sheetId);
            const cols = sheet.cols.length - 1;
            const rows = sheet.rows.length - 1;
            const zones = selection.zones.map((z) => ({
                left: clip(z.left, 0, cols),
                right: clip(z.right, 0, cols),
                top: clip(z.top, 0, rows),
                bottom: clip(z.bottom, 0, rows),
            }));
            const anchorCol = clip(selection.anchor[0], 0, cols);
            const anchorRow = clip(selection.anchor[1], 0, rows);
            const anchorZone = {
                left: clip(selection.anchorZone.left, 0, cols),
                right: clip(selection.anchorZone.right, 0, cols),
                top: clip(selection.anchorZone.top, 0, rows),
                bottom: clip(selection.anchorZone.bottom, 0, rows),
            };
            return {
                anchor: [anchorCol, anchorRow],
                zones,
                anchorZone,
            };
        }
        onColumnsRemoved(cmd) {
            const zone = updateSelectionOnDeletion(this.getSelectedZone(), "left", cmd.elements);
            this.setSelection([zone.left, zone.top], [zone], zone, true);
            this.ensureSelectionValidity();
        }
        onRowsRemoved(cmd) {
            const zone = updateSelectionOnDeletion(this.getSelectedZone(), "top", cmd.elements);
            this.setSelection([zone.left, zone.top], [zone], zone, true);
            this.ensureSelectionValidity();
        }
        onAddElements(cmd) {
            const selection = this.getSelectedZone();
            const zone = updateSelectionOnInsertion(selection, cmd.dimension === "COL" ? "left" : "top", cmd.base, cmd.position, cmd.quantity);
            this.setSelection([zone.left, zone.top], [zone], zone, true);
        }
        /**
         * this function searches for anchorZone in selection.zones
         * and modifies it by newZone
         */
        updateSelectionZones(newZone) {
            let zones = [...this.selection.zones];
            const current = this.selection.anchorZone;
            const index = zones.findIndex((z) => isEqual(z, current));
            if (index >= 0) {
                zones[index] = newZone;
            }
            return zones;
        }
        activateNextSheet(direction) {
            const sheetIds = this.getters.getSheets().map((sheet) => sheet.id);
            const oldSheetPosition = sheetIds.findIndex((id) => id === this.activeSheet.id);
            const delta = direction === "left" ? sheetIds.length - 1 : 1;
            const newPosition = (oldSheetPosition + delta) % sheetIds.length;
            this.dispatch("ACTIVATE_SHEET", {
                sheetIdFrom: this.getActiveSheetId(),
                sheetIdTo: sheetIds[newPosition],
            });
        }
        onMoveElements(cmd) {
            const thickness = cmd.elements.length;
            this.dispatch("ADD_COLUMNS_ROWS", {
                dimension: cmd.dimension,
                sheetId: cmd.sheetId,
                base: cmd.base,
                quantity: thickness,
                position: "before",
            });
            const isCol = cmd.dimension === "COL";
            const start = cmd.elements[0];
            const end = cmd.elements[thickness - 1];
            const isBasedBefore = cmd.base < start;
            const deltaCol = isBasedBefore && isCol ? thickness : 0;
            const deltaRow = isBasedBefore && !isCol ? thickness : 0;
            const sheet = this.getters.getSheet(cmd.sheetId);
            this.dispatch("CUT", {
                target: [
                    {
                        left: isCol ? start + deltaCol : 0,
                        right: isCol ? end + deltaCol : sheet.cols.length - 1,
                        top: !isCol ? start + deltaRow : 0,
                        bottom: !isCol ? end + deltaRow : sheet.rows.length - 1,
                    },
                ],
            });
            this.dispatch("PASTE", {
                target: [
                    {
                        left: isCol ? cmd.base : 0,
                        right: isCol ? cmd.base + thickness - 1 : sheet.cols.length - 1,
                        top: !isCol ? cmd.base : 0,
                        bottom: !isCol ? cmd.base + thickness - 1 : sheet.rows.length - 1,
                    },
                ],
            });
            const toRemove = isBasedBefore ? cmd.elements.map((el) => el + thickness) : cmd.elements;
            let currentIndex = cmd.base;
            for (const element of toRemove) {
                const size = cmd.dimension === "COL"
                    ? this.getters.getCol(cmd.sheetId, element).size
                    : this.getters.getRow(cmd.sheetId, element).size;
                this.dispatch("RESIZE_COLUMNS_ROWS", {
                    dimension: cmd.dimension,
                    sheetId: cmd.sheetId,
                    size,
                    elements: [currentIndex],
                });
                currentIndex += 1;
            }
            this.dispatch("REMOVE_COLUMNS_ROWS", {
                dimension: cmd.dimension,
                sheetId: cmd.sheetId,
                elements: toRemove,
            });
        }
        isMoveElementAllowed(cmd) {
            const isCol = cmd.dimension === "COL";
            const start = cmd.elements[0];
            const end = cmd.elements[cmd.elements.length - 1];
            const id = cmd.sheetId;
            const doesElementsHaveCommonMerges = isCol
                ? this.getters.doesColumnsHaveCommonMerges
                : this.getters.doesRowsHaveCommonMerges;
            if (doesElementsHaveCommonMerges(id, start - 1, start) ||
                doesElementsHaveCommonMerges(id, end, end + 1) ||
                doesElementsHaveCommonMerges(id, cmd.base - 1, cmd.base)) {
                return 2 /* WillRemoveExistingMerge */;
            }
            return 0 /* Success */;
        }
        // ---------------------------------------------------------------------------
        // Grid rendering
        // ---------------------------------------------------------------------------
        drawGrid(renderingContext) {
            if (this.getters.getEditionMode() !== "inactive") {
                return;
            }
            const { viewport, ctx, thinLineWidth } = renderingContext;
            // selection
            const zones = this.getSelectedZones();
            ctx.fillStyle = "#f3f7fe";
            const onlyOneCell = zones.length === 1 && zones[0].left === zones[0].right && zones[0].top === zones[0].bottom;
            ctx.fillStyle = onlyOneCell ? "#f3f7fe" : "#e9f0ff";
            ctx.strokeStyle = SELECTION_BORDER_COLOR;
            ctx.lineWidth = 1.5 * thinLineWidth;
            ctx.globalCompositeOperation = "multiply";
            for (const zone of zones) {
                const [x, y, width, height] = this.getters.getRect(zone, viewport);
                ctx.fillRect(x, y, width, height);
                ctx.strokeRect(x, y, width, height);
            }
            ctx.globalCompositeOperation = "source-over";
            // active zone
            const activeSheet = this.getters.getActiveSheetId();
            const [col, row] = this.getPosition();
            ctx.strokeStyle = SELECTION_BORDER_COLOR;
            ctx.lineWidth = 3 * thinLineWidth;
            let zone;
            if (this.getters.isInMerge(activeSheet, col, row)) {
                zone = this.getters.getMerge(activeSheet, col, row);
            }
            else {
                zone = {
                    top: row,
                    bottom: row,
                    left: col,
                    right: col,
                };
            }
            const [x, y, width, height] = this.getters.getRect(zone, viewport);
            if (width > 0 && height > 0) {
                ctx.strokeRect(x, y, width, height);
            }
        }
    }
    SelectionPlugin.layers = [5 /* Selection */];
    SelectionPlugin.modes = ["normal"];
    SelectionPlugin.getters = [
        "getActiveSheet",
        "getActiveSheetId",
        "getActiveCell",
        "getActiveCols",
        "getActiveRows",
        "getCurrentStyle",
        "getSelectedZones",
        "getSelectedZone",
        "getAggregate",
        "getSelectedFigureId",
        "getVisibleFigures",
        "getSelection",
        "getPosition",
        "getSheetPosition",
        "getSelectionMode",
        "isSelected",
        "getElementsFromSelection",
    ];

    const CELL_DELETED_MESSAGE = _lt("The cell you are trying to edit has been deleted.");
    const SelectionIndicator = "␣";
    class EditionPlugin extends UIPlugin {
        constructor() {
            super(...arguments);
            this.col = 0;
            this.row = 0;
            this.mode = "inactive";
            this.sheet = "";
            this.currentContent = "";
            this.currentTokens = [];
            this.selectionStart = 0;
            this.selectionEnd = 0;
            this.selectionInitialStart = 0;
            this.multiSelectionInitialStart = 0;
            this.initialContent = "";
            this.previousRef = "";
            this.previousRange = undefined;
            this.colorIndexByRange = {};
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        allowDispatch(cmd) {
            switch (cmd.type) {
                case "CHANGE_COMPOSER_CURSOR_SELECTION":
                    return this.validateSelection(this.currentContent.length, cmd.start, cmd.end);
                case "SET_CURRENT_CONTENT":
                    if (cmd.selection) {
                        return this.validateSelection(cmd.content.length, cmd.selection.start, cmd.selection.end);
                    }
                    else {
                        return 0 /* Success */;
                    }
                case "START_EDITION":
                    if (cmd.selection) {
                        const cell = this.getters.getActiveCell();
                        const content = cmd.text || (cell === null || cell === void 0 ? void 0 : cell.composerContent) || "";
                        return this.validateSelection(content.length, cmd.selection.start, cmd.selection.end);
                    }
                    else {
                        return 0 /* Success */;
                    }
                default:
                    return 0 /* Success */;
            }
        }
        handle(cmd) {
            switch (cmd.type) {
                case "CHANGE_COMPOSER_CURSOR_SELECTION":
                    this.selectionStart = cmd.start;
                    this.selectionEnd = cmd.end;
                    break;
                case "STOP_COMPOSER_RANGE_SELECTION":
                    if (this.isSelectingForComposer()) {
                        this.mode = "editing";
                    }
                    break;
                case "START_EDITION":
                    this.startEdition(cmd.text, cmd.selection);
                    break;
                case "STOP_EDITION":
                    if (cmd.cancel) {
                        this.cancelEdition();
                        this.resetContent();
                    }
                    else {
                        this.stopEdition();
                    }
                    break;
                case "SET_CURRENT_CONTENT":
                    this.setContent(cmd.content, cmd.selection);
                    break;
                case "REPLACE_COMPOSER_CURSOR_SELECTION":
                    this.replaceSelection(cmd.text);
                    break;
                case "SELECT_FIGURE":
                    this.cancelEdition();
                    this.resetContent();
                    break;
                case "SELECT_CELL":
                case "SET_SELECTION":
                case "MOVE_POSITION":
                    switch (this.mode) {
                        case "editing":
                            this.dispatch("STOP_EDITION");
                            break;
                        case "waitingForRangeSelection":
                            this.insertSelectedRange();
                            break;
                        case "rangeSelected":
                            switch (cmd.type) {
                                case "MOVE_POSITION":
                                    this.replaceAllSelectedRanges();
                                    break;
                                case "SELECT_CELL":
                                    if (this.getters.getSelectionMode() === SelectionMode.expanding) {
                                        this.insertSelectedRange();
                                    }
                                    else {
                                        this.replaceAllSelectedRanges();
                                    }
                                    break;
                                case "SET_SELECTION":
                                    if (!cmd.strict) {
                                        this.replaceSelectedRange();
                                    }
                                    else if (this.getters.getSelectionMode() === SelectionMode.expanding) {
                                        this.insertSelectedRange();
                                    }
                                    else {
                                        this.replaceAllSelectedRanges();
                                    }
                                    break;
                            }
                            break;
                    }
                    break;
                case "ADD_COLUMNS_ROWS":
                    this.onAddElements(cmd);
                    break;
                case "REMOVE_COLUMNS_ROWS":
                    if (cmd.dimension === "COL") {
                        this.onColumnsRemoved(cmd);
                    }
                    else {
                        this.onRowsRemoved(cmd);
                    }
                    break;
                case "START_CHANGE_HIGHLIGHT":
                    this.dispatch("STOP_COMPOSER_RANGE_SELECTION");
                    const previousRefToken = this.currentTokens
                        .filter((token) => token.type === "SYMBOL")
                        .find((token) => {
                        let value = token.value;
                        const [xc, sheet] = value.split("!").reverse();
                        const sheetName = sheet || this.getters.getSheetName(this.sheet);
                        const activeSheetId = this.getters.getActiveSheetId();
                        return (isEqual(this.getters.expandZone(activeSheetId, toZone(xc)), cmd.zone) &&
                            this.getters.getSheetName(activeSheetId) === sheetName);
                    });
                    this.previousRef = previousRefToken.value;
                    this.previousRange = this.getters.getRangeFromSheetXC(this.getters.getActiveSheetId(), this.previousRef);
                    this.selectionInitialStart = previousRefToken.start;
                    break;
                case "CHANGE_HIGHLIGHT":
                    const newRef = this.getZoneReference(cmd.zone, this.previousRange.parts);
                    this.selectionStart = this.selectionInitialStart;
                    this.selectionEnd = this.selectionInitialStart + this.previousRef.length;
                    this.replaceSelection(newRef);
                    this.previousRef = newRef;
                    this.selectionStart = this.currentContent.length;
                    this.selectionEnd = this.currentContent.length;
                    break;
                case "DELETE_SHEET":
                case "UNDO":
                case "REDO":
                    const sheetIdExists = !!this.getters.tryGetSheet(this.sheet);
                    if (!sheetIdExists && this.mode !== "inactive") {
                        this.cancelEdition();
                        this.resetContent();
                        this.ui.notifyUser(CELL_DELETED_MESSAGE);
                    }
                    break;
            }
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        getEditionMode() {
            return this.mode;
        }
        getCurrentContent() {
            if (this.mode === "inactive") {
                const cell = this.getters.getActiveCell();
                return (cell === null || cell === void 0 ? void 0 : cell.composerContent) || "";
            }
            return this.currentContent;
        }
        getEditionSheet() {
            return this.sheet;
        }
        getComposerSelection() {
            return {
                start: this.selectionStart,
                end: this.selectionEnd,
            };
        }
        isSelectingForComposer() {
            return (this.mode === "waitingForRangeSelection" ||
                this.mode === "rangeSelected" ||
                this.mode === "resettingPosition");
        }
        getCurrentTokens() {
            return this.currentTokens;
        }
        /**
         * Return the (enriched) token just before the cursor.
         */
        getTokenAtCursor() {
            const start = Math.min(this.selectionStart, this.selectionEnd);
            const end = Math.max(this.selectionStart, this.selectionEnd);
            if (start === end && end === 0) {
                return undefined;
            }
            else {
                return this.currentTokens.find((t) => t.start <= start && t.end >= end);
            }
        }
        // ---------------------------------------------------------------------------
        // Misc
        // ---------------------------------------------------------------------------
        validateSelection(length, start, end) {
            return start >= 0 && start <= length && end >= 0 && end <= length
                ? 0 /* Success */
                : 29 /* WrongComposerSelection */;
        }
        onColumnsRemoved(cmd) {
            if (cmd.elements.includes(this.col) && this.mode !== "inactive") {
                this.dispatch("STOP_EDITION", { cancel: true });
                this.ui.notifyUser(CELL_DELETED_MESSAGE);
                return;
            }
            const { top, left } = updateSelectionOnDeletion({ left: this.col, right: this.col, top: this.row, bottom: this.row }, "left", cmd.elements);
            this.col = left;
            this.row = top;
        }
        onRowsRemoved(cmd) {
            if (cmd.elements.includes(this.row) && this.mode !== "inactive") {
                this.dispatch("STOP_EDITION", { cancel: true });
                this.ui.notifyUser(CELL_DELETED_MESSAGE);
                return;
            }
            const { top, left } = updateSelectionOnDeletion({ left: this.col, right: this.col, top: this.row, bottom: this.row }, "top", cmd.elements);
            this.col = left;
            this.row = top;
        }
        onAddElements(cmd) {
            const { top, left } = updateSelectionOnInsertion({ left: this.col, right: this.col, top: this.row, bottom: this.row }, cmd.dimension === "COL" ? "left" : "top", cmd.base, cmd.position, cmd.quantity);
            this.col = left;
            this.row = top;
        }
        /**
         * Enable the selecting mode
         */
        startComposerRangeSelection() {
            this.mode = "resettingPosition";
            if (this.sheet === this.getters.getActiveSheetId()) {
                this.dispatch("SELECT_CELL", {
                    col: this.col,
                    row: this.row,
                });
            }
            this.mode = "waitingForRangeSelection";
            // We set this variable to store the start of the multiple range
            // selection. This is useful for example when we select multiple
            // cells with ctrl, release the ctrl and select a new cell.
            // This should result in deletions of previously selected cells.
            this.multiSelectionInitialStart = this.selectionStart;
        }
        /**
         * start the edition of a cell
         * @param str the key that is used to start the edition if it is a "content" key like a letter or number
         * @param selection
         * @private
         */
        startEdition(str, selection) {
            const cell = this.getters.getActiveCell();
            this.initialContent = (cell === null || cell === void 0 ? void 0 : cell.composerContent) || "";
            this.mode = "editing";
            const [col, row] = this.getters.getPosition();
            this.col = col;
            this.row = row;
            this.sheet = this.getters.getActiveSheetId();
            this.setContent(str || this.initialContent, selection);
            this.colorIndexByRange = {};
        }
        stopEdition() {
            if (this.mode !== "inactive") {
                this.cancelEdition();
                const sheetId = this.getters.getActiveSheetId();
                const mergeSheetId = this.getters.getSheets().find((sheet) => sheet.id === this.sheet).id;
                const [col, row] = this.getters.getMainCell(mergeSheetId, this.col, this.row);
                let content = this.currentContent;
                const didChange = this.initialContent !== content;
                if (!didChange) {
                    return;
                }
                if (content) {
                    const cell = this.getters.getCell(sheetId, col, row);
                    if (content.startsWith("=")) {
                        const left = this.currentTokens.filter((t) => t.type === "LEFT_PAREN").length;
                        const right = this.currentTokens.filter((t) => t.type === "RIGHT_PAREN").length;
                        const missing = left - right;
                        if (missing > 0) {
                            content += new Array(missing).fill(")").join("");
                        }
                    }
                    else if (cell === null || cell === void 0 ? void 0 : cell.isLink()) {
                        content = markdownLink(content, cell.link.url);
                    }
                    this.dispatch("UPDATE_CELL", {
                        sheetId: this.sheet,
                        col,
                        row,
                        content,
                    });
                }
                else {
                    this.dispatch("UPDATE_CELL", {
                        sheetId: this.sheet,
                        content: "",
                        col,
                        row,
                    });
                }
                if (sheetId !== this.sheet) {
                    this.dispatch("ACTIVATE_SHEET", {
                        sheetIdFrom: this.getters.getActiveSheetId(),
                        sheetIdTo: this.sheet,
                    });
                }
                this.setContent("");
            }
        }
        cancelEdition() {
            this.mode = "inactive";
        }
        /**
         * Reset the current content to the active cell content
         */
        resetContent() {
            this.setContent(this.initialContent || "");
        }
        setContent(text, selection) {
            const isNewCurrentContent = this.currentContent !== text;
            this.currentContent = text;
            if (selection) {
                this.selectionStart = selection.start;
                this.selectionEnd = selection.end;
            }
            else {
                this.selectionStart = this.selectionEnd = text.length;
            }
            if (isNewCurrentContent || this.mode !== "inactive") {
                this.currentTokens = text.startsWith("=") ? composerTokenize(text) : [];
            }
            if (this.canStartComposerRangeSelection()) {
                this.startComposerRangeSelection();
            }
        }
        /**
         * Insert reference of the currently selected zone in the composer content.
         * Separates references with commas when more than one is selected.
         */
        insertSelectedRange() {
            const start = Math.min(this.selectionStart, this.selectionEnd);
            const ref = this.getZoneReference(this.getters.getSelectedZone());
            if (this.mode === "waitingForRangeSelection") {
                this.insertText(ref, start);
                this.selectionInitialStart = start;
                this.mode = "rangeSelected";
                return;
            }
            // range already present (mean this.mode === "rangeSelected")
            this.insertText("," + ref, start);
            this.selectionInitialStart = start + 1;
        }
        /**
         * Replace the last reference by the new one.
         * This function is particularly useful when multiple cells selection is
         * enabled and we need to change the last reference (eg: change the cell
         * reference to a range reference)
         */
        replaceSelectedRange() {
            const { end } = this.getters.getComposerSelection();
            this.dispatch("CHANGE_COMPOSER_CURSOR_SELECTION", {
                start: this.selectionInitialStart,
                end,
            });
            this.replaceSelection(this.getZoneReference(this.getters.getSelectedZone()));
        }
        /**
         * Replace all references selected by the new one.
         * */
        replaceAllSelectedRanges() {
            const { end } = this.getters.getComposerSelection();
            this.dispatch("CHANGE_COMPOSER_CURSOR_SELECTION", {
                start: this.multiSelectionInitialStart,
                end,
            });
            this.replaceSelection(this.getZoneReference(this.getters.getSelectedZone()));
            this.selectionInitialStart = this.multiSelectionInitialStart;
        }
        getZoneReference(zone, fixedParts = [{ colFixed: false, rowFixed: false }]) {
            const sheetId = this.getters.getActiveSheetId();
            let selectedXc = this.getters.zoneToXC(sheetId, zone, fixedParts);
            if (this.getters.getEditionSheet() !== this.getters.getActiveSheetId()) {
                const sheetName = getComposerSheetName(this.getters.getSheetName(this.getters.getActiveSheetId()));
                selectedXc = `${sheetName}!${selectedXc}`;
            }
            return selectedXc;
        }
        /**
         * Replace the current selection by a new text.
         * The cursor is then set at the end of the text.
         */
        replaceSelection(text) {
            const start = Math.min(this.selectionStart, this.selectionEnd);
            const end = Math.max(this.selectionStart, this.selectionEnd);
            this.replaceText(text, start, end);
        }
        replaceText(text, start, end) {
            this.currentContent =
                this.currentContent.slice(0, start) +
                    this.currentContent.slice(end, this.currentContent.length);
            this.insertText(text, start);
        }
        /**
         * Insert a text at the given position.
         * The cursor is then set at the end of the text.
         */
        insertText(text, start) {
            const content = this.currentContent.slice(0, start) + text + this.currentContent.slice(start);
            const end = start + text.length;
            this.dispatch("SET_CURRENT_CONTENT", {
                content,
                selection: { start: end, end },
            });
        }
        /**
         * Highlight all ranges that can be found in the composer content.
         */
        getComposerHighlights() {
            if (!this.currentContent.startsWith("=") || this.mode === "inactive") {
                return [];
            }
            const ranges = [];
            const colorIndexByRange = {};
            for (let token of this.currentTokens.filter((token) => token.type === "SYMBOL")) {
                let value = token.value;
                const [xc, sheet] = value.split("!").reverse();
                if (rangeReference.test(xc)) {
                    const refSanitized = (sheet ? `${sheet}!` : `${this.getters.getSheetName(this.getters.getEditionSheet())}!`) +
                        xc.replace(/\$/g, "");
                    ranges.push(refSanitized);
                    const colorIndex = this.colorIndexByRange[refSanitized];
                    if (colorIndex !== undefined) {
                        colorIndexByRange[refSanitized] = colorIndex;
                    }
                }
            }
            this.colorIndexByRange = colorIndexByRange;
            let colorIndexes = Object.values(colorIndexByRange);
            let nextColorIndex = 0;
            return ranges.map((r) => {
                if (this.colorIndexByRange[r] === undefined) {
                    while (colorIndexes.includes(nextColorIndex)) {
                        nextColorIndex++;
                    }
                    colorIndexes.push(nextColorIndex);
                    this.colorIndexByRange[r] = nextColorIndex;
                }
                return [r, colors$1[this.colorIndexByRange[r] % colors$1.length]];
            });
        }
        /**
         * Function used to determine when composer selection can start.
         * Three conditions are necessary:
         * - the previous token is among ["COMMA", "LEFT_PAREN", "OPERATOR"]
         * - the next token is missing or is among ["COMMA", "RIGHT_PAREN", "OPERATOR"]
         * - Previous and next tokens can be separated by spaces
         */
        canStartComposerRangeSelection() {
            if (this.mode !== "editing" && this.selectionStart === this.selectionEnd) {
                return false;
            }
            if (this.currentContent.startsWith("=")) {
                const tokenAtCursor = this.getTokenAtCursor();
                if (tokenAtCursor) {
                    const tokenIdex = this.currentTokens
                        .map((token) => token.start)
                        .indexOf(tokenAtCursor.start);
                    let count = tokenIdex;
                    let currentToken = tokenAtCursor;
                    // check previous token
                    while (!["COMMA", "LEFT_PAREN", "OPERATOR"].includes(currentToken.type)) {
                        if (currentToken.type !== "SPACE" || count < 1) {
                            return false;
                        }
                        count--;
                        currentToken = this.currentTokens[count];
                    }
                    count = tokenIdex + 1;
                    currentToken = this.currentTokens[count];
                    // check next token
                    while (currentToken && !["COMMA", "RIGHT_PAREN", "OPERATOR"].includes(currentToken.type)) {
                        if (currentToken.type !== "SPACE") {
                            return false;
                        }
                        count++;
                        currentToken = this.currentTokens[count];
                    }
                    count++;
                    currentToken = this.currentTokens[count];
                }
                return true;
            }
            return false;
        }
    }
    EditionPlugin.getters = [
        "getEditionMode",
        "isSelectingForComposer",
        "getCurrentContent",
        "getEditionSheet",
        "getComposerSelection",
        "getCurrentTokens",
        "getTokenAtCursor",
        "getComposerHighlights",
    ];
    EditionPlugin.modes = ["normal"];

    const functionMap = functionRegistry.mapping;
    class EvaluationPlugin extends UIPlugin {
        constructor(getters, state, dispatch, config) {
            super(getters, state, dispatch, config);
            this.isUpToDate = new Set(); // Set<sheetIds>
            this.evalContext = config.evalContext;
            config.dataSources.on("data-loaded", this, () => {
                this.dispatch("EVALUATE_CELLS", { sheetId: this.getters.getActiveSheetId() });
            });
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        handle(cmd) {
            if (invalidateEvaluationCommands.has(cmd.type)) {
                this.isUpToDate.clear();
            }
            switch (cmd.type) {
                case "UPDATE_CELL":
                    if ("content" in cmd) {
                        this.isUpToDate.clear();
                    }
                    break;
                case "ACTIVATE_SHEET": {
                    this.evaluate(cmd.sheetIdTo);
                    this.isUpToDate.add(cmd.sheetIdTo);
                    break;
                }
                case "EVALUATE_CELLS":
                    this.evaluate(cmd.sheetId);
                    this.isUpToDate.add(cmd.sheetId);
                    break;
                case "EVALUATE_ALL_SHEETS":
                    this.evaluateAllSheets();
                    break;
            }
        }
        finalize() {
            const sheetId = this.getters.getActiveSheetId();
            if (!this.isUpToDate.has(sheetId)) {
                this.evaluate(sheetId);
                this.isUpToDate.add(sheetId);
            }
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        evaluateFormula(formulaString, sheetId = this.getters.getActiveSheetId()) {
            let formula = normalize(formulaString);
            const compiledFormula = compile(formula);
            const params = this.getFormulaParameters(() => { });
            const ranges = [];
            for (let xc of formula.dependencies.references) {
                ranges.push(this.getters.getRangeFromSheetXC(sheetId, xc));
            }
            const dependencies = { ...formula.dependencies, references: ranges };
            return compiledFormula(dependencies, sheetId, ...params);
        }
        /**
         * Return the value of each cell in the range as they are displayed in the grid.
         */
        getRangeFormattedValues(range) {
            const sheet = this.getters.tryGetSheet(range.sheetId);
            if (sheet === undefined)
                return [[]];
            return mapCellsInZone(range.zone, sheet, (cell) => this.getters.getCellText(cell, this.getters.shouldShowFormulas()), "");
        }
        /**
         * Return the value of each cell in the range.
         */
        getRangeValues(range) {
            const sheet = this.getters.tryGetSheet(range.sheetId);
            if (sheet === undefined)
                return [[]];
            return mapCellsInZone(range.zone, sheet, (cell) => cell.evaluated.value);
        }
        // ---------------------------------------------------------------------------
        // Evaluator
        // ---------------------------------------------------------------------------
        evaluate(sheetId) {
            const cells = this.getters.getCells(sheetId);
            const params = this.getFormulaParameters(computeValue);
            const visited = {};
            for (let cell of Object.values(cells)) {
                computeValue(cell, sheetId);
            }
            function handleError(e, cell) {
                if (!(e instanceof Error)) {
                    e = new Error(e);
                }
                if (cell.evaluated.value !== "#CYCLE") {
                    cell.assignValue("#ERROR");
                    // apply function name
                    const __lastFnCalled = params[2].__lastFnCalled || "";
                    cell.assignError("#ERROR", e.message.replace("[[FUNCTION_NAME]]", __lastFnCalled));
                }
            }
            function computeValue(cell, sheetId) {
                if (!cell.isFormula()) {
                    return;
                }
                const cellId = cell.id;
                if (cellId in visited) {
                    if (visited[cellId] === null) {
                        cell.assignError("#CYCLE", _lt("Circular reference"));
                    }
                    return;
                }
                visited[cellId] = null;
                try {
                    params[2].__originCellXC = () => {
                        // compute the value lazily for performance reasons
                        const position = params[2].getters.getCellPosition(cellId);
                        return toXC(position.col, position.row);
                    };
                    cell.assignValue(cell.compiledFormula(cell.dependencies, sheetId, ...params));
                    if (Array.isArray(cell.evaluated.value)) {
                        // if a value returns an array (like =A1:A3)
                        throw new Error(_lt("This formula depends on invalid values"));
                    }
                }
                catch (e) {
                    handleError(e, cell);
                }
                visited[cellId] = true;
            }
        }
        /**
         * Return all functions necessary to properly evaluate a formula:
         * - a refFn function to read any reference, cell or range of a normalized formula
         * - a range function to convert any reference to a proper value array
         * - an evaluation context
         */
        getFormulaParameters(computeValue) {
            const evalContext = Object.assign(Object.create(functionMap), this.evalContext, {
                getters: this.getters,
            });
            const sheets = this.getters.getEvaluationSheets();
            function readCell(range) {
                var _a;
                let cell;
                const s = sheets[range.sheetId];
                if (s) {
                    cell = (_a = s.rows[range.zone.top]) === null || _a === void 0 ? void 0 : _a.cells[range.zone.left];
                }
                else {
                    throw new Error(_lt("Invalid sheet name"));
                }
                if (!cell || cell.isEmpty()) {
                    // magic "empty" value
                    // Returning null instead of undefined will ensure that we don't
                    // fall back on the default value of the argument provided to the formula's compute function
                    return null;
                }
                return getCellValue(cell, range.sheetId);
            }
            function getCellValue(cell, sheetId) {
                computeValue(cell, sheetId);
                if (cell.evaluated.type === CellValueType.error) {
                    throw new Error(_lt("This formula depends on invalid values"));
                }
                return cell.evaluated.value;
            }
            /**
             * Return a range of values. It is a list of col values.
             *
             * Note that each col is possibly sparse: it only contain the values of cells
             * that are actually present in the grid.
             */
            function _range(range) {
                const sheet = sheets[range.sheetId];
                if (!isZoneValid(range.zone)) {
                    throw new Error(_lt("Invalid reference"));
                }
                // Performance issue: Avoid fetching data on positions that are out of the spreadsheet
                // e.g. A1:ZZZ9999 in a sheet with 10 cols and 10 rows should ignore everything past J10 and return a 10x10 array
                const sheetZone = {
                    top: 0,
                    bottom: sheet.rows.length - 1,
                    left: 0,
                    right: sheet.cols.length - 1,
                };
                const result = [];
                const zone = intersection(range.zone, sheetZone);
                if (!zone) {
                    result.push([]);
                    return result;
                }
                // Performance issue: nested loop is faster than a map here
                for (let col = zone.left; col <= zone.right; col++) {
                    const rowValues = [];
                    for (let row = zone.top; row <= zone.bottom; row++) {
                        const cell = evalContext.getters.getCell(range.sheetId, col, row);
                        rowValues.push(cell ? getCellValue(cell, range.sheetId) : undefined);
                    }
                    result.push(rowValues);
                }
                return result;
            }
            /**
             * Returns the value of the cell(s) used in reference
             *
             * @param position the index in the references array
             * @param references all the references used in the current formula
             * @param sheetId the sheet that is currently being evaluated, if a reference does not
             *        include a sheet, it is the id of the sheet of the reference to be used
             * @param isMeta if a reference is supposed to be used in a `meta` parameter as described in the
             *        function for which this parameter is used, we just return the string of the parameter.
             *        The `compute` of the formula's function must process it completely
             */
            function refFn(position, references, sheetId, isMeta, functionName, paramNumber) {
                const range = references[position];
                if (isMeta) {
                    return evalContext.getters.getRangeString(range, sheetId);
                }
                if (!isZoneValid(range.zone)) {
                    throw new Error(_lt("Invalid reference"));
                }
                // if the formula definition could have accepted a range, we would pass through the _range function and not here
                if (range.zone.bottom !== range.zone.top || range.zone.left !== range.zone.right) {
                    throw new Error(paramNumber
                        ? _lt("Function %s expects the parameter %s to be a single value or a single cell reference, not a range.", functionName.toString(), paramNumber.toString())
                        : _lt("Function %s expects its parameters to be single values or single cell references, not ranges.", functionName.toString()));
                }
                if (range.invalidSheetName) {
                    throw new Error(_lt("Invalid sheet name: %s", range.invalidSheetName));
                }
                return readCell(range);
            }
            /**
             * Return the values of the cell(s) used in reference, but always in the format of a range even
             * if a single cell is referenced. This is useful for the formulas that describe parameters as
             * range<number> etc.
             *
             * the parameters are the same as refFn, except that these parameters cannot be Meta
             */
            function range(position, references, sheetId) {
                return _range(references[position]);
            }
            return [refFn, range, evalContext];
        }
        /**
         * Triggers an evaluation of all cells on all sheets.
         */
        evaluateAllSheets() {
            for (const sheetId of this.getters.getVisibleSheets()) {
                this.evaluate(sheetId);
                this.isUpToDate.add(sheetId);
            }
        }
    }
    EvaluationPlugin.getters = ["evaluateFormula", "getRangeFormattedValues", "getRangeValues"];
    EvaluationPlugin.modes = ["normal"];

    const GraphColors = [
        // the same colors as those used in odoo reporting
        "rgb(31,119,180)",
        "rgb(255,127,14)",
        "rgb(174,199,232)",
        "rgb(255,187,120)",
        "rgb(44,160,44)",
        "rgb(152,223,138)",
        "rgb(214,39,40)",
        "rgb(255,152,150)",
        "rgb(148,103,189)",
        "rgb(197,176,213)",
        "rgb(140,86,75)",
        "rgb(196,156,148)",
        "rgb(227,119,194)",
        "rgb(247,182,210)",
        "rgb(127,127,127)",
        "rgb(199,199,199)",
        "rgb(188,189,34)",
        "rgb(219,219,141)",
        "rgb(23,190,207)",
        "rgb(158,218,229)",
    ];
    class ChartColors {
        constructor() {
            this.graphColorIndex = 0;
        }
        next() {
            return GraphColors[this.graphColorIndex++ % GraphColors.length];
        }
    }

    class EvaluationChartPlugin extends UIPlugin {
        constructor() {
            super(...arguments);
            // contains the configuration of the chart with it's values like they should be displayed,
            // as well as all the options needed for the chart library to work correctly
            this.chartRuntime = {};
            this.outOfDate = new Set();
        }
        handle(cmd) {
            if (invalidateEvaluationCommands.has(cmd.type) ||
                cmd.type === "EVALUATE_CELLS" ||
                (cmd.type === "UPDATE_CELL" && "content" in cmd)) {
                for (let chartId of Object.keys(this.chartRuntime)) {
                    this.outOfDate.add(chartId);
                }
            }
            switch (cmd.type) {
                case "UPDATE_CHART":
                case "CREATE_CHART":
                    const chartDefinition = this.getters.getChartDefinition(cmd.id);
                    this.chartRuntime[cmd.id] = this.mapDefinitionToRuntime(chartDefinition);
                    break;
                case "DELETE_FIGURE":
                    delete this.chartRuntime[cmd.id];
                    break;
                case "REFRESH_CHART":
                    this.evaluateUsedSheets([cmd.id]);
                    this.outOfDate.add(cmd.id);
                    break;
                case "ACTIVATE_SHEET":
                    const chartsIds = this.getters.getChartsIdBySheet(cmd.sheetIdTo);
                    this.evaluateUsedSheets(chartsIds);
                    break;
                case "DELETE_SHEET":
                    for (let chartId of Object.keys(this.chartRuntime)) {
                        if (!this.getters.getChartDefinition(chartId)) {
                            delete this.chartRuntime[chartId];
                        }
                    }
                    break;
            }
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        getChartRuntime(figureId) {
            if (this.outOfDate.has(figureId) || !(figureId in this.chartRuntime)) {
                const chartDefinition = this.getters.getChartDefinition(figureId);
                if (chartDefinition === undefined)
                    return;
                this.chartRuntime[figureId] = this.mapDefinitionToRuntime(chartDefinition);
                this.outOfDate.delete(figureId);
            }
            return this.chartRuntime[figureId];
        }
        truncateLabel(label) {
            if (!label) {
                return "";
            }
            if (label.length > MAX_CHAR_LABEL) {
                return label.substring(0, MAX_CHAR_LABEL) + "…";
            }
            return label;
        }
        getDefaultConfiguration(definition, labels) {
            const legend = {};
            if (!definition.labelRange && definition.dataSets.length === 1) {
                legend.display = false;
            }
            else {
                legend.position = definition.legendPosition;
            }
            const config = {
                type: definition.type,
                options: {
                    legend,
                    // https://www.chartjs.org/docs/latest/general/responsive.html
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: { left: 20, right: 20, top: definition.title ? 10 : 25, bottom: 10 },
                    },
                    elements: {
                        line: {
                            fill: false, // do not fill the area under line charts
                        },
                        point: {
                            hitRadius: 15, // increased hit radius to display point tooltip when hovering nearby
                        },
                    },
                    animation: {
                        duration: 0, // general animation time
                    },
                    hover: {
                        animationDuration: 10, // duration of animations when hovering an item
                    },
                    responsiveAnimationDuration: 0,
                    title: {
                        display: !!definition.title,
                        fontSize: 22,
                        fontStyle: "normal",
                        text: definition.title,
                    },
                },
                data: {
                    labels: labels.map(this.truncateLabel),
                    datasets: [],
                },
            };
            if (definition.type !== "pie") {
                config.options.scales = {
                    xAxes: [
                        {
                            ticks: {
                                // x axis configuration
                                maxRotation: 60,
                                minRotation: 15,
                                padding: 5,
                                labelOffset: 2,
                            },
                        },
                    ],
                    yAxes: [
                        {
                            position: definition.verticalAxisPosition,
                            ticks: {
                                // y axis configuration
                                beginAtZero: true, // the origin of the y axis is always zero
                            },
                        },
                    ],
                };
                if (definition.type === "bar" && definition.stackedBar) {
                    config.options.scales.xAxes[0].stacked = true;
                    config.options.scales.yAxes[0].stacked = true;
                }
            }
            else {
                config.options.tooltips = {
                    callbacks: {
                        title: function (tooltipItems, data) {
                            return data.datasets[tooltipItems[0].datasetIndex].label;
                        },
                    },
                };
            }
            return config;
        }
        getSheetIdsUsedInChart(chartDefinition) {
            const sheetIds = new Set();
            for (let ds of chartDefinition.dataSets) {
                sheetIds.add(ds.dataRange.sheetId);
            }
            if (chartDefinition.labelRange) {
                sheetIds.add(chartDefinition.labelRange.sheetId);
            }
            return sheetIds;
        }
        evaluateUsedSheets(chartsIds) {
            const usedSheetsId = new Set();
            for (let chartId of chartsIds) {
                const chartDefinition = this.getters.getChartDefinition(chartId);
                const sheetsIds = chartDefinition !== undefined ? this.getSheetIdsUsedInChart(chartDefinition) : [];
                sheetsIds.forEach((sheetId) => {
                    if (sheetId !== this.getters.getActiveSheetId()) {
                        usedSheetsId.add(sheetId);
                    }
                });
            }
            for (let sheetId of usedSheetsId) {
                this.dispatch("EVALUATE_CELLS", { sheetId });
            }
        }
        mapDefinitionToRuntime(definition) {
            let labels = [];
            if (definition.labelRange) {
                if (!definition.labelRange.invalidXc && !definition.labelRange.invalidSheetName) {
                    labels = this.getters.getRangeFormattedValues(definition.labelRange).flat(1);
                }
            }
            else if (definition.dataSets.length === 1) {
                for (let i = 0; i < this.getData(definition.dataSets[0], definition.sheetId).length; i++) {
                    labels.push("");
                }
            }
            else {
                if (definition.dataSets[0]) {
                    const ranges = this.getData(definition.dataSets[0], definition.sheetId);
                    labels = range(0, ranges.length).map((r) => r.toString());
                }
            }
            const runtime = this.getDefaultConfiguration(definition, labels);
            const colors = new ChartColors();
            const pieColors = [];
            if (definition.type === "pie") {
                const maxLength = Math.max(...definition.dataSets.map((ds) => this.getData(ds, definition.sheetId).length));
                for (let i = 0; i <= maxLength; i++) {
                    pieColors.push(colors.next());
                }
            }
            for (const [dsIndex, ds] of Object.entries(definition.dataSets)) {
                let label;
                if (ds.labelCell) {
                    const labelRange = ds.labelCell;
                    const cell = labelRange
                        ? this.getters.getCell(labelRange.sheetId, labelRange.zone.left, labelRange.zone.top)
                        : undefined;
                    label =
                        cell && labelRange
                            ? this.truncateLabel(cell.formattedValue)
                            : (label = `${chartTerms.Series} ${parseInt(dsIndex) + 1}`);
                }
                else {
                    label = label = `${chartTerms.Series} ${parseInt(dsIndex) + 1}`;
                }
                const color = definition.type !== "pie" ? colors.next() : "#FFFFFF"; // white border for pie chart
                const dataset = {
                    label,
                    data: ds.dataRange ? this.getData(ds, definition.sheetId) : [],
                    lineTension: 0,
                    borderColor: color,
                    backgroundColor: color,
                };
                if (definition.type === "pie") {
                    // In case of pie graph, dataset.backgroundColor is an array of string
                    // @ts-ignore - we know dataset.data is an array
                    dataset.backgroundColor = pieColors;
                }
                runtime.data.datasets.push(dataset);
            }
            return runtime;
        }
        // TODO type this with Chart.js types.
        getData(ds, sheetId) {
            if (ds.dataRange) {
                const labelCellZone = ds.labelCell ? [zoneToXc(ds.labelCell.zone)] : [];
                const dataXC = recomputeZones([zoneToXc(ds.dataRange.zone)], labelCellZone)[0];
                if (dataXC === undefined) {
                    return [];
                }
                const dataRange = this.getters.getRangeFromSheetXC(ds.dataRange.sheetId, dataXC);
                return this.getters.getRangeValues(dataRange).flat(1);
            }
            return [];
        }
    }
    EvaluationChartPlugin.getters = ["getChartRuntime"];
    EvaluationChartPlugin.modes = ["normal"];

    // -----------------------------------------------------------------------------
    // Constants
    // -----------------------------------------------------------------------------
    class EvaluationConditionalFormatPlugin extends UIPlugin {
        constructor() {
            super(...arguments);
            this.isStale = true;
            // stores the computed styles in the format of computedStyles.sheetName[col][row] = Style
            this.computedStyles = {};
            this.computedIcons = {};
            /**
             * Execute the predicate to know if a conditional formatting rule should be applied to a cell
             */
            this.rulePredicate = {
                CellIsRule: (cell, rule) => {
                    if (cell && cell.evaluated.type === CellValueType.error) {
                        return false;
                    }
                    const values = rule.values.map(parsePrimitiveContent);
                    switch (rule.operator) {
                        case "IsEmpty":
                            return !isDefined(cell) || cell.evaluated.value.toString().trim() === "";
                        case "IsNotEmpty":
                            return isDefined(cell) && cell.evaluated.value.toString().trim() !== "";
                        case "BeginsWith":
                            if (!cell && values[0] === "") {
                                return false;
                            }
                            return (isDefined(cell) && (cell === null || cell === void 0 ? void 0 : cell.evaluated.value.toString().startsWith(values[0].toString())));
                        case "EndsWith":
                            if (!cell && values[0] === "") {
                                return false;
                            }
                            return isDefined(cell) && cell.evaluated.value.toString().endsWith(values[0].toString());
                        case "Between":
                            return (isDefined(cell) &&
                                cell.evaluated.value >= values[0] &&
                                cell.evaluated.value <= values[1]);
                        case "NotBetween":
                            return !(isDefined(cell) &&
                                cell.evaluated.value >= values[0] &&
                                cell.evaluated.value <= values[1]);
                        case "ContainsText":
                            return (isDefined(cell) && cell.evaluated.value.toString().indexOf(values[0].toString()) > -1);
                        case "NotContains":
                            return (!isDefined(cell) ||
                                !cell.evaluated.value ||
                                cell.evaluated.value.toString().indexOf(values[0].toString()) == -1);
                        case "GreaterThan":
                            return isDefined(cell) && cell.evaluated.value > values[0];
                        case "GreaterThanOrEqual":
                            return isDefined(cell) && cell.evaluated.value >= values[0];
                        case "LessThan":
                            return isDefined(cell) && cell.evaluated.value < values[0];
                        case "LessThanOrEqual":
                            return isDefined(cell) && cell.evaluated.value <= values[0];
                        case "NotEqual":
                            if (!isDefined(cell) && values[0] === "") {
                                return false;
                            }
                            return isDefined(cell) && cell.evaluated.value !== values[0];
                        case "Equal":
                            if (!cell && values[0] === "") {
                                return true;
                            }
                            return isDefined(cell) && cell.evaluated.value === values[0];
                        default:
                            console.warn(_lt("Not implemented operator %s for kind of conditional formatting:  %s", rule.operator, rule.type));
                    }
                    return false;
                },
            };
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        handle(cmd) {
            switch (cmd.type) {
                case "ACTIVATE_SHEET":
                    const activeSheet = cmd.sheetIdTo;
                    this.computedStyles[activeSheet] = this.computedStyles[activeSheet] || {};
                    this.computedIcons[activeSheet] = this.computedIcons[activeSheet] || {};
                    this.isStale = true;
                    break;
                case "AUTOFILL_CELL":
                    const sheetId = this.getters.getActiveSheetId();
                    const cfOrigin = this.getters.getRulesByCell(sheetId, cmd.originCol, cmd.originRow);
                    for (const cf of cfOrigin) {
                        this.adaptRules(sheetId, cf, [toXC(cmd.col, cmd.row)], []);
                    }
                    break;
                case "PASTE_CONDITIONAL_FORMAT":
                    this.pasteCf(cmd.origin, cmd.target, cmd.operation);
                    break;
                case "DUPLICATE_SHEET":
                case "CREATE_SHEET":
                case "DELETE_SHEET":
                case "ADD_CONDITIONAL_FORMAT":
                case "REMOVE_CONDITIONAL_FORMAT":
                case "REMOVE_COLUMNS_ROWS":
                case "ADD_COLUMNS_ROWS":
                case "EVALUATE_CELLS":
                case "UPDATE_CELL":
                case "UNDO":
                case "REDO":
                case "DELETE_CELL":
                case "INSERT_CELL":
                    this.isStale = true;
                    break;
            }
        }
        finalize() {
            if (this.isStale) {
                this.computeStyles();
                this.isStale = false;
            }
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        /**
         * Returns the conditional style property for a given cell reference in the active sheet or
         * undefined if this cell doesn't have a conditional style set.
         */
        getConditionalStyle(col, row) {
            var _a;
            const activeSheet = this.getters.getActiveSheetId();
            const styles = this.computedStyles[activeSheet];
            return styles && ((_a = styles[col]) === null || _a === void 0 ? void 0 : _a[row]);
        }
        getConditionalIcon(col, row) {
            var _a;
            const activeSheet = this.getters.getActiveSheetId();
            const icon = this.computedIcons[activeSheet];
            return icon && ((_a = icon[col]) === null || _a === void 0 ? void 0 : _a[row]);
        }
        // ---------------------------------------------------------------------------
        // Private
        // ---------------------------------------------------------------------------
        /**
         * Compute the styles according to the conditional formatting.
         * This computation must happen after the cell values are computed if they change
         *
         * This result of the computation will be in the state.cell[XC].conditionalStyle and will be the union of all the style
         * properties of the rules applied (in order).
         * So if a cell has multiple conditional formatting applied to it, and each affect a different value of the style,
         * the resulting style will have the combination of all those values.
         * If multiple conditional formatting use the same style value, they will be applied in order so that the last applied wins
         */
        computeStyles() {
            var _a;
            const activeSheetId = this.getters.getActiveSheetId();
            this.computedStyles[activeSheetId] = {};
            this.computedIcons[activeSheetId] = {};
            const computedStyle = this.computedStyles[activeSheetId];
            for (let cf of this.getters.getConditionalFormats(activeSheetId)) {
                try {
                    switch (cf.rule.type) {
                        case "ColorScaleRule":
                            for (let range of cf.ranges) {
                                this.applyColorScale(range, cf.rule);
                            }
                            break;
                        case "IconSetRule":
                            for (let range of cf.ranges) {
                                this.applyIcon(range, cf.rule);
                            }
                            break;
                        default:
                            for (let ref of cf.ranges) {
                                const zone = toZone(ref);
                                for (let row = zone.top; row <= zone.bottom; row++) {
                                    for (let col = zone.left; col <= zone.right; col++) {
                                        const pr = this.rulePredicate[cf.rule.type];
                                        let cell = this.getters.getCell(activeSheetId, col, row);
                                        if (pr && pr(cell, cf.rule)) {
                                            if (!computedStyle[col])
                                                computedStyle[col] = [];
                                            // we must combine all the properties of all the CF rules applied to the given cell
                                            computedStyle[col][row] = Object.assign(((_a = computedStyle[col]) === null || _a === void 0 ? void 0 : _a[row]) || {}, cf.rule.style);
                                        }
                                    }
                                }
                            }
                            break;
                    }
                }
                catch (_) {
                    // we don't care about the errors within the evaluation of a rule
                }
            }
        }
        parsePoint(range, threshold, functionName) {
            switch (threshold.type) {
                case "value":
                    return this.getters.evaluateFormula(`=${functionName}(${range})`);
                case "number":
                    return Number(threshold.value);
                case "percentage":
                    const min = this.getters.evaluateFormula(`=min(${range})`);
                    const max = this.getters.evaluateFormula(`=max(${range})`);
                    const delta = max - min;
                    return min + (delta * Number(threshold.value)) / 100;
                case "percentile":
                    return this.getters.evaluateFormula(`=PERCENTILE(${range},${Number(threshold.value) / 100})`);
                case "formula":
                    const value = threshold.value && this.getters.evaluateFormula(threshold.value);
                    return !(value instanceof Promise) ? value : null;
                default:
                    return null;
            }
        }
        applyIcon(range, rule) {
            const lowerInflectionPoint = this.parsePoint(range, rule.lowerInflectionPoint);
            const upperInflectionPoint = this.parsePoint(range, rule.upperInflectionPoint);
            if (lowerInflectionPoint === null ||
                upperInflectionPoint === null ||
                lowerInflectionPoint > upperInflectionPoint) {
                return;
            }
            const zone = toZone(range);
            const activeSheetId = this.getters.getActiveSheetId();
            const computedIcons = this.computedIcons[activeSheetId];
            const iconSet = [rule.icons.upper, rule.icons.middle, rule.icons.lower];
            for (let row = zone.top; row <= zone.bottom; row++) {
                for (let col = zone.left; col <= zone.right; col++) {
                    const cell = this.getters.getCell(activeSheetId, col, row);
                    if ((cell === null || cell === void 0 ? void 0 : cell.evaluated.type) !== CellValueType.number) {
                        continue;
                    }
                    const icon = this.computeIcon(cell.evaluated.value, upperInflectionPoint, rule.upperInflectionPoint.operator, lowerInflectionPoint, rule.lowerInflectionPoint.operator, iconSet);
                    if (!computedIcons[col]) {
                        computedIcons[col] = [];
                    }
                    computedIcons[col][row] = icon;
                }
            }
        }
        computeIcon(value, upperInflectionPoint, upperOperator, lowerInflectionPoint, lowerOperator, icons) {
            if ((upperOperator === "ge" && value >= upperInflectionPoint) ||
                (upperOperator === "gt" && value > upperInflectionPoint)) {
                return icons[0];
            }
            else if ((lowerOperator === "ge" && value >= lowerInflectionPoint) ||
                (lowerOperator === "gt" && value > lowerInflectionPoint)) {
                return icons[1];
            }
            return icons[2];
        }
        applyColorScale(range, rule) {
            var _a;
            const minValue = this.parsePoint(range, rule.minimum, "min");
            const midValue = rule.midpoint ? this.parsePoint(range, rule.midpoint) : null;
            const maxValue = this.parsePoint(range, rule.maximum, "max");
            if (minValue === null ||
                maxValue === null ||
                minValue >= maxValue ||
                (midValue && (minValue >= midValue || midValue >= maxValue))) {
                return;
            }
            const zone = toZone(range);
            const activeSheetId = this.getters.getActiveSheetId();
            const computedStyle = this.computedStyles[activeSheetId];
            const colorCellArgs = [];
            if (rule.midpoint && midValue) {
                colorCellArgs.push({
                    minValue,
                    minColor: rule.minimum.color,
                    colorDiffUnit: this.computeColorDiffUnits(minValue, midValue, rule.minimum.color, rule.midpoint.color),
                });
                colorCellArgs.push({
                    minValue: midValue,
                    minColor: rule.midpoint.color,
                    colorDiffUnit: this.computeColorDiffUnits(midValue, maxValue, rule.midpoint.color, rule.maximum.color),
                });
            }
            else {
                colorCellArgs.push({
                    minValue,
                    minColor: rule.minimum.color,
                    colorDiffUnit: this.computeColorDiffUnits(minValue, maxValue, rule.minimum.color, rule.maximum.color),
                });
            }
            for (let row = zone.top; row <= zone.bottom; row++) {
                for (let col = zone.left; col <= zone.right; col++) {
                    const cell = this.getters.getCell(activeSheetId, col, row);
                    if ((cell === null || cell === void 0 ? void 0 : cell.evaluated.type) === CellValueType.number) {
                        const value = clip(cell.evaluated.value, minValue, maxValue);
                        let color;
                        if (colorCellArgs.length === 2 && midValue) {
                            color =
                                value <= midValue
                                    ? this.colorCell(value, colorCellArgs[0].minValue, colorCellArgs[0].minColor, colorCellArgs[0].colorDiffUnit)
                                    : this.colorCell(value, colorCellArgs[1].minValue, colorCellArgs[1].minColor, colorCellArgs[1].colorDiffUnit);
                        }
                        else {
                            color = this.colorCell(value, colorCellArgs[0].minValue, colorCellArgs[0].minColor, colorCellArgs[0].colorDiffUnit);
                        }
                        if (!computedStyle[col])
                            computedStyle[col] = [];
                        computedStyle[col][row] = ((_a = computedStyle[col]) === null || _a === void 0 ? void 0 : _a[row]) || {};
                        computedStyle[col][row].fillColor = "#" + colorNumberString(color);
                    }
                }
            }
        }
        computeColorDiffUnits(minValue, maxValue, minColor, maxColor) {
            const deltaValue = maxValue - minValue;
            const deltaColorR = ((minColor >> 16) % 256) - ((maxColor >> 16) % 256);
            const deltaColorG = ((minColor >> 8) % 256) - ((maxColor >> 8) % 256);
            const deltaColorB = (minColor % 256) - (maxColor % 256);
            const colorDiffUnitR = deltaColorR / deltaValue;
            const colorDiffUnitG = deltaColorG / deltaValue;
            const colorDiffUnitB = deltaColorB / deltaValue;
            return [colorDiffUnitR, colorDiffUnitG, colorDiffUnitB];
        }
        colorCell(value, minValue, minColor, colorDiffUnit) {
            const [colorDiffUnitR, colorDiffUnitG, colorDiffUnitB] = colorDiffUnit;
            const r = Math.round(((minColor >> 16) % 256) - colorDiffUnitR * (value - minValue));
            const g = Math.round(((minColor >> 8) % 256) - colorDiffUnitG * (value - minValue));
            const b = Math.round((minColor % 256) - colorDiffUnitB * (value - minValue));
            return (r << 16) | (g << 8) | b;
        }
        /**
         * Add or remove cells to a given conditional formatting rule.
         */
        adaptRules(sheetId, cf, toAdd, toRemove) {
            if (toAdd.length === 0 && toRemove.length === 0) {
                return;
            }
            const rules = this.getters.getConditionalFormats(sheetId);
            const replaceIndex = rules.findIndex((c) => c.id === cf.id);
            let currentRanges = [];
            if (replaceIndex > -1) {
                currentRanges = rules[replaceIndex].ranges;
            }
            currentRanges = currentRanges.concat(toAdd);
            const newRange = recomputeZones(currentRanges, toRemove);
            this.dispatch("ADD_CONDITIONAL_FORMAT", {
                cf: {
                    id: cf.id,
                    rule: cf.rule,
                    stopIfTrue: cf.stopIfTrue,
                },
                target: newRange.map(toZone),
                sheetId,
            });
        }
        pasteCf(origin, target, operation) {
            const xc = toXC(target.col, target.row);
            for (let rule of this.getters.getConditionalFormats(origin.sheetId)) {
                for (let range of rule.ranges) {
                    if (isInside(origin.col, origin.row, toZone(range))) {
                        const cf = rule;
                        const toRemoveRange = [];
                        if (operation === "CUT") {
                            //remove from current rule
                            toRemoveRange.push(toXC(origin.col, origin.row));
                        }
                        if (origin.sheetId === target.sheetId) {
                            this.adaptRules(origin.sheetId, cf, [xc], toRemoveRange);
                        }
                        else {
                            this.adaptRules(target.sheetId, cf, [xc], []);
                            this.adaptRules(origin.sheetId, cf, [], toRemoveRange);
                        }
                    }
                }
            }
        }
    }
    EvaluationConditionalFormatPlugin.getters = ["getConditionalStyle", "getConditionalIcon"];
    EvaluationConditionalFormatPlugin.modes = ["normal"];

    const BORDER_COLOR = "#8B008B";
    const BACKGROUND_COLOR = "#8B008B33";
    var Direction;
    (function (Direction) {
        Direction[Direction["previous"] = -1] = "previous";
        Direction[Direction["current"] = 0] = "current";
        Direction[Direction["next"] = 1] = "next";
    })(Direction || (Direction = {}));
    /**
     * Find and Replace Plugin
     *
     * This plugin is used in combination with the find_and_replace sidePanel
     * It is used to 'highlight' cells that match an input string according to
     * the given searchOptions. The second part of this plugin makes it possible
     * (again with the find_and_replace sidePanel), to replace the values that match
     * the search with a new value.
     */
    class FindAndReplacePlugin extends UIPlugin {
        constructor() {
            super(...arguments);
            this.searchMatches = [];
            this.selectedMatchIndex = null;
            this.currentSearchRegex = null;
            this.searchOptions = {
                matchCase: false,
                exactMatch: false,
                searchFormulas: false,
            };
            this.replaceOptions = {
                modifyFormulas: false,
            };
            this.toSearch = "";
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        handle(cmd) {
            switch (cmd.type) {
                case "UPDATE_SEARCH":
                    this.updateSearch(cmd.toSearch, cmd.searchOptions);
                    break;
                case "CLEAR_SEARCH":
                    this.clearSearch();
                    break;
                case "SELECT_SEARCH_PREVIOUS_MATCH":
                    this.selectNextCell(Direction.previous);
                    break;
                case "SELECT_SEARCH_NEXT_MATCH":
                    this.selectNextCell(Direction.next);
                    break;
                case "REPLACE_SEARCH":
                    this.replace(cmd.replaceWith, cmd.replaceOptions);
                    break;
                case "REPLACE_ALL_SEARCH":
                    this.replaceAll(cmd.replaceWith, cmd.replaceOptions);
                    break;
                case "UNDO":
                case "REDO":
                case "REMOVE_COLUMNS_ROWS":
                case "ADD_COLUMNS_ROWS":
                    this.clearSearch();
                    break;
                case "ACTIVATE_SHEET":
                case "REFRESH_SEARCH":
                    this.refreshSearch();
                    break;
            }
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        getSearchMatches() {
            return this.searchMatches;
        }
        getCurrentSelectedMatchIndex() {
            return this.selectedMatchIndex;
        }
        // ---------------------------------------------------------------------------
        // Search
        // ---------------------------------------------------------------------------
        /**
         * Will update the current searchOptions and accordingly update the regex.
         * It will then search for matches using the regex and store them.
         */
        updateSearch(toSearch, searchOptions) {
            this.searchOptions = searchOptions;
            if (toSearch !== this.toSearch) {
                this.selectedMatchIndex = null;
            }
            this.toSearch = toSearch;
            this.updateRegex();
            this.refreshSearch();
        }
        /**
         * refresh the matches according to the current search options
         */
        refreshSearch() {
            const matches = this.findMatches();
            this.searchMatches = matches;
            this.selectNextCell(Direction.current);
        }
        /**
         * Updates the regex based on the current searchOptions and
         * the value toSearch
         */
        updateRegex() {
            let searchValue = this.toSearch;
            const flags = !this.searchOptions.matchCase ? "i" : "";
            if (this.searchOptions.exactMatch) {
                searchValue = `^${searchValue}$`;
            }
            this.currentSearchRegex = RegExp(searchValue, flags);
        }
        /**
         * Find matches using the current regex
         */
        findMatches() {
            const activeSheetId = this.getters.getActiveSheetId();
            const cells = this.getters.getCells(activeSheetId);
            const matches = [];
            if (this.toSearch) {
                for (const cell of Object.values(cells)) {
                    if (cell &&
                        this.currentSearchRegex &&
                        this.currentSearchRegex.test(this.searchOptions.searchFormulas
                            ? cell.isFormula()
                                ? cell.content
                                : String(cell.evaluated.value)
                            : String(cell.evaluated.value))) {
                        const position = this.getters.getCellPosition(cell.id);
                        const match = { col: position.col, row: position.row, selected: false };
                        matches.push(match);
                    }
                }
            }
            return matches.sort(this.sortByRowThenColumn);
        }
        sortByRowThenColumn(a, b) {
            if (a.row === b.row) {
                return a.col - b.col;
            }
            return a.row > b.row ? 1 : -1;
        }
        /**
         * Changes the selected search cell. Given a direction it will
         * Change the selection to the previous, current or nextCell,
         * if it exists otherwise it will set the selectedMatchIndex to null.
         * It will also reset the index to 0 if the search has changed.
         * It is also used to keep coherence between the selected searchMatch
         * and selectedMatchIndex.
         */
        selectNextCell(indexChange) {
            const matches = this.searchMatches;
            if (!matches.length) {
                this.selectedMatchIndex = null;
                return;
            }
            let nextIndex;
            if (this.selectedMatchIndex === null) {
                nextIndex = 0;
            }
            else {
                nextIndex = this.selectedMatchIndex + indexChange;
            }
            //modulo of negative value to be able to cycle in both directions with previous and next
            nextIndex = ((nextIndex % matches.length) + matches.length) % matches.length;
            if (this.selectedMatchIndex === null || this.selectedMatchIndex !== nextIndex) {
                this.selectedMatchIndex = nextIndex;
                this.dispatch("SELECT_CELL", { col: matches[nextIndex].col, row: matches[nextIndex].row });
            }
            for (let index = 0; index < this.searchMatches.length; index++) {
                this.searchMatches[index].selected = index === this.selectedMatchIndex;
            }
        }
        clearSearch() {
            this.toSearch = "";
            this.searchMatches = [];
            this.selectedMatchIndex = null;
            this.currentSearchRegex = null;
            this.searchOptions = {
                matchCase: false,
                exactMatch: false,
                searchFormulas: false,
            };
            this.replaceOptions = {
                modifyFormulas: false,
            };
        }
        // ---------------------------------------------------------------------------
        // Replace
        // ---------------------------------------------------------------------------
        /**
         * Replace the value of the currently selected match if the replaceOptions
         * allow it
         */
        replace(replaceWith, replaceOptions) {
            this.replaceOptions = replaceOptions;
            if (this.selectedMatchIndex === null || !this.currentSearchRegex) {
                return;
            }
            const matches = this.searchMatches;
            const selectedMatch = matches[this.selectedMatchIndex];
            const sheetId = this.getters.getActiveSheetId();
            const cellToReplace = this.getters.getCell(sheetId, selectedMatch.col, selectedMatch.row);
            const toReplace = this.toReplace(cellToReplace, sheetId);
            if (!cellToReplace || !toReplace) {
                this.selectNextCell(Direction.next);
            }
            else {
                const replaceRegex = new RegExp(this.currentSearchRegex.source, this.currentSearchRegex.flags + "g");
                const newContent = toReplace.toString().replace(replaceRegex, replaceWith);
                this.dispatch("UPDATE_CELL", {
                    sheetId: this.getters.getActiveSheetId(),
                    col: selectedMatch.col,
                    row: selectedMatch.row,
                    content: newContent,
                });
                this.searchMatches.splice(this.selectedMatchIndex, 1);
                this.selectNextCell(Direction.current);
            }
        }
        /**
         * Apply the replace function to all the matches one time.
         */
        replaceAll(replaceWith, replaceOptions) {
            const matchCount = this.searchMatches.length;
            for (let i = 0; i < matchCount; i++) {
                this.replace(replaceWith, replaceOptions);
            }
        }
        /**
         * Determines if the content, the value or nothing should be replaced,
         * based on the search and replace options
         */
        toReplace(cell, sheetId) {
            if (cell) {
                if (this.searchOptions.searchFormulas && cell.isFormula()) {
                    return cell.content;
                }
                else if (this.replaceOptions.modifyFormulas || !cell.isFormula()) {
                    return cell.evaluated.value.toString();
                }
            }
            return null;
        }
        // ---------------------------------------------------------------------------
        // Grid rendering
        // ---------------------------------------------------------------------------
        drawGrid(renderingContext) {
            const { ctx, viewport } = renderingContext;
            const sheetId = this.getters.getActiveSheetId();
            for (const match of this.searchMatches) {
                const merge = this.getters.getMerge(sheetId, match.col, match.row);
                const left = merge ? merge.left : match.col;
                const right = merge ? merge.right : match.col;
                const top = merge ? merge.top : match.row;
                const bottom = merge ? merge.bottom : match.row;
                const [x, y, width, height] = this.getters.getRect({ top, left, right, bottom }, viewport);
                if (width > 0 && height > 0) {
                    ctx.fillStyle = BACKGROUND_COLOR;
                    ctx.fillRect(x, y, width, height);
                    if (match.selected) {
                        ctx.strokeStyle = BORDER_COLOR;
                        ctx.strokeRect(x, y, width, height);
                    }
                }
            }
        }
    }
    FindAndReplacePlugin.layers = [3 /* Search */];
    FindAndReplacePlugin.getters = ["getSearchMatches", "getCurrentSelectedMatchIndex"];

    class FormatPlugin extends UIPlugin {
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        handle(cmd) {
            switch (cmd.type) {
                case "SET_DECIMAL":
                    this.setDecimal(cmd.sheetId, cmd.target, cmd.step);
                    break;
            }
        }
        /**
         * This function allows to adjust the quantity of decimal places after a decimal
         * point on cells containing number value. It does this by changing the cells
         * format. Values aren't modified.
         *
         * The change of the decimal quantity is done one by one, the sign of the step
         * variable indicates whether we are increasing or decreasing.
         *
         * If several cells are in the zone, the format resulting from the change of the
         * first cell (with number type) will be applied to the whole zone.
         */
        setDecimal(sheetId, zones, step) {
            // Find the first cell with a number value and get the format
            const numberFormat = this.searchNumberFormat(sheetId, zones);
            if (numberFormat !== undefined) {
                // Depending on the step sign, increase or decrease the decimal representation
                // of the format
                const newFormat = this.changeDecimalFormat(numberFormat, step);
                // Apply the new format on the whole zone
                this.dispatch("SET_FORMATTING", {
                    sheetId,
                    target: zones,
                    format: newFormat,
                });
            }
        }
        /**
         * Take a range of cells and return the format of the first cell containing a
         * number value. Returns a default format if the cell hasn't format. Returns
         * undefined if no number value in the range.
         */
        searchNumberFormat(sheetId, zones) {
            var _a;
            for (let zone of zones) {
                for (let row = zone.top; row <= zone.bottom; row++) {
                    for (let col = zone.left; col <= zone.right; col++) {
                        const cell = this.getters.getCell(sheetId, col, row);
                        if ((cell === null || cell === void 0 ? void 0 : cell.evaluated.type) === CellValueType.number &&
                            !((_a = cell.format) === null || _a === void 0 ? void 0 : _a.match(DATETIME_FORMAT)) // reject dates
                        ) {
                            return cell.format || this.setDefaultNumberFormat(cell.evaluated.value);
                        }
                    }
                }
            }
            return undefined;
        }
        /**
         * Function used to give the default format of a cell with a number for value.
         * It is considered that the default format of a number is 0 followed by as many
         * 0 as there are decimal places.
         *
         * Example:
         * - 1 --> '0'
         * - 123 --> '0'
         * - 12345 --> '0'
         * - 42.1 --> '0.0'
         * - 456.0001 --> '0.0000'
         */
        setDefaultNumberFormat(cellValue) {
            const strValue = cellValue.toString();
            const parts = strValue.split(".");
            if (parts.length === 1) {
                return "0";
            }
            return "0." + Array(parts[1].length + 1).join("0");
        }
        /**
         * This function take a cell format representation and return a new format representation
         * with more or less decimal places.
         *
         * If the format doesn't look like a digital format (means that not contain '0')
         * or if this one cannot be increased or decreased, the returned format will be
         * the same.
         *
         * This function aims to work with all possible formats as well as custom formats.
         *
         * Examples of format changed by this function:
         * - "0" (step = 1) --> "0.0"
         * - "0.000%" (step = 1) --> "0.0000%"
         * - "0.00" (step = -1) --> "0.0"
         * - "0%" (step = -1) --> "0%"
         * - "#,##0.0" (step = -1) --> "#,##0"
         * - "#,##0;0.0%;0.000" (step = 1) --> "#,##0.0;0.00%;0.0000"
         */
        changeDecimalFormat(format, step) {
            const sign = Math.sign(step);
            // According to the representation of the cell format. A format can contain
            // up to 4 sub-formats which can be applied depending on the value of the cell
            // (among positive / negative / zero / text), each of these sub-format is separated
            // by ';' in the format. We need to make the change on each sub-format.
            const subFormats = format.split(";");
            let newSubFormats = [];
            for (let subFormat of subFormats) {
                const decimalPointPosition = subFormat.indexOf(".");
                const exponentPosition = subFormat.toUpperCase().indexOf("E");
                let newSubFormat;
                // the 1st step is to find the part of the zeros located before the
                // exponent (when existed)
                const subPart = exponentPosition > -1 ? subFormat.slice(0, exponentPosition) : subFormat;
                const zerosAfterDecimal = decimalPointPosition > -1 ? subPart.slice(decimalPointPosition).match(/0/g).length : 0;
                // the 2nd step is to add (or remove) zero after the last zeros obtained in
                // step 1
                const lastZeroPosition = subPart.lastIndexOf("0");
                if (lastZeroPosition > -1) {
                    if (sign > 0) {
                        // in this case we want to add decimal information
                        if (zerosAfterDecimal < maximumDecimalPlaces) {
                            newSubFormat =
                                subFormat.slice(0, lastZeroPosition + 1) +
                                    (zerosAfterDecimal === 0 ? ".0" : "0") +
                                    subFormat.slice(lastZeroPosition + 1);
                        }
                        else {
                            newSubFormat = subFormat;
                        }
                    }
                    else {
                        // in this case we want to remove decimal information
                        if (zerosAfterDecimal > 0) {
                            // remove last zero
                            newSubFormat =
                                subFormat.slice(0, lastZeroPosition) + subFormat.slice(lastZeroPosition + 1);
                            // if a zero always exist after decimal point else remove decimal point
                            if (zerosAfterDecimal === 1) {
                                newSubFormat =
                                    newSubFormat.slice(0, decimalPointPosition) +
                                        newSubFormat.slice(decimalPointPosition + 1);
                            }
                        }
                        else {
                            // zero after decimal isn't present, we can't remove zero
                            newSubFormat = subFormat;
                        }
                    }
                }
                else {
                    // no zeros are present in this format, we do nothing
                    newSubFormat = subFormat;
                }
                newSubFormats.push(newSubFormat);
            }
            return newSubFormats.join(";");
        }
    }
    FormatPlugin.modes = ["normal"];

    /**
     * HighlightPlugin
     */
    class HighlightPlugin extends UIPlugin {
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        getHighlights() {
            return this.prepareHighlights(this.getters.getComposerHighlights().concat(this.getters.getSelectionInputHighlights()));
        }
        // ---------------------------------------------------------------------------
        // Other
        // ---------------------------------------------------------------------------
        prepareHighlights(ranges) {
            if (ranges.length === 0) {
                return [];
            }
            const activeSheetId = this.getters.getActiveSheetId();
            const preparedHighlights = [];
            for (let [r1c1, color] of ranges) {
                const [xc, sheet] = r1c1.split("!").reverse();
                const sheetId = sheet ? this.getters.getSheetIdByName(sheet) : activeSheetId;
                if (sheetId) {
                    let zone = toZone(xc);
                    const { height, width } = zoneToDimension(zone);
                    zone = height * width === 1 ? this.getters.expandZone(activeSheetId, toZone(xc)) : zone;
                    preparedHighlights.push({ zone, color, sheet: sheetId });
                }
            }
            return preparedHighlights.filter((x) => x.zone.top >= 0 &&
                x.zone.left >= 0 &&
                x.zone.bottom < this.getters.getSheet(x.sheet).rows.length &&
                x.zone.right < this.getters.getSheet(x.sheet).cols.length);
        }
        // ---------------------------------------------------------------------------
        // Grid rendering
        // ---------------------------------------------------------------------------
        drawGrid(renderingContext) {
            // rendering selection highlights
            const { ctx, viewport, thinLineWidth } = renderingContext;
            const sheetId = this.getters.getActiveSheetId();
            const lineWidth = 3 * thinLineWidth;
            ctx.lineWidth = lineWidth;
            /**
             * We only need to draw the highlights of the current sheet.
             *
             * Note that there can be several times the same highlight in 'this.highlights'.
             * In order to avoid superposing the same color layer and modifying the final
             * opacity, we filter highlights to remove duplicates.
             */
            for (let h of this.getHighlights().filter((highlight, index) => 
            // For every highlight in the sheet, deduplicated by zone
            this.getHighlights().findIndex((h) => isEqual(h.zone, highlight.zone) && h.sheet === sheetId) === index)) {
                const [x, y, width, height] = this.getters.getRect(h.zone, viewport);
                if (width > 0 && height > 0) {
                    ctx.strokeStyle = h.color;
                    ctx.strokeRect(x + lineWidth / 2, y + lineWidth / 2, width - lineWidth, height - lineWidth);
                    ctx.globalCompositeOperation = "source-over";
                    ctx.fillStyle = h.color + "20";
                    ctx.fillRect(x + lineWidth, y + lineWidth, width - 2 * lineWidth, height - 2 * lineWidth);
                }
            }
        }
    }
    HighlightPlugin.modes = ["normal"];
    HighlightPlugin.layers = [1 /* Highlights */];
    HighlightPlugin.getters = ["getHighlights"];

    // -----------------------------------------------------------------------------
    // Constants, types, helpers, ...
    // -----------------------------------------------------------------------------
    function computeAlign(cell, isShowingFormulas) {
        if (cell.isFormula() && isShowingFormulas) {
            return "left";
        }
        return cell.defaultAlign;
    }
    function searchIndex(headers, offset) {
        let left = 0;
        let right = headers.length - 1;
        while (left <= right) {
            const index = Math.floor((left + right) / 2);
            const header = headers[index];
            if (offset < header.start) {
                right = index - 1;
            }
            else if (offset > header.end) {
                left = index + 1;
            }
            else if (header.isHidden) {
                left += 1;
            }
            else {
                return index;
            }
        }
        return -1;
    }
    class RendererPlugin extends UIPlugin {
        constructor() {
            super(...arguments);
            this.boxes = [];
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        /**
         * Return the index of a column given an offset x and a visible left col index.
         * It returns -1 if no column is found.
         */
        getColIndex(x, left, sheet) {
            if (x < HEADER_WIDTH) {
                return -1;
            }
            const cols = (sheet || this.getters.getActiveSheet()).cols;
            const adjustedX = x - HEADER_WIDTH + cols[left].start + 1;
            return searchIndex(cols, adjustedX);
        }
        getRowIndex(y, top, sheet) {
            if (y < HEADER_HEIGHT) {
                return -1;
            }
            const rows = (sheet || this.getters.getActiveSheet()).rows;
            const adjustedY = y - HEADER_HEIGHT + rows[top].start + 1;
            return searchIndex(rows, adjustedY);
        }
        getRect(zone, viewport) {
            const { left, top, right, bottom } = zone;
            let { offsetY, offsetX } = viewport;
            offsetX -= HEADER_WIDTH;
            offsetY -= HEADER_HEIGHT;
            const { cols, rows } = this.getters.getActiveSheet();
            const x = Math.max(cols[left].start - offsetX, HEADER_WIDTH);
            const width = cols[right].end - offsetX - x;
            const y = Math.max(rows[top].start - offsetY, HEADER_HEIGHT);
            const height = rows[bottom].end - offsetY - y;
            return [x, y, width, height];
        }
        /**
         * Check if a given position is visible in the viewport.
         */
        isVisibleInViewport(col, row, viewport) {
            const { right, left, top, bottom } = viewport;
            return row <= bottom && row >= top && col >= left && col <= right;
        }
        getEdgeScrollCol(x) {
            let canEdgeScroll = false;
            let direction = 0;
            let delay = 0;
            const { width } = this.getters.getViewportDimension();
            const { width: gridWidth } = this.getters.getGridDimension(this.getters.getActiveSheet());
            const { left, offsetX } = this.getters.getActiveSnappedViewport();
            if (x < HEADER_WIDTH && left > 0) {
                canEdgeScroll = true;
                direction = -1;
                delay = scrollDelay(HEADER_WIDTH - x);
            }
            else if (x > width && offsetX < gridWidth - width) {
                canEdgeScroll = true;
                direction = +1;
                delay = scrollDelay(x - width);
            }
            return { canEdgeScroll, direction, delay };
        }
        getEdgeScrollRow(y) {
            let canEdgeScroll = false;
            let direction = 0;
            let delay = 0;
            const { height } = this.getters.getViewportDimension();
            const { height: gridHeight } = this.getters.getGridDimension(this.getters.getActiveSheet());
            const { top, offsetY } = this.getters.getActiveSnappedViewport();
            if (y < HEADER_HEIGHT && top > 0) {
                canEdgeScroll = true;
                direction = -1;
                delay = scrollDelay(HEADER_HEIGHT - y);
            }
            else if (y > height && offsetY < gridHeight - height) {
                canEdgeScroll = true;
                direction = +1;
                delay = scrollDelay(y - height);
            }
            return { canEdgeScroll, direction, delay };
        }
        // ---------------------------------------------------------------------------
        // Grid rendering
        // ---------------------------------------------------------------------------
        drawGrid(renderingContext, layer) {
            switch (layer) {
                case 0 /* Background */:
                    this.boxes = this.getGridBoxes(renderingContext);
                    this.drawBackground(renderingContext);
                    this.drawCellBackground(renderingContext);
                    this.drawBorders(renderingContext);
                    this.drawTexts(renderingContext);
                    this.drawIcon(renderingContext);
                    break;
                case 7 /* Headers */:
                    this.drawHeaders(renderingContext);
                    break;
            }
        }
        drawBackground(renderingContext) {
            const { ctx, viewport, thinLineWidth } = renderingContext;
            let { offsetX, offsetY, top, left, bottom, right } = viewport;
            const { width, height } = this.getters.getViewportDimension();
            const { cols, rows, id: sheetId } = this.getters.getActiveSheet();
            // white background
            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, width, height);
            // background grid
            offsetX -= HEADER_WIDTH;
            offsetY -= HEADER_HEIGHT;
            if (!this.getters.getGridLinesVisibility(sheetId)) {
                return;
            }
            ctx.lineWidth = 2 * thinLineWidth;
            ctx.strokeStyle = CELL_BORDER_COLOR;
            ctx.beginPath();
            // vertical lines
            const lineHeight = Math.min(height, rows[bottom].end - offsetY);
            for (let i = left; i <= right; i++) {
                if (cols[i].isHidden) {
                    continue;
                }
                const x = cols[i].end - offsetX;
                ctx.moveTo(x, 0);
                ctx.lineTo(x, lineHeight);
            }
            // horizontal lines
            const lineWidth = Math.min(width, cols[right].end - offsetX);
            for (let i = top; i <= bottom; i++) {
                if (rows[i].isHidden) {
                    continue;
                }
                const y = rows[i].end - offsetY;
                ctx.moveTo(0, y);
                ctx.lineTo(lineWidth, y);
            }
            ctx.stroke();
        }
        drawCellBackground(renderingContext) {
            const { ctx, thinLineWidth } = renderingContext;
            ctx.lineWidth = 0.3 * thinLineWidth;
            const inset = 0.1 * thinLineWidth;
            ctx.strokeStyle = "#111";
            const areGridLinesVisible = this.getters.getGridLinesVisibility(this.getters.getActiveSheetId());
            for (let box of this.boxes) {
                // fill color
                let style = box.style;
                if (style && style.fillColor && style.fillColor !== "#ffffff") {
                    ctx.fillStyle = style.fillColor;
                    ctx.fillRect(box.x, box.y, box.width, box.height);
                    if (areGridLinesVisible) {
                        ctx.strokeRect(box.x + inset, box.y + inset, box.width - 2 * inset, box.height - 2 * inset);
                    }
                }
                if (box.error) {
                    ctx.fillStyle = "red";
                    ctx.beginPath();
                    ctx.moveTo(box.x + box.width - 5, box.y);
                    ctx.lineTo(box.x + box.width, box.y);
                    ctx.lineTo(box.x + box.width, box.y + 5);
                    ctx.fill();
                }
            }
        }
        drawBorders(renderingContext) {
            const { ctx, thinLineWidth } = renderingContext;
            for (let box of this.boxes) {
                // fill color
                let border = box.border;
                if (border) {
                    const { x, y, width, height } = box;
                    if (border.left) {
                        drawBorder(border.left, x, y, x, y + height);
                    }
                    if (border.top) {
                        drawBorder(border.top, x, y, x + width, y);
                    }
                    if (border.right) {
                        drawBorder(border.right, x + width, y, x + width, y + height);
                    }
                    if (border.bottom) {
                        drawBorder(border.bottom, x, y + height, x + width, y + height);
                    }
                }
            }
            function drawBorder([style, color], x1, y1, x2, y2) {
                ctx.strokeStyle = color;
                ctx.lineWidth = (style === "thin" ? 2 : 3) * thinLineWidth;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
        drawTexts(renderingContext) {
            const { ctx, thinLineWidth } = renderingContext;
            ctx.textBaseline = "middle";
            let currentFont;
            for (let box of this.boxes) {
                if (box.text) {
                    const style = box.style || {};
                    const align = box.align;
                    const italic = style.italic ? "italic " : "";
                    const weight = style.bold ? "bold" : DEFAULT_FONT_WEIGHT;
                    const sizeInPt = style.fontSize || DEFAULT_FONT_SIZE;
                    const size = fontSizeMap[sizeInPt];
                    const font = `${italic}${weight} ${size}px ${DEFAULT_FONT}`;
                    if (font !== currentFont) {
                        currentFont = font;
                        ctx.font = font;
                    }
                    ctx.fillStyle = style.textColor || "#000";
                    let x;
                    let y = box.y + box.height / 2 + 1;
                    if (align === "left") {
                        x = box.x + (box.image ? box.image.size + 2 * MIN_CF_ICON_MARGIN : MIN_CELL_TEXT_MARGIN);
                    }
                    else if (align === "right") {
                        x = box.x + box.width - MIN_CELL_TEXT_MARGIN;
                    }
                    else {
                        x = box.x + box.width / 2;
                    }
                    ctx.textAlign = align;
                    if (box.clipRect) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(...box.clipRect);
                        ctx.clip();
                    }
                    ctx.fillText(box.text, Math.round(x), Math.round(y));
                    if (style.strikethrough || style.underline) {
                        if (align === "right") {
                            x = x - box.textWidth;
                        }
                        else if (align === "center") {
                            x = x - box.textWidth / 2;
                        }
                        if (style.strikethrough) {
                            ctx.fillRect(x, y, box.textWidth, 2.6 * thinLineWidth);
                        }
                        if (style.underline) {
                            y = box.y + box.height / 2 + 1 + size / 2;
                            ctx.fillRect(x, y, box.textWidth, 1.3 * thinLineWidth);
                        }
                    }
                    if (box.clipRect) {
                        ctx.restore();
                    }
                }
            }
        }
        async drawIcon(renderingContext) {
            const { ctx } = renderingContext;
            for (let box of this.boxes) {
                if (box.image) {
                    let x = box.x;
                    let y = box.y;
                    const icon = box.image.image;
                    const size = box.image.size;
                    const margin = (box.height - size) / 2;
                    if (box.image.clipIcon) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(...box.image.clipIcon);
                        ctx.clip();
                    }
                    ctx.drawImage(icon, x + MIN_CF_ICON_MARGIN, y + margin, size, size);
                    if (box.image.clipIcon) {
                        ctx.restore();
                    }
                }
            }
        }
        drawHeaders(renderingContext) {
            const { ctx, viewport, thinLineWidth } = renderingContext;
            let { offsetX, offsetY, left, top, right, bottom } = viewport;
            const { width, height } = this.getters.getViewportDimension();
            offsetX -= HEADER_WIDTH;
            offsetY -= HEADER_HEIGHT;
            const selection = this.getters.getSelectedZones();
            const { cols, rows } = this.getters.getActiveSheet();
            const activeCols = this.getters.getActiveCols();
            const activeRows = this.getters.getActiveRows();
            ctx.fillStyle = BACKGROUND_HEADER_COLOR;
            ctx.font = `400 ${HEADER_FONT_SIZE}px ${DEFAULT_FONT}`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.lineWidth = thinLineWidth;
            ctx.strokeStyle = "#333";
            // background
            ctx.fillRect(0, 0, width, HEADER_HEIGHT);
            ctx.fillRect(0, 0, HEADER_WIDTH, height);
            // selection background
            ctx.fillStyle = BACKGROUND_HEADER_SELECTED_COLOR;
            for (let zone of selection) {
                const x1 = Math.max(HEADER_WIDTH, cols[zone.left].start - offsetX);
                const x2 = Math.max(HEADER_WIDTH, cols[zone.right].end - offsetX);
                const y1 = Math.max(HEADER_HEIGHT, rows[zone.top].start - offsetY);
                const y2 = Math.max(HEADER_HEIGHT, rows[zone.bottom].end - offsetY);
                ctx.fillStyle = activeCols.has(zone.left)
                    ? BACKGROUND_HEADER_ACTIVE_COLOR
                    : BACKGROUND_HEADER_SELECTED_COLOR;
                ctx.fillRect(x1, 0, x2 - x1, HEADER_HEIGHT);
                ctx.fillStyle = activeRows.has(zone.top)
                    ? BACKGROUND_HEADER_ACTIVE_COLOR
                    : BACKGROUND_HEADER_SELECTED_COLOR;
                ctx.fillRect(0, y1, HEADER_WIDTH, y2 - y1);
            }
            // 2 main lines
            ctx.beginPath();
            ctx.moveTo(HEADER_WIDTH, 0);
            ctx.lineTo(HEADER_WIDTH, height);
            ctx.moveTo(0, HEADER_HEIGHT);
            ctx.lineTo(width, HEADER_HEIGHT);
            ctx.strokeStyle = HEADER_BORDER_COLOR;
            ctx.stroke();
            ctx.beginPath();
            // column text + separator
            for (let i = left; i <= right; i++) {
                const col = cols[i];
                if (col.isHidden) {
                    continue;
                }
                ctx.fillStyle = activeCols.has(i) ? "#fff" : TEXT_HEADER_COLOR;
                ctx.fillText(col.name, (col.start + col.end) / 2 - offsetX, HEADER_HEIGHT / 2);
                ctx.moveTo(col.end - offsetX, 0);
                ctx.lineTo(col.end - offsetX, HEADER_HEIGHT);
            }
            // row text + separator
            for (let i = top; i <= bottom; i++) {
                const row = rows[i];
                if (row.isHidden) {
                    continue;
                }
                ctx.fillStyle = activeRows.has(i) ? "#fff" : TEXT_HEADER_COLOR;
                ctx.fillText(row.name, HEADER_WIDTH / 2, (row.start + row.end) / 2 - offsetY);
                ctx.moveTo(0, row.end - offsetY);
                ctx.lineTo(HEADER_WIDTH, row.end - offsetY);
            }
            ctx.stroke();
        }
        hasContent(col, row) {
            const sheetId = this.getters.getActiveSheetId();
            const cell = this.getters.getCell(sheetId, col, row);
            return (cell && !cell.isEmpty()) || this.getters.isInMerge(sheetId, col, row);
        }
        getGridBoxes(renderingContext) {
            const { viewport } = renderingContext;
            let { right, left, top, bottom, offsetX, offsetY } = viewport;
            offsetX -= HEADER_WIDTH;
            offsetY -= HEADER_HEIGHT;
            const showFormula = this.getters.shouldShowFormulas();
            const result = [];
            const { cols, rows, id: sheetId } = this.getters.getActiveSheet();
            // process all visible cells
            for (let rowNumber = top; rowNumber <= bottom; rowNumber++) {
                const row = rows[rowNumber];
                if (row.isHidden) {
                    continue;
                }
                for (let colNumber = left; colNumber <= right; colNumber++) {
                    const col = cols[colNumber];
                    if (col.isHidden) {
                        continue;
                    }
                    let cell = row.cells[colNumber];
                    const border = this.getters.getCellBorder(sheetId, colNumber, rowNumber);
                    const conditionalStyle = this.getters.getConditionalStyle(colNumber, rowNumber);
                    const iconStyle = this.getters.getConditionalIcon(colNumber, rowNumber);
                    if (!this.getters.isInMerge(sheetId, colNumber, rowNumber)) {
                        if (cell) {
                            const text = this.getters.getCellText(cell, showFormula);
                            let style = this.getters.getCellStyle(cell);
                            if (conditionalStyle) {
                                style = Object.assign({}, style, conditionalStyle);
                            }
                            let align = text
                                ? (style && style.align) || computeAlign(cell, showFormula)
                                : undefined;
                            let clipRect = null;
                            let clipIcon = null;
                            const textWidth = this.getters.getTextWidth(cell);
                            const fontsize = style.fontSize || DEFAULT_FONT_SIZE;
                            const iconWidth = fontSizeMap[fontsize];
                            const iconBoxWidth = iconStyle ? iconWidth + 2 * MIN_CF_ICON_MARGIN : 0;
                            const contentWidth = iconBoxWidth + textWidth;
                            const isOverflowing = contentWidth > cols[colNumber].size || fontSizeMap[fontsize] > row.size;
                            if (isOverflowing && cell.evaluated.type === CellValueType.number) {
                                align = align !== "center" ? "left" : align;
                            }
                            if (iconStyle) {
                                const colWidth = col.end - col.start;
                                clipRect = [
                                    col.start - offsetX + iconBoxWidth,
                                    row.start - offsetY,
                                    Math.max(0, colWidth - iconBoxWidth),
                                    row.size,
                                ];
                                clipIcon = [
                                    col.start - offsetX,
                                    row.start - offsetY,
                                    Math.min(iconBoxWidth, colWidth),
                                    row.size,
                                ];
                            }
                            else {
                                if (isOverflowing) {
                                    let c;
                                    let width;
                                    switch (align) {
                                        case "left":
                                            c = colNumber;
                                            while (c < right && !this.hasContent(c + 1, rowNumber)) {
                                                c++;
                                            }
                                            width = cols[c].end - col.start;
                                            if (width < textWidth || fontSizeMap[fontsize] > row.size) {
                                                clipRect = [col.start - offsetX, row.start - offsetY, width, row.size];
                                            }
                                            break;
                                        case "right":
                                            c = colNumber;
                                            while (c > left && !this.hasContent(c - 1, rowNumber)) {
                                                c--;
                                            }
                                            width = col.end - cols[c].start;
                                            if (width < textWidth || fontSizeMap[fontsize] > row.size) {
                                                clipRect = [cols[c].start - offsetX, row.start - offsetY, width, row.size];
                                            }
                                            break;
                                        case "center":
                                            let c1 = colNumber;
                                            while (c1 > left && !this.hasContent(c1 - 1, rowNumber)) {
                                                c1--;
                                            }
                                            let c2 = colNumber;
                                            while (c2 < right && !this.hasContent(c2 + 1, rowNumber)) {
                                                c2++;
                                            }
                                            const colLeft = Math.min(c1, colNumber);
                                            const colRight = Math.max(c2, colNumber);
                                            width = cols[colRight].end - cols[colLeft].start;
                                            if (width < textWidth ||
                                                colLeft === colNumber ||
                                                colRight === colNumber ||
                                                fontSizeMap[fontsize] > row.size) {
                                                clipRect = [
                                                    cols[colLeft].start - offsetX,
                                                    row.start - offsetY,
                                                    width,
                                                    row.size,
                                                ];
                                            }
                                            break;
                                    }
                                }
                            }
                            result.push({
                                x: col.start - offsetX,
                                y: row.start - offsetY,
                                width: col.size,
                                height: row.size,
                                text,
                                textWidth,
                                border,
                                style,
                                align,
                                clipRect,
                                error: cell.evaluated.type === CellValueType.error ? cell.evaluated.error : undefined,
                                image: iconStyle
                                    ? {
                                        type: "icon",
                                        size: iconWidth,
                                        clipIcon,
                                        image: ICONS[iconStyle].img,
                                    }
                                    : undefined,
                            });
                        }
                        else {
                            result.push({
                                x: col.start - offsetX,
                                y: row.start - offsetY,
                                width: col.size,
                                height: row.size,
                                text: "",
                                textWidth: 0,
                                border,
                                style: conditionalStyle ? conditionalStyle : null,
                                align: undefined,
                                clipRect: null,
                                error: undefined,
                            });
                        }
                    }
                }
            }
            const activeSheetId = this.getters.getActiveSheetId();
            // process all visible merges
            for (let merge of this.getters.getMerges(activeSheetId)) {
                if (this.getters.isMergeHidden(activeSheetId, merge)) {
                    continue;
                }
                if (overlap(merge, viewport)) {
                    const refCell = this.getters.getCell(activeSheetId, merge.left, merge.top);
                    const borderTopLeft = this.getters.getCellBorder(activeSheetId, merge.left, merge.top);
                    const borderBottomRight = this.getters.getCellBorder(activeSheetId, merge.right, merge.bottom);
                    const width = cols[merge.right].end - cols[merge.left].start;
                    let text, textWidth, style, align, border;
                    style = refCell ? this.getters.getCellStyle(refCell) : null;
                    if (refCell || borderBottomRight || borderTopLeft) {
                        text = refCell ? this.getters.getCellText(refCell, showFormula) : "";
                        textWidth = refCell ? this.getters.getTextWidth(refCell) : null;
                        const conditionalStyle = this.getters.getConditionalStyle(merge.topLeft.col, merge.topLeft.row);
                        if (conditionalStyle) {
                            style = Object.assign({}, style, conditionalStyle);
                        }
                        align = text ? (style && style.align) || computeAlign(refCell, showFormula) : null;
                        border = {
                            bottom: borderBottomRight ? borderBottomRight.bottom : null,
                            left: borderTopLeft ? borderTopLeft.left : null,
                            right: borderBottomRight ? borderBottomRight.right : null,
                            top: borderTopLeft ? borderTopLeft.top : null,
                        };
                    }
                    style = style || {};
                    // Small trick: the code that draw the background color skips the color
                    // #ffffff.  But for merges, we actually need to draw the background,
                    // otherwise the grid is visible. So, we change the #ffffff color to the
                    // color #fff, which is actually the same.
                    if (!style.fillColor || style.fillColor === "#ffffff") {
                        style = Object.create(style);
                        style.fillColor = "#fff";
                    }
                    const x = cols[merge.left].start - offsetX;
                    const y = rows[merge.top].start - offsetY;
                    const height = rows[merge.bottom].end - rows[merge.top].start;
                    const iconStyle = this.getters.getConditionalIcon(merge.left, merge.top);
                    const fontsize = style.fontSize || DEFAULT_FONT_SIZE;
                    const iconWidth = fontSizeMap[fontsize];
                    const iconBoxWidth = iconStyle ? 2 * MIN_CF_ICON_MARGIN + iconWidth : 0;
                    /** alignment of a number cell should be put to left once the text overflows from the cell */
                    const contentWidth = iconBoxWidth + textWidth;
                    align =
                        text &&
                            (refCell === null || refCell === void 0 ? void 0 : refCell.evaluated.type) === CellValueType.number &&
                            contentWidth > width &&
                            align !== "center"
                            ? "left"
                            : align;
                    const clipRect = iconStyle
                        ? [x + iconBoxWidth, y, Math.max(0, width - iconBoxWidth), height]
                        : [x, y, width, height];
                    const clipIcon = iconStyle
                        ? [x, y, Math.min(iconBoxWidth, width), height]
                        : null;
                    result.push({
                        x: x,
                        y: y,
                        width,
                        height,
                        text,
                        textWidth,
                        border,
                        style,
                        align,
                        clipRect,
                        error: refCell && refCell.evaluated.type === CellValueType.error
                            ? refCell.evaluated.error
                            : undefined,
                        image: iconStyle
                            ? {
                                type: "icon",
                                clipIcon,
                                size: iconWidth,
                                image: ICONS[iconStyle].img,
                            }
                            : undefined,
                    });
                }
            }
            return result;
        }
    }
    RendererPlugin.layers = [0 /* Background */, 7 /* Headers */];
    RendererPlugin.getters = [
        "getColIndex",
        "getRowIndex",
        "getRect",
        "isVisibleInViewport",
        "getEdgeScrollCol",
        "getEdgeScrollRow",
    ];
    RendererPlugin.modes = ["normal"];

    const uuidGenerator = new UuidGenerator();
    /**
     * Selection input Plugin
     *
     * The SelectionInput component input and output are both arrays of strings, but
     * it requires an intermediary internal state to work.
     * This plugin handles this internal state.
     */
    class SelectionInputPlugin extends UIPlugin {
        constructor() {
            super(...arguments);
            this.inputs = {};
            this.activeSheets = {};
            this.inputHasSingleRange = {};
            this.focusedInputId = null;
            this.focusedRange = null;
            this.willAddNewRange = false;
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        allowDispatch(cmd) {
            switch (cmd.type) {
                case "FOCUS_RANGE":
                    const index = this.getIndex(cmd.id, cmd.rangeId);
                    if (this.focusedInputId === cmd.id && this.focusedRange === index) {
                        return 22 /* InputAlreadyFocused */;
                    }
                    break;
                case "ADD_EMPTY_RANGE":
                    if (this.inputHasSingleRange[cmd.id] && this.inputs[cmd.id].length === 1) {
                        return 23 /* MaximumRangesReached */;
                    }
                    break;
            }
            return 0 /* Success */;
        }
        handle(cmd) {
            switch (cmd.type) {
                case "ENABLE_NEW_SELECTION_INPUT":
                    this.initInput(cmd.id, cmd.initialRanges || [], cmd.hasSingleRange);
                    break;
                case "DISABLE_SELECTION_INPUT":
                    if (this.focusedInputId === cmd.id) {
                        this.unfocus();
                    }
                    delete this.inputs[cmd.id];
                    delete this.activeSheets[cmd.id];
                    delete this.inputHasSingleRange[cmd.id];
                    break;
                case "UNFOCUS_SELECTION_INPUT":
                    this.unfocus();
                    break;
                case "FOCUS_RANGE":
                    this.focus(cmd.id, this.getIndex(cmd.id, cmd.rangeId));
                    break;
                case "CHANGE_RANGE": {
                    const index = this.getIndex(cmd.id, cmd.rangeId);
                    if (index !== null) {
                        const id = cmd.id;
                        if (this.focusedInputId !== id || this.focusedRange !== index) {
                            this.dispatch("FOCUS_RANGE", { id, rangeId: this.inputs[id][index].id });
                        }
                        const values = cmd.value.split(",").map((reference) => reference.trim());
                        this.setRange(id, index, values);
                    }
                    break;
                }
                case "ADD_EMPTY_RANGE":
                    this.insertNewRange(cmd.id, this.inputs[cmd.id].length, [""]);
                    this.focusLast(cmd.id);
                    break;
                case "REMOVE_RANGE":
                    const index = this.getIndex(cmd.id, cmd.rangeId);
                    if (index !== null) {
                        this.removeRange(cmd.id, index);
                    }
                    break;
                case "SELECT_CELL":
                case "SET_SELECTION":
                    if (!this.focusedInputId) {
                        break;
                    }
                    const all = this.getSelectionInputValue(this.focusedInputId);
                    const selectedZones = this.inputHasSingleRange[this.focusedInputId]
                        ? [this.getters.getSelectedZone()]
                        : this.getters.getSelectedZones();
                    const selectedXCs = selectedZones.map(zoneToXc).filter((zoneXc) => !all.includes(zoneXc));
                    const inputSheetId = this.activeSheets[this.focusedInputId];
                    const sheetId = this.getters.getActiveSheetId();
                    const sheetName = this.getters.getSheetName(sheetId);
                    this.add(selectedXCs.map((xc) => sheetId === inputSheetId ? xc : `${getComposerSheetName(sheetName)}!${xc}`));
                    break;
                case "PREPARE_SELECTION_EXPANSION": {
                    const [id, index] = [this.focusedInputId, this.focusedRange];
                    if (id !== null && index !== null && !this.inputHasSingleRange[id]) {
                        this.willAddNewRange = this.inputs[id][index].xc.trim() !== "";
                    }
                    break;
                }
            }
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        /**
         * Return a list of all valid XCs.
         * e.g. ["A1", "Sheet2!B3", "E12"]
         */
        getSelectionInput(id) {
            if (!this.inputs[id]) {
                return [];
            }
            return this.inputs[id].map((input, index) => Object.assign({}, input, {
                color: this.focusedInputId === id && this.focusedRange !== null && this.isRangeValid(input.xc)
                    ? input.color
                    : null,
                isFocused: this.focusedInputId === id && this.focusedRange === index,
            }));
        }
        isRangeValid(xc) {
            if (!xc) {
                return false;
            }
            const [rangeXc, sheetName] = xc.split("!").reverse();
            return (rangeXc.match(rangeReference) !== null &&
                (sheetName === undefined || this.getters.getSheetIdByName(sheetName) !== undefined));
        }
        getSelectionInputValue(id) {
            return this.cleanInputs(this.inputs[id].map((range) => {
                return range.xc ? range.xc : "";
            }));
        }
        getSelectionInputHighlights() {
            if (!this.focusedInputId) {
                return [];
            }
            return this.inputs[this.focusedInputId]
                .map((input) => this.inputToHighlights(this.focusedInputId, input))
                .flat();
        }
        // ---------------------------------------------------------------------------
        // Other
        // ---------------------------------------------------------------------------
        initInput(id, initialRanges, inputHasSingleRange = false) {
            this.inputs[id] = [];
            this.insertNewRange(id, 0, initialRanges);
            this.activeSheets[id] = this.getters.getActiveSheetId();
            this.inputHasSingleRange[id] = inputHasSingleRange;
            if (this.inputs[id].length === 0) {
                this.dispatch("ADD_EMPTY_RANGE", { id });
            }
        }
        /**
         * Focus a given range or remove the focus.
         */
        focus(id, index) {
            this.focusedInputId = id;
            this.focusedRange = index;
        }
        focusLast(id) {
            this.focus(id, this.inputs[id].length - 1);
        }
        unfocus() {
            this.focusedInputId = null;
            this.focusedRange = null;
        }
        add(newRanges) {
            if (this.focusedInputId === null ||
                this.focusedRange === null ||
                this.getters.isSelectingForComposer() ||
                newRanges.length === 0) {
                return;
            }
            const mode = this.getters.getSelectionMode();
            if (mode === SelectionMode.expanding && this.willAddNewRange) {
                const id = this.focusedInputId;
                this.insertNewRange(id, this.inputs[id].length, newRanges);
                this.focusLast(this.focusedInputId);
                this.willAddNewRange = false;
            }
            else {
                this.setRange(this.focusedInputId, this.focusedRange, newRanges);
            }
        }
        setContent(id, index, xc) {
            this.inputs[id][index] = {
                ...this.inputs[id][index],
                id: uuidGenerator.uuidv4(),
                xc,
            };
        }
        /**
         * Insert new inputs after the given index.
         */
        insertNewRange(id, index, values) {
            this.inputs[id].splice(index, 0, ...values.map((xc, i) => ({
                xc,
                id: (this.inputs[id].length + i + 1).toString(),
                color: getNextColor(),
            })));
        }
        /**
         * Set a new value in a given range input. If more than one value is provided,
         * new inputs will be added.
         */
        setRange(id, index, values) {
            const [, ...additionalValues] = values;
            this.setContent(id, index, values[0]);
            this.insertNewRange(id, index + 1, additionalValues);
            // focus the last newly added range
            if (additionalValues.length) {
                this.focus(id, index + additionalValues.length);
            }
        }
        removeRange(id, index) {
            this.inputs[id].splice(index, 1);
            if (this.focusedInputId === id && this.focusedRange !== null) {
                this.focusLast(id);
            }
        }
        /**
         * Convert highlights input format to the command format.
         * The first xc in the input range will keep its color.
         * Invalid ranges and ranges from other sheets than the active sheets
         * are ignored.
         */
        inputToHighlights(id, { xc, color }) {
            const ranges = this.cleanInputs([xc])
                .filter((range) => this.isRangeValid(range))
                .filter((reference) => this.shouldBeHighlighted(this.activeSheets[id], reference));
            if (ranges.length === 0)
                return [];
            const [fromInput, ...otherRanges] = ranges;
            const highlights = [[fromInput, color || getNextColor()]];
            for (const range of otherRanges) {
                highlights.push([range, getNextColor()]);
            }
            return highlights;
        }
        cleanInputs(ranges) {
            return ranges
                .map((xc) => xc.split(","))
                .flat()
                .map((xc) => xc.trim())
                .filter((xc) => xc !== "");
        }
        /**
         * Check if a cell or range reference should be highlighted.
         * It should be highlighted if it references the current active sheet.
         * Note that if no sheet name is given in the reference ("A1"), it refers to the
         * active sheet when the selection input was enabled which might be different from
         * the current active sheet.
         */
        shouldBeHighlighted(inputSheetId, reference) {
            const sheetName = reference.split("!").reverse()[1];
            const sheetId = this.getters.getSheetIdByName(sheetName);
            const activeSheetId = this.getters.getActiveSheet().id;
            const valid = this.isRangeValid(reference);
            return (valid &&
                (sheetId === activeSheetId || (sheetId === undefined && activeSheetId === inputSheetId)));
        }
        /**
         * Return the index of a range given its id
         * or `null` if the range is not found.
         */
        getIndex(id, rangeId) {
            const index = this.inputs[id].findIndex((range) => range.id === rangeId);
            return index >= 0 ? index : null;
        }
    }
    SelectionInputPlugin.modes = ["normal"];
    SelectionInputPlugin.layers = [1 /* Highlights */];
    SelectionInputPlugin.getters = [
        "getSelectionInput",
        "getSelectionInputValue",
        "isRangeValid",
        "getSelectionInputHighlights",
    ];

    /**
     * This is a generic event bus based on the Owl event bus.
     * This bus however ensures type safety across events and subscription callbacks.
     */
    class EventBus {
        constructor() {
            this.bus = new owl__namespace.core.EventBus();
        }
        on(type, owner, callback) {
            this.bus.on(type, owner, callback);
        }
        trigger(type, payload) {
            this.bus.trigger(type, payload);
        }
        off(eventType, owner) {
            this.bus.off(eventType, owner);
        }
        clear() {
            this.bus.clear();
        }
    }

    class Revision {
        /**
         * A revision represents a whole client action (Create a sheet, merge a Zone, Undo, ...).
         * A revision contains the following information:
         *  - id: ID of the revision
         *  - commands: CoreCommands that are linked to the action, and should be
         *              dispatched in other clients
         *  - clientId: Client who initiated the action
         *  - changes: List of changes applied on the state.
         */
        constructor(id, clientId, commands, changes) {
            this._commands = [];
            this._changes = [];
            this.id = id;
            this.clientId = clientId;
            this._commands = [...commands];
            this._changes = changes ? [...changes] : [];
        }
        setChanges(changes) {
            this._changes = changes;
        }
        get commands() {
            return this._commands;
        }
        get changes() {
            return this._changes;
        }
    }

    class ClientDisconnectedError extends Error {
    }
    class Session extends EventBus {
        /**
         * Manages the collaboration between multiple users on the same spreadsheet.
         * It can forward local state changes to other users to ensure they all eventually
         * reach the same state.
         * It also manages the positions of each clients in the spreadsheet to provide
         * a visual indication of what other users are doing in the spreadsheet.
         *
         * @param revisions
         * @param transportService communication channel used to send and receive messages
         * between all connected clients
         * @param client the client connected locally
         * @param serverRevisionId
         */
        constructor(revisions, transportService, serverRevisionId = DEFAULT_REVISION_ID) {
            super();
            this.revisions = revisions;
            this.transportService = transportService;
            this.serverRevisionId = serverRevisionId;
            /**
             * Positions of the others client.
             */
            this.clients = {};
            this.clientId = "local";
            this.pendingMessages = [];
            this.waitingAck = false;
            this.processedRevisions = new Set();
            this.uuidGenerator = new UuidGenerator();
            this.debouncedMove = owl__namespace.utils.debounce(this._move.bind(this), DEBOUNCE_TIME);
        }
        /**
         * Add a new revision to the collaborative session.
         * It will be transmitted to all other connected clients.
         */
        save(commands, changes) {
            if (!commands.length || !changes.length)
                return;
            const revision = new Revision(this.uuidGenerator.uuidv4(), this.clientId, commands, changes);
            this.revisions.append(revision.id, revision);
            this.trigger("new-local-state-update", { id: revision.id });
            this.sendUpdateMessage({
                type: "REMOTE_REVISION",
                version: MESSAGE_VERSION,
                serverRevisionId: this.serverRevisionId,
                nextRevisionId: revision.id,
                clientId: revision.clientId,
                commands: revision.commands,
            });
        }
        undo(revisionId) {
            this.sendUpdateMessage({
                type: "REVISION_UNDONE",
                version: MESSAGE_VERSION,
                serverRevisionId: this.serverRevisionId,
                nextRevisionId: this.uuidGenerator.uuidv4(),
                undoneRevisionId: revisionId,
            });
        }
        redo(revisionId) {
            this.sendUpdateMessage({
                type: "REVISION_REDONE",
                version: MESSAGE_VERSION,
                serverRevisionId: this.serverRevisionId,
                nextRevisionId: this.uuidGenerator.uuidv4(),
                redoneRevisionId: revisionId,
            });
        }
        /**
         * Notify that the position of the client has changed
         */
        move(position) {
            this.debouncedMove(position);
        }
        join(client) {
            if (client) {
                this.clients[client.id] = client;
                this.clientId = client.id;
            }
            else {
                this.clients["local"] = { id: "local", name: "local" };
                this.clientId = "local";
            }
            this.transportService.onNewMessage(this.clientId, this.onMessageReceived.bind(this));
        }
        loadInitialMessages(messages) {
            this.on("unexpected-revision-id", this, ({ revisionId }) => {
                throw new Error(`The spreadsheet could not be loaded. Revision ${revisionId} is corrupted.`);
            });
            for (const message of messages) {
                this.onMessageReceived(message);
            }
            this.off("unexpected-revision-id", this);
        }
        /**
         * Notify the server that the user client left the collaborative session
         */
        leave() {
            delete this.clients[this.clientId];
            this.transportService.leave(this.clientId);
            this.transportService.sendMessage({
                type: "CLIENT_LEFT",
                clientId: this.clientId,
                version: MESSAGE_VERSION,
            });
        }
        /**
         * Send a snapshot of the spreadsheet to the collaboration server
         */
        snapshot(data) {
            const snapshotId = this.uuidGenerator.uuidv4();
            this.transportService.sendMessage({
                type: "SNAPSHOT",
                nextRevisionId: snapshotId,
                serverRevisionId: this.serverRevisionId,
                data: { ...data, revisionId: snapshotId },
                version: MESSAGE_VERSION,
            });
        }
        getClient() {
            const client = this.clients[this.clientId];
            if (!client) {
                throw new ClientDisconnectedError("The client left the session");
            }
            return client;
        }
        getConnectedClients() {
            return new Set(Object.values(this.clients).filter(isDefined));
        }
        getRevisionId() {
            return this.serverRevisionId;
        }
        isFullySynchronized() {
            return this.pendingMessages.length === 0;
        }
        _move(position) {
            var _a;
            // this method is debounced and might be called after the client
            // left the session.
            if (!this.clients[this.clientId])
                return;
            const currentPosition = (_a = this.clients[this.clientId]) === null || _a === void 0 ? void 0 : _a.position;
            if ((currentPosition === null || currentPosition === void 0 ? void 0 : currentPosition.col) === position.col &&
                currentPosition.row === position.row &&
                currentPosition.sheetId === position.sheetId) {
                return;
            }
            const type = currentPosition ? "CLIENT_MOVED" : "CLIENT_JOINED";
            const client = this.getClient();
            this.clients[this.clientId] = { ...client, position };
            this.transportService.sendMessage({
                type,
                version: MESSAGE_VERSION,
                client: { ...client, position },
            });
        }
        /**
         * Handles messages received from other clients in the collaborative
         * session.
         */
        onMessageReceived(message) {
            if (this.isAlreadyProcessed(message))
                return;
            switch (message.type) {
                case "CLIENT_MOVED":
                    this.onClientMoved(message);
                    break;
                case "CLIENT_JOINED":
                    this.onClientJoined(message);
                    break;
                case "CLIENT_LEFT":
                    this.onClientLeft(message);
                    break;
                case "REVISION_REDONE": {
                    this.waitingAck = false;
                    this.revisions.redo(message.redoneRevisionId, message.nextRevisionId, message.serverRevisionId);
                    this.trigger("revision-redone", {
                        revisionId: message.redoneRevisionId,
                        commands: this.revisions.get(message.redoneRevisionId).commands,
                    });
                    break;
                }
                case "REVISION_UNDONE":
                    this.waitingAck = false;
                    this.revisions.undo(message.undoneRevisionId, message.nextRevisionId, message.serverRevisionId);
                    this.trigger("revision-undone", {
                        revisionId: message.undoneRevisionId,
                        commands: this.revisions.get(message.undoneRevisionId).commands,
                    });
                    break;
                case "REMOTE_REVISION":
                    this.waitingAck = false;
                    if (message.serverRevisionId !== this.serverRevisionId) {
                        this.trigger("unexpected-revision-id", { revisionId: message.serverRevisionId });
                        return;
                    }
                    const { clientId, commands } = message;
                    const revision = new Revision(message.nextRevisionId, clientId, commands);
                    if (revision.clientId !== this.clientId) {
                        this.revisions.insert(revision.id, revision, message.serverRevisionId);
                        this.trigger("remote-revision-received", { commands });
                    }
                    break;
                case "SNAPSHOT_CREATED": {
                    this.waitingAck = false;
                    const revision = new Revision(message.nextRevisionId, "server", []);
                    this.revisions.insert(revision.id, revision, message.serverRevisionId);
                    this.dropPendingHistoryMessages();
                    this.trigger("snapshot");
                    break;
                }
            }
            this.acknowledge(message);
            this.trigger("collaborative-event-received");
        }
        onClientMoved(message) {
            if (message.client.id !== this.clientId) {
                this.clients[message.client.id] = message.client;
            }
        }
        /**
         * Register the new client and send your
         * own position back.
         */
        onClientJoined(message) {
            if (message.client.id !== this.clientId) {
                this.clients[message.client.id] = message.client;
                const client = this.clients[this.clientId];
                if (client) {
                    const { position } = client;
                    if (position) {
                        this.transportService.sendMessage({
                            type: "CLIENT_MOVED",
                            version: MESSAGE_VERSION,
                            client: { ...client, position },
                        });
                    }
                }
            }
        }
        onClientLeft(message) {
            if (message.clientId !== this.clientId) {
                delete this.clients[message.clientId];
            }
        }
        sendUpdateMessage(message) {
            this.pendingMessages.push(message);
            if (this.waitingAck) {
                return;
            }
            this.waitingAck = true;
            this.sendPendingMessage();
        }
        /**
         * Send the next pending message
         */
        sendPendingMessage() {
            let message = this.pendingMessages[0];
            if (!message)
                return;
            if (message.type === "REMOTE_REVISION") {
                const revision = this.revisions.get(message.nextRevisionId);
                if (revision.commands.length === 0) {
                    /**
                     * The command is empty, we have to drop all the next local revisions
                     * to avoid issues with undo/redo
                     */
                    this.revisions.drop(revision.id);
                    const revisionIds = this.pendingMessages
                        .filter((message) => message.type === "REMOTE_REVISION")
                        .map((message) => message.nextRevisionId);
                    this.trigger("pending-revisions-dropped", { revisionIds });
                    this.pendingMessages = [];
                    return;
                }
                message = {
                    ...message,
                    clientId: revision.clientId,
                    commands: revision.commands,
                };
            }
            this.transportService.sendMessage({
                ...message,
                serverRevisionId: this.serverRevisionId,
            });
        }
        acknowledge(message) {
            switch (message.type) {
                case "REMOTE_REVISION":
                case "REVISION_REDONE":
                case "REVISION_UNDONE":
                case "SNAPSHOT_CREATED":
                    this.pendingMessages = this.pendingMessages.filter((msg) => msg.nextRevisionId !== message.nextRevisionId);
                    this.serverRevisionId = message.nextRevisionId;
                    this.processedRevisions.add(message.nextRevisionId);
                    this.sendPendingMessage();
                    break;
            }
        }
        isAlreadyProcessed(message) {
            switch (message.type) {
                case "REMOTE_REVISION":
                case "REVISION_REDONE":
                case "REVISION_UNDONE":
                    return this.processedRevisions.has(message.nextRevisionId);
                default:
                    return false;
            }
        }
        dropPendingHistoryMessages() {
            this.pendingMessages = this.pendingMessages.filter(({ type }) => type !== "REVISION_REDONE" && type !== "REVISION_UNDONE");
        }
    }

    function randomChoice(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
    }
    const colors = [
        "#ff851b",
        "#0074d9",
        "#7fdbff",
        "#b10dc9",
        "#39cccc",
        "#f012be",
        "#3d9970",
        "#111111",
        "#ff4136",
        "#aaaaaa",
        "#85144b",
        "#001f3f",
    ];
    class SelectionMultiUserPlugin extends UIPlugin {
        constructor() {
            super(...arguments);
            this.availableColors = new Set(colors);
            this.colors = {};
        }
        isPositionValid(position) {
            const sheet = this.getters.getSheet(position.sheetId);
            return position.row < sheet.rows.length && position.col < sheet.cols.length;
        }
        chooseNewColor() {
            if (this.availableColors.size === 0) {
                this.availableColors = new Set(colors);
            }
            const color = randomChoice([...this.availableColors.values()]);
            this.availableColors.delete(color);
            return color;
        }
        /**
         * Get the list of others connected clients which are present in the same sheet
         * and with a valid position
         */
        getClientsToDisplay() {
            try {
                this.getters.getClient();
            }
            catch (e) {
                if (e instanceof ClientDisconnectedError) {
                    return [];
                }
                else {
                    throw e;
                }
            }
            const sheetId = this.getters.getActiveSheetId();
            const clients = [];
            for (const client of this.getters.getConnectedClients()) {
                if (client.id !== this.getters.getClient().id &&
                    client.position &&
                    client.position.sheetId === sheetId &&
                    this.isPositionValid(client.position)) {
                    const position = client.position;
                    if (!this.colors[client.id]) {
                        this.colors[client.id] = this.chooseNewColor();
                    }
                    const color = this.colors[client.id];
                    clients.push({ ...client, position, color });
                }
            }
            return clients;
        }
        drawGrid(renderingContext) {
            const { viewport, ctx, thinLineWidth } = renderingContext;
            const activeSheetId = this.getters.getActiveSheetId();
            for (const client of this.getClientsToDisplay()) {
                const { row, col } = client.position;
                const zone = this.getters.expandZone(activeSheetId, {
                    top: row,
                    bottom: row,
                    left: col,
                    right: col,
                });
                const [x, y, width, height] = this.getters.getRect(zone, viewport);
                if (width <= 0 || height <= 0) {
                    continue;
                }
                const color = client.color;
                /* Cell background */
                const cellBackgroundColor = `${color}10`;
                ctx.fillStyle = cellBackgroundColor;
                ctx.lineWidth = 4 * thinLineWidth;
                ctx.strokeStyle = color;
                ctx.globalCompositeOperation = "multiply";
                ctx.fillRect(x, y, width, height);
                /* Cell border */
                ctx.globalCompositeOperation = "source-over";
                ctx.strokeRect(x, y, width, height);
                /* client name background */
                ctx.font = `bold ${DEFAULT_FONT_SIZE + 1}px ${DEFAULT_FONT}`;
            }
        }
    }
    SelectionMultiUserPlugin.getters = ["getClientsToDisplay"];
    SelectionMultiUserPlugin.layers = [5 /* Selection */];
    SelectionMultiUserPlugin.modes = ["normal"];

    class SortPlugin extends UIPlugin {
        allowDispatch(cmd) {
            switch (cmd.type) {
                case "SORT_CELLS":
                    if (!isInside(cmd.anchor[0], cmd.anchor[1], cmd.zone)) {
                        throw new Error(_lt("The anchor must be part of the provided zone"));
                    }
                    return this.checkValidations(cmd, this.checkMerge, this.checkMergeSizes);
            }
            return 0 /* Success */;
        }
        handle(cmd) {
            switch (cmd.type) {
                case "SORT_CELLS":
                    if (cmd.interactive) {
                        this.interactiveSortSelection(cmd.sheetId, cmd.anchor, cmd.zone, cmd.sortDirection);
                    }
                    else {
                        this.sortZone(cmd.sheetId, cmd.anchor, cmd.zone, cmd.sortDirection);
                    }
                    break;
            }
        }
        checkMerge({ sheetId, zone }) {
            if (!this.getters.doesIntersectMerge(sheetId, zone)) {
                return 0 /* Success */;
            }
            /*Test the presence of single cells*/
            for (let row = zone.top; row <= zone.bottom; row++) {
                for (let col = zone.left; col <= zone.right; col++) {
                    if (!this.getters.isInMerge(sheetId, col, row)) {
                        return 46 /* InvalidSortZone */;
                    }
                }
            }
            return 0 /* Success */;
        }
        checkMergeSizes({ sheetId, zone }) {
            if (!this.getters.doesIntersectMerge(sheetId, zone)) {
                return 0 /* Success */;
            }
            const merges = this.getters.getMerges(sheetId).filter((merge) => overlap(merge, zone));
            /*Test the presence of merges of different sizes*/
            const mergeDimension = zoneToDimension(merges[0]);
            let [widthFirst, heightFirst] = [mergeDimension.width, mergeDimension.height];
            if (!merges.every((merge) => {
                let [widthCurrent, heightCurrent] = [
                    merge.right - merge.left + 1,
                    merge.bottom - merge.top + 1,
                ];
                return widthCurrent === widthFirst && heightCurrent === heightFirst;
            })) {
                return 46 /* InvalidSortZone */;
            }
            return 0 /* Success */;
        }
        interactiveSortSelection(sheetId, anchor, zone, sortDirection) {
            let result = DispatchResult.Success;
            //several columns => bypass the contiguity check
            let multiColumns = zone.right > zone.left;
            if (this.getters.doesIntersectMerge(sheetId, zone)) {
                multiColumns = false;
                let table;
                for (let r = zone.top; r <= zone.bottom; r++) {
                    table = [];
                    for (let c = zone.left; c <= zone.right; c++) {
                        let merge = this.getters.getMerge(sheetId, c, r);
                        if (merge && !table.includes(merge.id.toString())) {
                            table.push(merge.id.toString());
                        }
                    }
                    if (table.length >= 2) {
                        multiColumns = true;
                        break;
                    }
                }
            }
            if (multiColumns) {
                result = this.dispatch("SORT_CELLS", { sheetId, anchor, zone, sortDirection });
            }
            else {
                // check contiguity
                const contiguousZone = this.getContiguousZone(sheetId, zone);
                if (isEqual(contiguousZone, zone)) {
                    // merge as it is
                    result = this.dispatch("SORT_CELLS", {
                        sheetId,
                        anchor,
                        zone,
                        sortDirection,
                    });
                }
                else {
                    this.ui.askConfirmation(_lt("We found data next to your selection. Since this data was not selected, it will not be sorted. Do you want to extend your selection?"), () => {
                        zone = contiguousZone;
                        result = this.dispatch("SORT_CELLS", {
                            sheetId,
                            anchor,
                            zone,
                            sortDirection,
                        });
                    }, () => {
                        result = this.dispatch("SORT_CELLS", {
                            sheetId,
                            anchor,
                            zone,
                            sortDirection,
                        });
                    });
                }
            }
            if (result.isCancelledBecause(46 /* InvalidSortZone */)) {
                this.dispatch("SET_SELECTION", {
                    anchor: anchor,
                    zones: [zone],
                    anchorZone: zone,
                });
                this.ui.notifyUser(_lt("Cannot sort. To sort, select only cells or only merges that have the same size."));
            }
        }
        // getContiguousZone helpers
        /**
         * safe-version of expandZone to make sure we don't get out of the grid
         */
        expand(sheet, z) {
            const { left, right, top, bottom } = this.getters.expandZone(sheet.id, z);
            return {
                left: Math.max(0, left),
                right: Math.min(sheet.cols.length - 1, right),
                top: Math.max(0, top),
                bottom: Math.min(sheet.rows.length - 1, bottom),
            };
        }
        /**
         * verifies the presence of at least one non-empty cell in the given zone
         */
        checkExpandedValues(sheet, z) {
            const expandedZone = this.expand(sheet, z);
            const sheetId = sheet.id;
            let line = [];
            let cell;
            if (this.getters.doesIntersectMerge(sheetId, expandedZone)) {
                const { left, right, top, bottom } = expandedZone;
                for (let c = left; c <= right; c++) {
                    for (let r = top; r <= bottom; r++) {
                        const [mainCellCol, mainCellRow] = this.getters.getMainCell(sheetId, c, r);
                        cell = this.getters.getCell(sheetId, mainCellCol, mainCellRow);
                        line.push((cell === null || cell === void 0 ? void 0 : cell.formattedValue) || "");
                    }
                }
            }
            else {
                const values = mapCellsInZone(expandedZone, sheet, (cell) => cell.formattedValue, "");
                line = values.flat();
            }
            return line.some((item) => item !== "");
        }
        /**
         * This function will expand the provided zone in directions (top, bottom, left, right) for which there
         * are non-null cells on the external boundary of the zone in the given direction.
         *
         * Example:
         *          A     B     C     D     E
         *         ___   ___   ___   ___   ___
         *    1  |     |  D  |     |     |     |
         *         ___   ___   ___   ___   ___
         *    2  |  5  |     |  1  |  D  |     |
         *         ___   ___   ___   ___   ___
         *    3  |     |     |  A  |  X  |     |
         *         ___   ___   ___   ___   ___
         *    4  |     |     |     |     |     |
         *         ___   ___   ___   ___   ___
         *
         *  Let's consider a provided zone corresponding to (C2:D3) - (left:2, right: 3, top:1, bottom:2)
         *  - the top external boundary is (B1:E1)
         *    Since we have B1='D' != "", we expand to the top: => (C1:D3)
         *    The top boundary having reached the top of the grid, we cannot expand in that direction anymore
         *
         *  - the left boundary is (B1:B4)
         *    since we have B1 again, we expand to the left  => (B1:D3)
         *
         *  - the right and bottom boundaries are a dead end for now as (E1:E4) and (A4:E4) are empty.
         *
         *  - the left boundary is now (A1:A4)
         *    Since we have A2=5 != "", we can therefore expand to the left => (A1:D3)
         *
         *  This will be the final zone as left and top have reached the boundaries of the grid and
         *  the other boundaries (E1:E4) and (A4:E4) are empty.
         *
         * @param sheetId UID of concerned sheet
         * @param zone Zone
         *
         */
        getContiguousZone(sheetId, zone) {
            let { top, bottom, left, right } = zone;
            let canExpand;
            const sheet = this.getters.getSheet(sheetId);
            let stop = false;
            while (!stop) {
                stop = true;
                /** top row external boundary */
                if (top > 0) {
                    canExpand = this.checkExpandedValues(sheet, {
                        left: left - 1,
                        right: right + 1,
                        top: top - 1,
                        bottom: top - 1,
                    });
                    if (canExpand) {
                        stop = false;
                        top--;
                    }
                }
                /** left column external boundary */
                if (left > 0) {
                    canExpand = this.checkExpandedValues(sheet, {
                        left: left - 1,
                        right: left - 1,
                        top: top - 1,
                        bottom: bottom + 1,
                    });
                    if (canExpand) {
                        stop = false;
                        left--;
                    }
                }
                /** right column external boundary */
                if (right < sheet.cols.length - 1) {
                    canExpand = this.checkExpandedValues(sheet, {
                        left: right + 1,
                        right: right + 1,
                        top: top - 1,
                        bottom: bottom + 1,
                    });
                    if (canExpand) {
                        stop = false;
                        right++;
                    }
                }
                /** bottom row external boundary */
                if (bottom < sheet.rows.length - 1) {
                    canExpand = this.checkExpandedValues(sheet, {
                        left: left - 1,
                        right: right + 1,
                        top: bottom + 1,
                        bottom: bottom + 1,
                    });
                    if (canExpand) {
                        stop = false;
                        bottom++;
                    }
                }
            }
            return { left, right, top, bottom };
        }
        /**
         * This function evaluates if the top row of a provided zone can be considered as a `header`
         * by checking the following criteria:
         * * If the left-most column top row value (topLeft) is empty, we ignore it while evaluating the criteria.
         * 1 - Apart from the left-most column, every element of the top row must be non-empty, i.e. a cell should be present in the sheet.
         * 2 - There should be at least one column in which the type (HeaderType) of the rop row cell differs from the type of the cell below.
         *  For the second criteria, we ignore columns on which the cell below is empty.
         *
         */
        hasHeader(sheet, zone, deltaX, deltaY) {
            const { left, right, top, bottom } = zone;
            if (bottom - top + 1 === 1)
                return false;
            let cells = mapCellsInZone({ left, right, top: top, bottom: top + 2 * deltaY - 1 }, sheet, (cell) => cell.evaluated.type, CellValueType.empty, deltaX, deltaY);
            // ignore left-most column when topLeft cell is empty
            const topLeft = cells[0][0];
            if (topLeft === CellValueType.empty) {
                cells = cells.slice(1);
            }
            if (cells.some((item) => item[0] === CellValueType.empty)) {
                return false;
            }
            else if (cells.some((item) => item[1] !== CellValueType.empty && item[0] !== item[1])) {
                return true;
            }
            else {
                return false;
            }
        }
        sortCellsList(list, sortDirection) {
            const cellsIndex = list.map((val, index) => ({ index, val }));
            const sortingCellsIndexes = cellsIndex.filter((x) => !(x.val == undefined || x.val.evaluated.value === ""));
            const emptyCellsIndexes = cellsIndex.filter((x) => x.val == undefined || x.val.evaluated.value === "");
            const inverse = sortDirection === "descending" ? -1 : 1;
            const sortTypes = [
                CellValueType.number,
                CellValueType.error,
                CellValueType.text,
                CellValueType.boolean,
            ];
            const convertCell = (cell) => {
                let type = cell.evaluated.type;
                return { type: type, value: cell.evaluated.value };
            };
            const sortingTypeValueMapIndexes = sortingCellsIndexes.map((item) => {
                return {
                    index: item.index,
                    val: convertCell(item.val),
                };
            });
            const sortedIndex = sortingTypeValueMapIndexes.sort((left, right) => {
                let typeOrder = sortTypes.indexOf(left.val.type) - sortTypes.indexOf(right.val.type);
                if (typeOrder === 0) {
                    if (left.val.type === CellValueType.text || left.val.type === CellValueType.error) {
                        typeOrder = left.val.value.localeCompare(right.val.value);
                    }
                    else
                        typeOrder = left.val.value - right.val.value;
                }
                return inverse * typeOrder;
            });
            return sortedIndex.concat(emptyCellsIndexes);
        }
        sortZone(sheetId, anchor, zone, sortDirection) {
            let stepX = 1, stepY = 1, sortingCol = anchor[0]; // fetch anchor
            let sortZone = Object.assign({}, zone);
            // Update in case of merges in the zone
            if (this.getters.doesIntersectMerge(sheetId, sortZone)) {
                const [col, row] = anchor;
                const merge = this.getters.getMerge(sheetId, col, row);
                stepX = merge.right - merge.left + 1;
                stepY = merge.bottom - merge.top + 1;
                sortingCol = merge.topLeft.col;
            }
            const sheet = this.getters.getSheet(sheetId);
            const hasHeader = this.hasHeader(sheet, sortZone, stepX, stepY);
            if (hasHeader) {
                sortZone.top += stepY;
            }
            const cells = mapCellsInZone(sortZone, sheet, (cell) => cell, undefined, stepX, stepY);
            const sortingCells = cells[sortingCol - sortZone.left];
            const sortedIndexOfSortTypeCells = this.sortCellsList(sortingCells, sortDirection);
            const sortedIndex = sortedIndexOfSortTypeCells.map((x) => x.index);
            const [width, height] = [cells.length, cells[0].length];
            for (let c = 0; c < width; c++) {
                for (let r = 0; r < height; r++) {
                    let cell = cells[c][sortedIndex[r]];
                    let newCol = sortZone.left + c * stepX;
                    let newRow = sortZone.top + r * stepY;
                    let newCellValues = {
                        sheetId: sheetId,
                        col: newCol,
                        row: newRow,
                        content: "",
                        value: "",
                    };
                    if (cell) {
                        let content = cell.content;
                        if (cell.isFormula()) {
                            const position = this.getters.getCellPosition(cell.id);
                            const offsetY = newRow - position.row;
                            // we only have a vertical offset
                            const ranges = this.getters.createAdaptedRanges(cell.dependencies.references, 0, offsetY, sheetId);
                            content = this.getters.buildFormulaContent(sheetId, cell.normalizedText, {
                                ...cell.dependencies,
                                references: ranges,
                            });
                        }
                        newCellValues.style = cell.style;
                        newCellValues.content = content;
                        newCellValues.format = cell.format;
                        newCellValues.value = cell.evaluated.value;
                    }
                    this.dispatch("UPDATE_CELL", newCellValues);
                }
            }
        }
    }
    SortPlugin.getters = ["getContiguousZone"];

    class UIOptionsPlugin extends UIPlugin {
        constructor() {
            super(...arguments);
            this.showFormulas = false;
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        handle(cmd) {
            switch (cmd.type) {
                case "SET_FORMULA_VISIBILITY":
                    this.showFormulas = cmd.show;
                    break;
            }
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        shouldShowFormulas() {
            return this.showFormulas;
        }
    }
    UIOptionsPlugin.modes = ["normal"];
    UIOptionsPlugin.getters = ["shouldShowFormulas"];

    class SheetUIPlugin extends UIPlugin {
        constructor() {
            super(...arguments);
            this.ctx = document.createElement("canvas").getContext("2d");
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        allowDispatch(cmd) {
            switch (cmd.type) {
                case "AUTORESIZE_ROWS":
                case "AUTORESIZE_COLUMNS":
                case "DELETE_SHEET_CONFIRMATION":
                    try {
                        this.getters.getSheet(cmd.sheetId);
                        break;
                    }
                    catch (error) {
                        return 21 /* InvalidSheetId */;
                    }
            }
            return 0 /* Success */;
        }
        handle(cmd) {
            switch (cmd.type) {
                case "RENAME_SHEET":
                    if (cmd.interactive) {
                        this.interactiveRenameSheet(cmd.sheetId, _lt("Rename Sheet"));
                    }
                    break;
                case "DELETE_SHEET_CONFIRMATION":
                    this.interactiveDeleteSheet(cmd.sheetId);
                    break;
                case "ADD_MERGE":
                    if (cmd.interactive) {
                        this.interactiveMerge(cmd.sheetId, cmd.target);
                    }
                    break;
                case "AUTORESIZE_COLUMNS":
                    for (let col of cmd.cols) {
                        const size = this.getColMaxWidth(cmd.sheetId, col);
                        if (size !== 0) {
                            this.dispatch("RESIZE_COLUMNS_ROWS", {
                                elements: [col],
                                dimension: "COL",
                                size: size + 2 * PADDING_AUTORESIZE,
                                sheetId: cmd.sheetId,
                            });
                        }
                    }
                    break;
                case "AUTORESIZE_ROWS":
                    for (let row of cmd.rows) {
                        const size = this.getRowMaxHeight(cmd.sheetId, row);
                        if (size !== 0) {
                            this.dispatch("RESIZE_COLUMNS_ROWS", {
                                elements: [row],
                                dimension: "ROW",
                                size: size + 2 * PADDING_AUTORESIZE,
                                sheetId: cmd.sheetId,
                            });
                        }
                    }
                    break;
            }
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        getCellWidth(cell) {
            let width = this.getTextWidth(cell);
            const cellPosition = this.getters.getCellPosition(cell.id);
            const icon = this.getters.getConditionalIcon(cellPosition.col, cellPosition.row);
            if (icon) {
                width += computeIconWidth(this.ctx, this.getters.getCellStyle(cell));
            }
            return width;
        }
        getTextWidth(cell) {
            const text = this.getters.getCellText(cell, this.getters.shouldShowFormulas());
            return computeTextWidth(this.ctx, text, this.getters.getCellStyle(cell));
        }
        getCellHeight(cell) {
            const style = this.getters.getCellStyle(cell);
            const sizeInPt = style.fontSize || DEFAULT_FONT_SIZE;
            return fontSizeMap[sizeInPt];
        }
        getCellText(cell, showFormula = false) {
            if (showFormula && (cell.isFormula() || cell.evaluated.type === CellValueType.error)) {
                return cell.content;
            }
            else {
                return cell.formattedValue;
            }
        }
        // ---------------------------------------------------------------------------
        // Grid manipulation
        // ---------------------------------------------------------------------------
        getColMaxWidth(sheetId, index) {
            const cells = this.getters.getColCells(sheetId, index);
            const sizes = cells.map((cell) => this.getCellWidth(cell));
            return Math.max(0, ...sizes);
        }
        getRowMaxHeight(sheetId, index) {
            const sheet = this.getters.getSheet(sheetId);
            const cells = Object.values(sheet.rows[index].cells);
            const sizes = cells.map((cell) => this.getCellHeight(cell));
            return Math.max(0, ...sizes);
        }
        interactiveRenameSheet(sheetId, title) {
            const placeholder = this.getters.getSheetName(sheetId);
            this.ui.editText(title, placeholder, (name) => {
                if (!name) {
                    return;
                }
                const result = this.dispatch("RENAME_SHEET", { sheetId: sheetId, name });
                const sheetName = this.getters.getSheetName(sheetId);
                if (!result.isSuccessful && sheetName !== name) {
                    this.interactiveRenameSheet(sheetId, _lt("Please enter a valid sheet name"));
                }
            });
        }
        interactiveDeleteSheet(sheetId) {
            this.ui.askConfirmation(_lt("Are you sure you want to delete this sheet ?"), () => {
                this.dispatch("DELETE_SHEET", { sheetId: sheetId });
            });
        }
        interactiveMerge(sheet, target) {
            const result = this.dispatch("ADD_MERGE", { sheetId: sheet, target });
            if (!result.isSuccessful) {
                if (result.isCancelledBecause(3 /* MergeIsDestructive */)) {
                    this.ui.askConfirmation(_lt("Merging these cells will only preserve the top-leftmost value. Merge anyway?"), () => {
                        this.dispatch("ADD_MERGE", { sheetId: sheet, target, force: true });
                    });
                }
            }
        }
    }
    SheetUIPlugin.getters = ["getCellWidth", "getCellHeight", "getTextWidth", "getCellText"];

    /**
     * Viewport plugin.
     *
     * This plugin manages all things related to all viewport states.
     *
     * There are two types of viewports :
     *  1. The viewport related to the scrollbar absolute position
     *  2. The snappedViewport which represents the previous one but but 'snapped' to
     *     the col/row structure, so, the offsets are correct for computations necessary
     *     to align elements to the grid.
     */
    class ViewportPlugin extends UIPlugin {
        constructor() {
            super(...arguments);
            this.viewports = {};
            this.snappedViewports = {};
            this.updateSnap = false;
            /**
             * The viewport dimensions (clientWidth and clientHeight) are usually set by one of the components
             * (i.e. when grid component is mounted) to properly reflect its state in the DOM.
             * In the absence of a component (standalone model), is it mandatory to set reasonable default values
             * to ensure the correct operation of this plugin.
             */
            this.clientWidth = 1000;
            this.clientHeight = 1000;
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        allowDispatch(cmd) {
            switch (cmd.type) {
                case "SET_VIEWPORT_OFFSET":
                    return this.checkOffsetValidity(cmd.offsetX, cmd.offsetY);
                case "RESIZE_VIEWPORT":
                    if (cmd.width < 0 || cmd.height < 0) {
                        return 52 /* InvalidViewportSize */;
                    }
                    return 0 /* Success */;
                default:
                    return 0 /* Success */;
            }
        }
        handle(cmd) {
            switch (cmd.type) {
                case "UNDO":
                case "REDO":
                    this.cleanViewports();
                    this.resetViewports();
                    break;
                case "RESIZE_VIEWPORT":
                    this.cleanViewports();
                    this.resizeViewport(cmd.height, cmd.width);
                    break;
                case "SET_VIEWPORT_OFFSET":
                    this.setViewportOffset(cmd.offsetX, cmd.offsetY);
                    break;
                case "REMOVE_COLUMNS_ROWS":
                case "RESIZE_COLUMNS_ROWS":
                case "HIDE_COLUMNS_ROWS":
                    if (cmd.dimension === "COL") {
                        this.adjustViewportOffsetX(cmd.sheetId, this.getViewport(cmd.sheetId));
                    }
                    else {
                        this.adjustViewportOffsetY(cmd.sheetId, this.getViewport(cmd.sheetId));
                    }
                    break;
                case "ADD_COLUMNS_ROWS":
                case "UNHIDE_COLUMNS_ROWS":
                    if (cmd.dimension === "COL") {
                        this.adjustViewportZoneX(cmd.sheetId, this.getViewport(cmd.sheetId));
                    }
                    else {
                        this.adjustViewportZoneY(cmd.sheetId, this.getViewport(cmd.sheetId));
                    }
                    break;
                case "ACTIVATE_SHEET":
                    this.refreshViewport(cmd.sheetIdTo);
                    break;
                case "SELECT_CELL":
                case "MOVE_POSITION":
                    this.refreshViewport(this.getters.getActiveSheetId());
                    break;
            }
        }
        finalize() {
            if (this.updateSnap) {
                this.snapViewportToCell(this.getters.getActiveSheetId());
                this.updateSnap = false;
            }
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        getViewportDimension() {
            return { width: this.clientWidth, height: this.clientHeight };
        }
        getActiveViewport() {
            const sheetId = this.getters.getActiveSheetId();
            return this.getViewport(sheetId);
        }
        getActiveSnappedViewport() {
            const sheetId = this.getters.getActiveSheetId();
            return this.getSnappedViewport(sheetId);
        }
        getGridDimension(sheet) {
            const lastCol = findLastVisibleColRow(sheet, "cols");
            const effectiveWidth = this.clientWidth - HEADER_WIDTH;
            const lastRow = findLastVisibleColRow(sheet, "rows");
            const effectiveHeight = this.clientHeight - HEADER_HEIGHT;
            const leftCol = sheet.cols.find((col) => col.end > lastCol.end - effectiveWidth) ||
                sheet.cols[sheet.cols.length - 1];
            const topRow = sheet.rows.find((row) => row.end > lastRow.end - effectiveHeight) ||
                sheet.rows[sheet.rows.length - 1];
            const width = lastCol.end +
                Math.max(DEFAULT_CELL_WIDTH, Math.min(leftCol.size, effectiveWidth - lastCol.size));
            const height = lastRow.end +
                Math.max(DEFAULT_CELL_HEIGHT + 5, Math.min(topRow.size, effectiveHeight - lastRow.size));
            return { width, height };
        }
        getMaximumViewportOffset(sheet) {
            const { width, height } = this.getters.getGridDimension(sheet);
            return {
                maxOffsetX: Math.max(0, width - this.clientWidth + HEADER_WIDTH + 1),
                maxOffsetY: Math.max(0, height - this.clientHeight + HEADER_HEIGHT + 1),
            };
        }
        // ---------------------------------------------------------------------------
        // Private
        // ---------------------------------------------------------------------------
        checkOffsetValidity(offsetX, offsetY) {
            const sheet = this.getters.getActiveSheet();
            const { maxOffsetX, maxOffsetY } = this.getMaximumViewportOffset(sheet);
            if (offsetX < 0 || offsetY < 0 || offsetY > maxOffsetY || offsetX > maxOffsetX) {
                return 51 /* InvalidOffset */;
            }
            return 0 /* Success */;
        }
        getSnappedViewport(sheetId) {
            this.snapViewportToCell(sheetId);
            return this.snappedViewports[sheetId];
        }
        getViewport(sheetId) {
            if (!this.viewports[sheetId]) {
                return this.generateViewportState(sheetId);
            }
            return this.viewports[sheetId];
        }
        /** gets rid of deprecated sheetIds */
        cleanViewports() {
            const sheets = this.getters.getVisibleSheets();
            for (let sheetId of Object.keys(this.viewports)) {
                if (!sheets.includes(sheetId)) {
                    delete this.viewports[sheetId];
                }
            }
        }
        resetViewports() {
            for (let [sheetId, viewport] of Object.entries(this.viewports)) {
                this.adjustViewportOffsetX(sheetId, viewport);
                this.adjustViewportOffsetY(sheetId, viewport);
                this.adjustViewportsPosition(sheetId);
            }
        }
        /** Corrects the viewport's horizontal offset based on the current structure
         *  To make sure that at least on column is visible inside the viewport.
         */
        adjustViewportOffsetX(sheetId, viewport) {
            const { offsetX } = viewport;
            const { width: sheetWidth } = this.getGridDimension(this.getters.getSheet(sheetId));
            if (this.clientWidth - HEADER_WIDTH + offsetX > sheetWidth) {
                const diff = this.clientWidth - HEADER_WIDTH + offsetX - sheetWidth;
                viewport.offsetX = Math.max(0, offsetX - diff);
            }
            this.adjustViewportZoneX(sheetId, viewport);
        }
        /** Corrects the viewport's vertical offset based on the current structure
         *  To make sure that at least on row is visible inside the viewport.
         */
        adjustViewportOffsetY(sheetId, viewport) {
            const { offsetY } = viewport;
            const { height: sheetHeight } = this.getGridDimension(this.getters.getSheet(sheetId));
            if (this.clientHeight - HEADER_HEIGHT + offsetY > sheetHeight) {
                const diff = this.clientHeight - HEADER_HEIGHT + offsetY - sheetHeight;
                viewport.offsetY = Math.max(0, offsetY - diff);
            }
            this.adjustViewportZoneY(sheetId, viewport);
        }
        resizeViewport(height, width) {
            this.clientHeight = height;
            this.clientWidth = width;
            this.recomputeViewports();
        }
        recomputeViewports() {
            for (let sheetId of Object.keys(this.viewports)) {
                this.adjustViewportOffsetX(sheetId, this.viewports[sheetId]);
                this.adjustViewportOffsetY(sheetId, this.viewports[sheetId]);
            }
        }
        setViewportOffset(offsetX, offsetY) {
            const sheetId = this.getters.getActiveSheetId();
            this.getActiveViewport();
            this.viewports[sheetId].offsetX = offsetX;
            this.viewports[sheetId].offsetY = offsetY;
            this.adjustViewportZone(sheetId, this.viewports[sheetId]);
        }
        generateViewportState(sheetId) {
            this.viewports[sheetId] = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
                offsetX: 0,
                offsetY: 0,
            };
            return this.viewports[sheetId];
        }
        refreshViewport(sheetId) {
            const viewport = this.getViewport(sheetId);
            this.adjustViewportZone(sheetId, viewport);
            this.adjustViewportsPosition(sheetId);
        }
        adjustViewportZone(sheetId, viewport) {
            this.adjustViewportZoneX(sheetId, viewport);
            this.adjustViewportZoneY(sheetId, viewport);
        }
        /** Updates the viewport zone based on its horizontal offset (will find Left) and its width (will find Right) */
        adjustViewportZoneX(sheetId, viewport) {
            const sheet = this.getters.getSheet(sheetId);
            const cols = sheet.cols;
            viewport.left = this.getters.getColIndex(viewport.offsetX + HEADER_WIDTH, 0, sheet);
            const x = this.clientWidth + viewport.offsetX - HEADER_WIDTH;
            viewport.right = cols.length - 1;
            for (let i = viewport.left; i < cols.length; i++) {
                if (x < cols[i].end) {
                    viewport.right = i;
                    break;
                }
            }
            this.updateSnap = true;
        }
        /** Updates the viewport zone based on its vertical offset (will find Top) and its width (will find Bottom) */
        adjustViewportZoneY(sheetId, viewport) {
            const sheet = this.getters.getSheet(sheetId);
            const rows = sheet.rows;
            viewport.top = this.getters.getRowIndex(viewport.offsetY + HEADER_HEIGHT, 0, sheet);
            const y = this.clientHeight + viewport.offsetY - HEADER_HEIGHT;
            viewport.bottom = rows.length - 1;
            for (let i = viewport.top; i < rows.length; i++) {
                if (y < rows[i].end) {
                    viewport.bottom = i;
                    break;
                }
            }
            this.updateSnap = true;
        }
        /**
         * This function will make sure that the provided cell position (or current selected position) is part of
         * the viewport that is actually displayed on the client, that is, the snapped one. We therefore adjust
         * the offset of the snapped viewport until it contains the cell completely.
         * In order to keep the coherence of both viewports, it is also necessary to update the standard viewport
         * if the zones of both viewports don't match.
         */
        adjustViewportsPosition(sheetId, position) {
            const sheet = this.getters.getSheet(sheetId);
            const { cols, rows } = sheet;
            const adjustedViewport = this.getSnappedViewport(sheetId);
            position = position || this.getters.getSheetPosition(sheetId);
            const [col, row] = getNextVisibleCellCoords(sheet, ...this.getters.getMainCell(sheetId, position[0], position[1]));
            while (cols[col].end > adjustedViewport.offsetX + this.clientWidth - HEADER_WIDTH &&
                adjustedViewport.offsetX < cols[col].start) {
                adjustedViewport.offsetX = cols[adjustedViewport.left].end;
                this.adjustViewportZoneX(sheetId, adjustedViewport);
            }
            while (col < adjustedViewport.left) {
                const step = cols
                    .slice(0, adjustedViewport.left)
                    .reverse()
                    .findIndex((col) => !col.isHidden);
                adjustedViewport.offsetX = cols[adjustedViewport.left - 1 - step].start;
                this.adjustViewportZoneX(sheetId, adjustedViewport);
            }
            while (rows[row].end > adjustedViewport.offsetY + this.clientHeight - HEADER_HEIGHT &&
                adjustedViewport.offsetY < rows[row].start) {
                adjustedViewport.offsetY = rows[adjustedViewport.top].end;
                this.adjustViewportZoneY(sheetId, adjustedViewport);
            }
            while (row < adjustedViewport.top) {
                const step = rows
                    .slice(0, adjustedViewport.top)
                    .reverse()
                    .findIndex((row) => !row.isHidden);
                adjustedViewport.offsetY = rows[adjustedViewport.top - 1 - step].start;
                this.adjustViewportZoneY(sheetId, adjustedViewport);
            }
            // cast the new snappedViewport in the standard viewport
            const { top, left } = this.viewports[sheetId];
            if (top !== adjustedViewport.top || left !== adjustedViewport.left)
                this.viewports[sheetId] = adjustedViewport;
            this.updateSnap = false;
        }
        /** Will update the snapped viewport based on the "standard" viewport to ensure its
         * offsets match the start of the viewport left (resp. top) column (resp. row). */
        snapViewportToCell(sheetId) {
            const { cols, rows } = this.getters.getSheet(sheetId);
            const viewport = this.getViewport(sheetId);
            const adjustedViewport = Object.assign({}, viewport);
            this.adjustViewportOffsetX(sheetId, adjustedViewport);
            this.adjustViewportOffsetY(sheetId, adjustedViewport);
            adjustedViewport.offsetX = cols[adjustedViewport.left].start;
            adjustedViewport.offsetY = rows[adjustedViewport.top].start;
            this.adjustViewportZone(sheetId, adjustedViewport);
            this.snappedViewports[sheetId] = adjustedViewport;
        }
    }
    ViewportPlugin.getters = [
        "getActiveViewport",
        "getSnappedViewport",
        "getActiveSnappedViewport",
        "getViewportDimension",
        "getGridDimension",
        "getMaximumViewportOffset",
    ];
    ViewportPlugin.modes = ["normal"];

    const corePluginRegistry = new Registry()
        .add("sheet", SheetPlugin)
        .add("cell", CellPlugin)
        .add("merge", MergePlugin)
        .add("borders", BordersPlugin)
        .add("conditional formatting", ConditionalFormatPlugin)
        .add("figures", FigurePlugin)
        .add("chart", ChartPlugin);
    const uiPluginRegistry = new Registry()
        .add("selection", SelectionPlugin)
        .add("ui_sheet", SheetUIPlugin)
        .add("ui_options", UIOptionsPlugin)
        .add("evaluation", EvaluationPlugin)
        .add("evaluation_cf", EvaluationConditionalFormatPlugin)
        .add("evaluation_chart", EvaluationChartPlugin)
        .add("clipboard", ClipboardPlugin)
        .add("edition", EditionPlugin)
        .add("highlight", HighlightPlugin)
        .add("selectionInput", SelectionInputPlugin)
        .add("viewport", ViewportPlugin)
        .add("grid renderer", RendererPlugin)
        .add("autofill", AutofillPlugin)
        .add("find_and_replace", FindAndReplacePlugin)
        .add("sort", SortPlugin)
        .add("automatic_sum", AutomaticSumPlugin)
        .add("format", FormatPlugin)
        .add("selection_multiuser", SelectionMultiUserPlugin);

    class LocalTransportService {
        constructor() {
            this.listeners = [];
        }
        sendMessage(message) {
            for (const { callback } of this.listeners) {
                callback(message);
            }
        }
        onNewMessage(id, callback) {
            this.listeners.push({ id, callback });
        }
        leave(id) {
            this.listeners = this.listeners.filter((listener) => listener.id !== id);
        }
    }

    /**
     * DataSourceRegistry is used to contains all the DataSource of spreadsheet.
     * It's role is to ensure that an evaluation is triggered when a data source is
     * ready, and to provide a way to wait for the loading of all the data sources
     */
    class DataSourceRegistry extends owl__namespace.core.EventBus {
        constructor() {
            super(...arguments);
            this.registry = new Registry();
        }
        /**
         * Add a new DataSource.
         *
         * Note that it will load the metadata directly
         */
        add(key, value) {
            this.registry.add(key, value);
            const debouncedLoaded = owl__namespace.utils.debounce(() => this.trigger("data-loaded", { id: key }), 0);
            value.on("data-loaded", this, () => debouncedLoaded());
            value.loadMetadata();
            return this;
        }
        /**
         * Get an item from the registry
         */
        get(key) {
            return this.registry.get(key);
        }
        /**
         * Get a list of all elements in the registry
         */
        getAll() {
            return this.registry.getAll();
        }
        /**
         * Remove an item from the registry
         */
        remove(key) {
            const value = this.get(key);
            value.off("data-loaded", this);
            this.registry.remove(key);
        }
        /**
         * Wait for the loading of all the data sources
         */
        async waitForReady() {
            const proms = [];
            for (const source of this.getAll()) {
                proms.push(source.get());
            }
            return Promise.all(proms);
        }
    }
    /**
     * DataSource is an abstract class that contains the logic of fetching and
     * maintaining access to data that have to be loaded.
     *
     * A class which extends this class have to implement two different methods:
     * * `_fetchMetadata`: This method should fetch the metadata, i.e. data that
     * should be fetch only once.
     *
     * * `_fetch`: This method should fetch the data from the server.
     *
     * To get the data from this class, there is three options:
     * * `get`: async function that will returns the data when it's loaded
     * * `getSync`: get the data that are currently loaded, undefined if no data
     * are loaded
     * * specific method: Subclass can implement concrete method to have access to a
     * particular data.
     */
    class DataSource extends owl__namespace.core.EventBus {
        /**
         * Load the metadata
         */
        async loadMetadata() {
            if (!this.metadataPromise) {
                this.metadataPromise = this._fetchMetadata().then((metadata) => {
                    this.metadata = metadata;
                    return metadata;
                });
            }
            await this.metadataPromise;
        }
        /**
         * This method should be use to get the data
         */
        async get(params) {
            if (params && params.forceFetch) {
                this.data = undefined;
                this.dataPromise = undefined;
            }
            await this.loadMetadata();
            if (!this.dataPromise) {
                this.dataPromise = this._fetch(params).then((data) => {
                    this.data = data;
                    this.lastUpdate = Date.now();
                    this.trigger("data-loaded");
                    return data;
                });
            }
            return this.dataPromise;
        }
        /**
         * Get the data ONLY if it's ready (data are loaded). Returns undefined if
         * it's not ready
         */
        getSync() {
            return this.data;
        }
        /**
         * Get the metadata ONLY if it's ready (loaded). Returns undefined if it's
         * not ready
         */
        getMetadataSync() {
            return this.metadata;
        }
        getLastUpdate() {
            return this.lastUpdate;
        }
    }

    function transformZone(zone, executed) {
        if (executed.type === "REMOVE_COLUMNS_ROWS") {
            return reduceZoneOnDeletion(zone, executed.dimension === "COL" ? "left" : "top", executed.elements);
        }
        if (executed.type === "ADD_COLUMNS_ROWS") {
            return expandZoneOnInsertion(zone, executed.dimension === "COL" ? "left" : "top", executed.base, executed.position, executed.quantity);
        }
        return { ...zone };
    }

    /*
     * This file contains the specifics transformations
     */
    otRegistry.addTransformation("ADD_COLUMNS_ROWS", ["CREATE_CHART", "UPDATE_CHART"], updateChartRangesTransformation);
    otRegistry.addTransformation("REMOVE_COLUMNS_ROWS", ["CREATE_CHART", "UPDATE_CHART"], updateChartRangesTransformation);
    otRegistry.addTransformation("DELETE_FIGURE", ["UPDATE_FIGURE", "UPDATE_CHART"], updateChartFigure);
    otRegistry.addTransformation("CREATE_SHEET", ["CREATE_SHEET"], createSheetTransformation);
    otRegistry.addTransformation("ADD_MERGE", ["ADD_MERGE", "REMOVE_MERGE"], mergeTransformation);
    function updateChartFigure(toTransform, executed) {
        if (toTransform.id === executed.id) {
            return undefined;
        }
        return toTransform;
    }
    function updateChartRangesTransformation(toTransform, executed) {
        const definition = toTransform.definition;
        let labelZone;
        let dataSets;
        if (definition.labelRange) {
            labelZone = transformZone(toZone(definition.labelRange), executed);
        }
        if (definition.dataSets) {
            dataSets = definition.dataSets
                .map(toZone)
                .map((zone) => transformZone(zone, executed))
                .filter(isDefined)
                .map(zoneToXc);
        }
        return {
            ...toTransform,
            definition: {
                ...definition,
                dataSets,
                labelRange: labelZone ? zoneToXc(labelZone) : undefined,
            },
        };
    }
    function createSheetTransformation(cmd, executed) {
        var _a;
        if (cmd.name === executed.name) {
            return {
                ...cmd,
                name: ((_a = cmd.name) === null || _a === void 0 ? void 0 : _a.match(/\d+/))
                    ? cmd.name.replace(/\d+/, (n) => (parseInt(n) + 1).toString())
                    : `${cmd.name}~`,
                position: cmd.position + 1,
            };
        }
        return cmd;
    }
    function mergeTransformation(cmd, executed) {
        if (cmd.sheetId !== executed.sheetId) {
            return cmd;
        }
        const target = [];
        for (const zone1 of cmd.target) {
            for (const zone2 of executed.target) {
                if (!overlap(zone1, zone2)) {
                    target.push({ ...zone1 });
                }
            }
        }
        if (target.length) {
            return { ...cmd, target };
        }
        return undefined;
    }

    const transformations = [
        { match: isSheetDependent, fn: transformSheetId },
        { match: isTargetDependent, fn: transformTarget },
        { match: isPositionDependent, fn: transformPosition },
        { match: isGridDependent, fn: transformDimension },
    ];
    /**
     * Get the result of applying the operation transformations on the given command
     * to transform based on the executed command.
     * Let's see a small example:
     * Given
     *  - command A: set the content of C1 to "Hello"
     *  - command B: add a column after A
     *
     * If command B has been executed locally and not transmitted (yet) to
     * other clients, and command A arrives from an other client to be executed locally.
     * Command A is no longer valid and no longer reflects the user intention.
     * It needs to be transformed knowing that command B is already executed.
     * transform(A, B) => set the content of D1 to "Hello"
     */
    function transform(toTransform, executed) {
        const specificTransform = otRegistry.getTransformation(toTransform.type, executed.type);
        return specificTransform
            ? specificTransform(toTransform, executed)
            : genericTransform(toTransform, executed);
    }
    /**
     * Get the result of applying the operation transformations on all the given
     * commands to transform for each executed commands.
     */
    function transformAll(toTransform, executed) {
        let transformedCommands = [...toTransform];
        for (const executedCommand of executed) {
            transformedCommands = transformedCommands
                .map((cmd) => transform(cmd, executedCommand))
                .filter(isDefined);
        }
        return transformedCommands;
    }
    /**
     * Apply a generic transformation based on the characteristic of the given commands.
     */
    function genericTransform(cmd, executed) {
        for (const { match, fn } of transformations) {
            if (match(cmd)) {
                const result = fn(cmd, executed);
                if (result === "SKIP_TRANSFORMATION") {
                    continue;
                }
                if (result === "IGNORE_COMMAND") {
                    return undefined;
                }
                return result;
            }
        }
        return cmd;
    }
    function transformSheetId(cmd, executed) {
        const deleteSheet = executed.type === "DELETE_SHEET" && executed.sheetId;
        if (cmd.sheetId === deleteSheet) {
            return "IGNORE_COMMAND";
        }
        else if (cmd.type === "CREATE_SHEET" ||
            executed.type === "CREATE_SHEET" ||
            cmd.sheetId !== executed.sheetId) {
            return cmd;
        }
        return "SKIP_TRANSFORMATION";
    }
    function transformTarget(cmd, executed) {
        const target = [];
        for (const zone of cmd.target) {
            const newZone = transformZone(zone, executed);
            if (newZone) {
                target.push(newZone);
            }
        }
        if (!target.length) {
            return "IGNORE_COMMAND";
        }
        return { ...cmd, target };
    }
    function transformDimension(cmd, executed) {
        if (executed.type === "ADD_COLUMNS_ROWS" || executed.type === "REMOVE_COLUMNS_ROWS") {
            if (executed.dimension !== cmd.dimension) {
                return cmd;
            }
            const isUnique = cmd.type === "ADD_COLUMNS_ROWS";
            const field = isUnique ? "base" : "elements";
            let elements = isUnique ? [cmd[field]] : cmd[field];
            if (executed.type === "REMOVE_COLUMNS_ROWS") {
                elements = elements
                    .map((element) => {
                    if (executed.elements.includes(element)) {
                        return undefined;
                    }
                    const executedElements = executed.elements.sort((a, b) => b - a);
                    for (let removedElement of executedElements) {
                        if (element > removedElement) {
                            element--;
                        }
                    }
                    return element;
                })
                    .filter(isDefined);
            }
            if (executed.type === "ADD_COLUMNS_ROWS") {
                const base = executed.position === "before" ? executed.base - 1 : executed.base;
                elements = elements.map((el) => (el > base ? el + executed.quantity : el));
            }
            if (elements.length) {
                let result = elements;
                if (isUnique) {
                    result = elements[0];
                }
                return { ...cmd, [field]: result };
            }
            return "IGNORE_COMMAND";
        }
        return "SKIP_TRANSFORMATION";
    }
    /**
     * Transform a PositionDependentCommand. It could be impacted by a grid command
     * (Add/remove cols/rows) and a merge
     */
    function transformPosition(cmd, executed) {
        if (executed.type === "ADD_COLUMNS_ROWS" || executed.type === "REMOVE_COLUMNS_ROWS") {
            return transformPositionWithGrid(cmd, executed);
        }
        if (executed.type === "ADD_MERGE") {
            return transformPositionWithMerge(cmd, executed);
        }
        return "SKIP_TRANSFORMATION";
    }
    /**
     * Transform a PositionDependentCommand after a grid shape modification. This
     * transformation consists of updating the position.
     */
    function transformPositionWithGrid(cmd, executed) {
        const field = executed.dimension === "COL" ? "col" : "row";
        let base = cmd[field];
        if (executed.type === "REMOVE_COLUMNS_ROWS") {
            const elements = [...executed.elements].sort((a, b) => b - a);
            if (elements.includes(base)) {
                return "IGNORE_COMMAND";
            }
            for (let removedElement of elements) {
                if (base >= removedElement) {
                    base--;
                }
            }
        }
        if (executed.type === "ADD_COLUMNS_ROWS") {
            if (base > executed.base || (base === executed.base && executed.position === "before")) {
                base = base + executed.quantity;
            }
        }
        return { ...cmd, [field]: base };
    }
    /**
     * Transform a PositionDependentCommand after a merge. This transformation
     * consists of checking that the position is not inside the merged zones
     */
    function transformPositionWithMerge(cmd, executed) {
        for (const zone of executed.target) {
            const sameTopLeft = cmd.col === zone.left && cmd.row === zone.top;
            if (!sameTopLeft && isInside(cmd.col, cmd.row, zone)) {
                return "IGNORE_COMMAND";
            }
        }
        return cmd;
    }

    function inverseCommand(cmd) {
        return inverseCommandRegistry.get(cmd.type)(cmd);
    }

    /**
     * Create an empty structure according to the type of the node key:
     * string: object
     * number: array
     */
    function createEmptyStructure(node) {
        if (typeof node === "string") {
            return {};
        }
        else if (typeof node === "number") {
            return [];
        }
        throw new Error(`Cannot create new node`);
    }

    /**
     * A branch holds a sequence of operations.
     * It can be represented as "A - B - C - D" if A, B, C and D are executed one
     * after the other.
     *
     * @param buildTransformation Factory to build transformations
     * @param operations initial operations
     */
    class Branch {
        constructor(buildTransformation, operations = []) {
            this.buildTransformation = buildTransformation;
            this.operations = operations;
        }
        getOperations() {
            return this.operations;
        }
        getOperation(operationId) {
            const operation = this.operations.find((op) => op.id === operationId);
            if (!operation) {
                throw new Error(`Operation ${operationId} not found`);
            }
            return operation;
        }
        getLastOperationId() {
            var _a;
            return (_a = this.operations[this.operations.length - 1]) === null || _a === void 0 ? void 0 : _a.id;
        }
        /**
         * Get the id of the operation appears first in the list of operations
         */
        getFirstOperationAmong(op1, op2) {
            for (const operation of this.operations) {
                if (operation.id === op1)
                    return op1;
                if (operation.id === op2)
                    return op2;
            }
            throw new Error(`Operation ${op1} and ${op2} not found`);
        }
        contains(operationId) {
            return !!this.operations.find((operation) => operation.id === operationId);
        }
        /**
         * Add the given operation as the first operation
         */
        prepend(operation) {
            const transformation = this.buildTransformation.with(operation.data);
            this.operations = [
                operation,
                ...this.operations.map((operation) => operation.transformed(transformation)),
            ];
        }
        /**
         * add the given operation after the given predecessorOpId
         */
        insert(newOperation, predecessorOpId) {
            const transformation = this.buildTransformation.with(newOperation.data);
            const { before, operation, after } = this.locateOperation(predecessorOpId);
            this.operations = [
                ...before,
                operation,
                newOperation,
                ...after.map((operation) => operation.transformed(transformation)),
            ];
        }
        /**
         * Add the given operation as the last operation
         */
        append(operation) {
            this.operations.push(operation);
        }
        /**
         * Append operations in the given branch to this branch.
         */
        appendBranch(branch) {
            this.operations = this.operations.concat(branch.operations);
        }
        /**
         * Create and return a copy of this branch, starting after the given operationId
         */
        fork(operationId) {
            const { after } = this.locateOperation(operationId);
            return new Branch(this.buildTransformation, after);
        }
        /**
         * Transform all the operations in this branch with the given transformation
         */
        transform(transformation) {
            this.operations = this.operations.map((operation) => operation.transformed(transformation));
        }
        /**
         * Cut the branch before the operation, meaning the operation
         * and all following operations are dropped.
         */
        cutBefore(operationId) {
            this.operations = this.locateOperation(operationId).before;
        }
        /**
         * Cut the branch after the operation, meaning all following operations are dropped.
         */
        cutAfter(operationId) {
            const { before, operation } = this.locateOperation(operationId);
            this.operations = before.concat([operation]);
        }
        /**
         * Find an operation in this branch based on its id.
         * This returns the operation itself, operations which comes before it
         * and operation which comes after it.
         */
        locateOperation(operationId) {
            const operationIndex = this.operations.findIndex((step) => step.id === operationId);
            if (operationIndex === -1) {
                throw new Error(`Operation ${operationId} not found`);
            }
            return {
                before: this.operations.slice(0, operationIndex),
                operation: this.operations[operationIndex],
                after: this.operations.slice(operationIndex + 1),
            };
        }
    }

    /**
     * An Operation can be executed to change a data structure from state A
     * to state B.
     * It should hold the necessary data used to perform this transition.
     * It should be possible to revert the changes made by this operation.
     *
     * In the context of o-spreadsheet, the data from an operation would
     * be a revision (the commands are used to execute it, the `changes` are used
     * to revert it).
     */
    class Operation {
        constructor(id, data) {
            this.id = id;
            this.data = data;
        }
        transformed(transformation) {
            return new Operation(this.id, transformation(this.data));
        }
    }

    /**
     * An execution object is a sequence of executionSteps (each execution step is an operation in a branch).
     *
     * You can iterate over the steps of an execution
     * ```js
     * for (const operation of execution) {
     *   // ... do something
     * }
     * ```
     */
    class OperationSequence {
        constructor(operations) {
            this.operations = operations;
        }
        [Symbol.iterator]() {
            return this.operations[Symbol.iterator]();
        }
        /**
         * Stop the operation sequence at a given operation
         * @param operationId included
         */
        stopWith(operationId) {
            function* filter(execution, operationId) {
                for (const step of execution) {
                    yield step;
                    if (step.operation.id === operationId) {
                        return;
                    }
                }
            }
            return new OperationSequence(filter(this.operations, operationId));
        }
        /**
         * Stop the operation sequence before a given operation
         * @param operationId excluded
         */
        stopBefore(operationId) {
            function* filter(execution, operationId) {
                for (const step of execution) {
                    if (step.operation.id === operationId) {
                        return;
                    }
                    yield step;
                }
            }
            return new OperationSequence(filter(this.operations, operationId));
        }
        /**
         * Start the operation sequence at a given operation
         * @param operationId excluded
         */
        startAfter(operationId) {
            function* filter(execution, operationId) {
                let skip = true;
                for (const step of execution) {
                    if (!skip) {
                        yield step;
                    }
                    if (step.operation.id === operationId) {
                        skip = false;
                    }
                }
            }
            return new OperationSequence(filter(this.operations, operationId));
        }
    }

    /**
     * The tree is a data structure used to maintain the different branches of the
     * SelectiveHistory.
     *
     * Branches can be "stacked" on each other and an execution path can be derived
     * from any stack of branches. The rules to derive this path is explained below.
     *
     * An operation can be cancelled/undone by inserting a new branch below
     * this operation.
     * e.g
     *    Given the branch A    B   C
     *    To undo B, a new branching branch is inserted at operation B.
     *    ```txt
     *    A   B   C   D
     *        >   C'  D'
     *    ```
     *    A new execution path can now be derived. At each operation:
     *    - if there is a lower branch, don't execute it and go to the operation below
     *    - if not, execute it and go to the operation on the right.
     *    The execution path is   A   C'    D'
     *    Operation C and D have been adapted (transformed) in the lower branch
     *    since operation B is not executed in this branch.
     *
     */
    class Tree {
        constructor(buildTransformation, initialBranch) {
            this.buildTransformation = buildTransformation;
            this.branchingOperationIds = new Map();
            this.branches = [initialBranch];
        }
        /**
         * Return the last branch of the entire stack of branches.
         */
        getLastBranch() {
            return this.branches[this.branches.length - 1];
        }
        /**
         * Return the sequence of operations from this branch
         * until the very last branch.
         */
        execution(branch) {
            return new OperationSequence(linkNext(this._execution(branch), this._execution(branch)));
        }
        /**
         * Return the sequence of operations from this branch
         * to the very first branch.
         */
        revertedExecution(branch) {
            return new OperationSequence(linkNext(this._revertedExecution(branch), this._revertedExecution(branch)));
        }
        /**
         * Append an operation to the end of the tree.
         * Also insert the (transformed) operation in all previous branches.
         *
         * Adding operation `D` to the last branch
         * ```txt
         *  A1   B1   C1
         *  >    B2   C2
         * ```
         * will give
         * ```txt
         *  A1   B1   C1   D'   with D' = D transformed with A1
         *  >    B2   C2   D
         * ```
         */
        insertOperationLast(branch, operation) {
            var _a;
            const insertAfter = branch.getLastOperationId() || ((_a = this.previousBranch(branch)) === null || _a === void 0 ? void 0 : _a.getLastOperationId());
            branch.append(operation);
            if (insertAfter) {
                this.insertPrevious(branch, operation, insertAfter);
            }
        }
        /**
         * Insert a new operation after an other operation.
         * The operation will be inserted in this branch, in next branches (transformed)
         * and in previous branches (also transformed).
         *
         * Given
         * ```txt
         *  1: A1   B1   C1
         *  2: >    B2   C2
         *  3:      >    C3
         * ```
         * Inserting D to branch 2 gives
         * ```txt
         *  1: A1   B1   C1   D1          D1 = D transformed with A1
         *  2: >    B2   C2   D     with  D  = D
         *  3:      >    C3   D2          D2 = D transformed without B2 (B2⁻¹)
         * ```
         */
        insertOperationAfter(branch, operation, predecessorOpId) {
            branch.insert(operation, predecessorOpId);
            this.updateNextWith(branch, operation, predecessorOpId);
            this.insertPrevious(branch, operation, predecessorOpId);
        }
        /**
         * Create a new branching branch at the given operation.
         * This cancels the operation from the execution path.
         */
        undo(branch, operation) {
            const transformation = this.buildTransformation.without(operation.data);
            const branchingId = this.branchingOperationIds.get(branch);
            this.branchingOperationIds.set(branch, operation.id);
            const nextBranch = branch.fork(operation.id);
            if (branchingId) {
                this.branchingOperationIds.set(nextBranch, branchingId);
            }
            this.insertBranchAfter(branch, nextBranch);
            this.transform(nextBranch, transformation);
        }
        /**
         * Remove the branch just after this one. This un-cancels (redo) the branching
         * operation. Lower branches will be transformed accordingly.
         *
         * Given
         * ```txt
         *  1: A1   B1   C1
         *  2: >    B2   C2
         *  3:      >    C3
         * ```
         * removing the next branch of 1 gives
         *
         * ```txt
         *  1: A1   B1   C1
         *  2:      >    C3'   with  C3' = C1 transformed without B1 (B1⁻¹)
         * ```
         */
        redo(branch) {
            const removedBranch = this.nextBranch(branch);
            if (!removedBranch)
                return;
            const nextBranch = this.nextBranch(removedBranch);
            this.removeBranchFromTree(removedBranch);
            const undoBranchingId = this.branchingOperationIds.get(removedBranch);
            if (undoBranchingId) {
                this.branchingOperationIds.set(branch, undoBranchingId);
            }
            else {
                this.branchingOperationIds.delete(branch);
            }
            if (nextBranch) {
                this.rebaseUp(nextBranch);
            }
        }
        /**
         * Drop the operation and all following operations in every
         * branch
         */
        drop(operationId) {
            for (const branch of this.branches) {
                if (branch.contains(operationId)) {
                    branch.cutBefore(operationId);
                }
            }
        }
        /**
         * Find the operation in the execution path.
         */
        findOperation(branch, operationId) {
            for (const operation of this.revertedExecution(branch)) {
                if (operation.operation.id === operationId) {
                    return operation;
                }
            }
            throw new Error(`Operation ${operationId} not found`);
        }
        /**
         * Rebuild transformed operations of this branch based on the upper branch.
         *
         * Given the following structure:
         * ```txt
         *  1: A1   B1    C1
         *  2: >    B2    C2
         *  3:      >     C3
         * ```
         * Rebasing branch "2" gives
         * ```txt
         *  1: A1   B1    C1
         *  2: >    B2'   C2'  With  B2' = B1 transformed without A1 and C2' = C1 transformed without A1
         *  3:      >     C3'        C3' = C2' transformed without B2'
         * ```
         */
        rebaseUp(branch) {
            const { previousBranch, branchingOperation } = this.findPreviousBranchingOperation(branch);
            if (!previousBranch || !branchingOperation)
                return;
            const rebaseTransformation = this.buildTransformation.without(branchingOperation.data);
            const newBranch = previousBranch.fork(branchingOperation.id);
            this.branchingOperationIds.set(newBranch, this.branchingOperationIds.get(branch));
            this.removeBranchFromTree(branch);
            this.insertBranchAfter(previousBranch, newBranch);
            newBranch.transform(rebaseTransformation);
            const nextBranch = this.nextBranch(newBranch);
            if (nextBranch) {
                this.rebaseUp(nextBranch);
            }
        }
        removeBranchFromTree(branch) {
            const index = this.branches.findIndex((l) => l === branch);
            this.branches.splice(index, 1);
        }
        insertBranchAfter(branch, toInsert) {
            const index = this.branches.findIndex((l) => l === branch);
            this.branches.splice(index + 1, 0, toInsert);
        }
        /**
         * Update the branching branch of this branch, either by (1) inserting the new
         * operation in it or (2) by transforming it.
         * (1) If the operation is positioned before the branching branch, the branching
         *     branch should be transformed with this operation.
         * (2) If it's positioned after, the operation should be inserted in the
         *     branching branch.
         */
        updateNextWith(branch, operation, predecessorOpId) {
            const branchingId = this.branchingOperationIds.get(branch);
            const nextBranch = this.nextBranch(branch);
            if (!branchingId || !nextBranch) {
                return;
            }
            if (branch.getFirstOperationAmong(predecessorOpId, branchingId) === branchingId) {
                const transformedOperation = this.addToNextBranch(branch, nextBranch, branchingId, operation, predecessorOpId);
                this.updateNextWith(nextBranch, transformedOperation, predecessorOpId);
            }
            else {
                const transformation = this.buildTransformation.with(operation.data);
                this.transform(nextBranch, transformation);
            }
        }
        addToNextBranch(branch, nextBranch, branchingId, operation, predecessorOpId) {
            // If the operation is inserted after the branching operation, it should
            // be positioned first.
            let transformedOperation = operation;
            if (predecessorOpId === branchingId) {
                transformedOperation = this.getTransformedOperation(branch, branchingId, operation);
                nextBranch.prepend(transformedOperation);
            }
            else if (nextBranch.contains(predecessorOpId)) {
                transformedOperation = this.getTransformedOperation(branch, branchingId, operation);
                nextBranch.insert(transformedOperation, predecessorOpId);
            }
            else {
                nextBranch.append(operation);
            }
            return transformedOperation;
        }
        getTransformedOperation(branch, branchingId, operation) {
            const branchingOperation = branch.getOperation(branchingId);
            const branchingTransformation = this.buildTransformation.without(branchingOperation.data);
            return operation.transformed(branchingTransformation);
        }
        /**
         * Check if this branch should execute the given operation.
         * i.e. If the operation is not cancelled by a branching branch.
         */
        shouldExecute(branch, operation) {
            return operation.id !== this.branchingOperationIds.get(branch);
        }
        transform(branch, transformation) {
            branch.transform(transformation);
            const nextBranch = this.nextBranch(branch);
            if (nextBranch) {
                this.transform(nextBranch, transformation);
            }
        }
        /**
         * Insert a new operation in previous branches. The operations which are
         * positioned after the inserted operations are transformed with the newly
         * inserted operations. This one is also transformed, with the branching
         * operation.
         */
        insertPrevious(branch, newOperation, insertAfter) {
            const { previousBranch, branchingOperation } = this.findPreviousBranchingOperation(branch);
            if (!previousBranch || !branchingOperation)
                return;
            const transformation = this.buildTransformation.with(branchingOperation.data);
            const branchTail = branch.fork(insertAfter);
            branchTail.transform(transformation);
            previousBranch.cutAfter(insertAfter);
            previousBranch.appendBranch(branchTail);
            const operationToInsert = newOperation.transformed(transformation);
            this.insertPrevious(previousBranch, operationToInsert, insertAfter);
        }
        findPreviousBranchingOperation(branch) {
            const previousBranch = this.previousBranch(branch);
            if (!previousBranch)
                return { previousBranch: undefined, branchingOperation: undefined };
            const previousBranchingId = this.branchingOperationIds.get(previousBranch);
            if (!previousBranchingId)
                return { previousBranch: undefined, branchingOperation: undefined };
            return {
                previousBranch,
                branchingOperation: previousBranch.getOperation(previousBranchingId),
            };
        }
        /**
         * Retrieve the next branch of the given branch
         */
        nextBranch(branch) {
            const index = this.branches.findIndex((l) => l === branch);
            if (index === -1) {
                return undefined;
            }
            return this.branches[index + 1];
        }
        /**
         * Retrieve the previous branch of the given branch
         */
        previousBranch(branch) {
            const index = this.branches.findIndex((l) => l === branch);
            if (index === -1) {
                return undefined;
            }
            return this.branches[index - 1];
        }
        /**
         * Yields the sequence of operations to execute, in reverse order.
         */
        *_revertedExecution(branch) {
            const branchingOperationId = this.branchingOperationIds.get(branch);
            let afterBranchingPoint = !!branchingOperationId;
            const operations = branch.getOperations();
            for (let i = operations.length - 1; i >= 0; i--) {
                const operation = operations[i];
                if (operation.id === branchingOperationId) {
                    afterBranchingPoint = false;
                }
                if (!afterBranchingPoint) {
                    yield {
                        operation: operation,
                        branch: branch,
                        isCancelled: !this.shouldExecute(branch, operation),
                    };
                }
            }
            const previous = this.previousBranch(branch);
            yield* previous ? this._revertedExecution(previous) : [];
        }
        /**
         * Yields the sequence of operations to execute
         */
        *_execution(branch) {
            for (const operation of branch.getOperations()) {
                yield {
                    operation: operation,
                    branch: branch,
                    isCancelled: !this.shouldExecute(branch, operation),
                };
                if (operation.id === this.branchingOperationIds.get(branch)) {
                    const next = this.nextBranch(branch);
                    yield* next ? this._execution(next) : [];
                    return;
                }
            }
            if (!this.branchingOperationIds.get(branch)) {
                const next = this.nextBranch(branch);
                yield* next ? this._execution(next) : [];
            }
        }
    }

    class SelectiveHistory {
        /**
         * The selective history is a data structure used to register changes/updates of a state.
         * Each change/update is called an "operation".
         * The data structure allows to easily cancel (and redo) any operation individually.
         * An operation can be represented by any data structure. It can be a "command", a "diff", etc.
         * However it must have the following properties:
         * - it can be applied to modify the state
         * - it can be reverted on the state such that it was never executed.
         * - it can be transformed given other operation (Operational Transformation)
         *
         * Since this data structure doesn't know anything about the state nor the structure of
         * operations, the actual work must be performed by external functions given as parameters.
         * @param initialOperationId
         * @param applyOperation a function which can apply an operation to the state
         * @param revertOperation  a function which can revert an operation from the state
         * @param buildEmpty  a function returning an "empty" operation.
         *                    i.e an operation that leaves the state unmodified once applied or reverted
         *                    (used for internal implementation)
         * @param buildTransformation Factory used to build transformations
         */
        constructor(initialOperationId, applyOperation, revertOperation, buildEmpty, buildTransformation) {
            this.applyOperation = applyOperation;
            this.revertOperation = revertOperation;
            this.buildEmpty = buildEmpty;
            this.buildTransformation = buildTransformation;
            this.HEAD_BRANCH = new Branch(this.buildTransformation);
            this.tree = new Tree(buildTransformation, this.HEAD_BRANCH);
            const initial = new Operation(initialOperationId, buildEmpty(initialOperationId));
            this.tree.insertOperationLast(this.HEAD_BRANCH, initial);
            this.HEAD_OPERATION = initial;
        }
        /**
         * Return the operation identified by its id.
         */
        get(operationId) {
            return this.tree.findOperation(this.HEAD_BRANCH, operationId).operation.data;
        }
        /**
         * Append a new operation as the last one
         */
        append(operationId, data) {
            const operation = new Operation(operationId, data);
            const branch = this.tree.getLastBranch();
            this.tree.insertOperationLast(branch, operation);
            this.HEAD_BRANCH = branch;
            this.HEAD_OPERATION = operation;
        }
        /**
         * Insert a new operation after a specific operation (may not be the last operation).
         * Following operations will be transformed according
         * to the new operation.
         */
        insert(operationId, data, insertAfter) {
            const operation = new Operation(operationId, data);
            this.revertTo(insertAfter);
            this.tree.insertOperationAfter(this.HEAD_BRANCH, operation, insertAfter);
            this.fastForward();
        }
        /**
         * @param operationId operation to undo
         * @param undoId the id of the "undo operation"
         * @param insertAfter the id of the operation after which to insert the undo
         */
        undo(operationId, undoId, insertAfter) {
            const { branch, operation } = this.tree.findOperation(this.HEAD_BRANCH, operationId);
            this.revertBefore(operationId);
            this.tree.undo(branch, operation);
            this.fastForward();
            this.insert(undoId, this.buildEmpty(undoId), insertAfter);
        }
        /**
         * @param operationId operation to redo
         * @param redoId the if of the "redo operation"
         * @param insertAfter the id of the operation after which to insert the redo
         */
        redo(operationId, redoId, insertAfter) {
            const { branch } = this.tree.findOperation(this.HEAD_BRANCH, operationId);
            this.revertBefore(operationId);
            this.tree.redo(branch);
            this.fastForward();
            this.insert(redoId, this.buildEmpty(redoId), insertAfter);
        }
        drop(operationId) {
            this.revertBefore(operationId);
            this.tree.drop(operationId);
        }
        /**
         * Revert the state as it was *before* the given operation was executed.
         */
        revertBefore(operationId) {
            const execution = this.tree.revertedExecution(this.HEAD_BRANCH).stopWith(operationId);
            this.revert(execution);
        }
        /**
         * Revert the state as it was *after* the given operation was executed.
         */
        revertTo(operationId) {
            const execution = operationId
                ? this.tree.revertedExecution(this.HEAD_BRANCH).stopBefore(operationId)
                : this.tree.revertedExecution(this.HEAD_BRANCH);
            this.revert(execution);
        }
        /**
         * Revert an execution
         */
        revert(execution) {
            for (const { next, operation, isCancelled } of execution) {
                if (!isCancelled) {
                    this.revertOperation(operation.data);
                }
                if (next) {
                    this.HEAD_BRANCH = next.branch;
                    this.HEAD_OPERATION = next.operation;
                }
            }
        }
        /**
         * Replay the operations between the current HEAD_BRANCH and the end of the tree
         */
        fastForward() {
            const operations = this.HEAD_OPERATION
                ? this.tree.execution(this.HEAD_BRANCH).startAfter(this.HEAD_OPERATION.id)
                : this.tree.execution(this.HEAD_BRANCH);
            for (const { operation: operation, branch, isCancelled } of operations) {
                if (!isCancelled) {
                    this.applyOperation(operation.data);
                }
                this.HEAD_OPERATION = operation;
                this.HEAD_BRANCH = branch;
            }
        }
    }

    function buildRevisionLog(initialRevisionId, recordChanges, dispatch) {
        return new SelectiveHistory(initialRevisionId, (revision) => {
            const commands = revision.commands.slice();
            const { changes } = recordChanges(() => {
                for (const command of commands) {
                    dispatch(command);
                }
            });
            revision.setChanges(changes);
        }, (revision) => revertChanges([revision]), (id) => new Revision(id, "empty", [], []), {
            with: (revision) => (toTransform) => {
                return new Revision(toTransform.id, toTransform.clientId, transformAll(toTransform.commands, revision.commands));
            },
            without: (revision) => (toTransform) => {
                return new Revision(toTransform.id, toTransform.clientId, transformAll(toTransform.commands, revision.commands.map(inverseCommand).flat()));
            },
        });
    }
    /**
     * Revert changes from the given revisions
     */
    function revertChanges(revisions) {
        for (const revision of revisions.slice().reverse()) {
            for (let i = revision.changes.length - 1; i >= 0; i--) {
                const change = revision.changes[i];
                applyChange(change, "before");
            }
        }
    }
    /**
     * Apply the changes of the given HistoryChange to the state
     */
    function applyChange(change, target) {
        let val = change.root;
        let key = change.path[change.path.length - 1];
        for (let pathIndex = 0; pathIndex < change.path.slice(0, -1).length; pathIndex++) {
            const p = change.path[pathIndex];
            if (val[p] === undefined) {
                const nextPath = change.path[pathIndex + 1];
                val[p] = createEmptyStructure(nextPath);
            }
            val = val[p];
        }
        if (change[target] === undefined) {
            delete val[key];
        }
        else {
            val[key] = change[target];
        }
    }

    /**
     * Local History
     *
     * The local history is responsible of tracking the locally state updates
     * It maintains the local undo and redo stack to allow to undo/redo only local
     * changes
     */
    class LocalHistory extends owl__namespace.core.EventBus {
        constructor(dispatch, session) {
            super();
            this.dispatch = dispatch;
            this.session = session;
            /**
             * Ids of the revisions which can be undone
             */
            this.undoStack = [];
            /**
             * Ids of the revisions which can be redone
             */
            this.redoStack = [];
            /**
             * Flag used to block all commands when an undo or redo is triggered, until
             * it is accepted on the server
             */
            this.isWaitingForUndoRedo = false;
            this.session.on("new-local-state-update", this, this.onNewLocalStateUpdate);
            this.session.on("revision-undone", this, ({ commands }) => this.selectiveUndo(commands));
            this.session.on("revision-redone", this, ({ commands }) => this.selectiveRedo(commands));
            this.session.on("pending-revisions-dropped", this, ({ revisionIds }) => this.drop(revisionIds));
            this.session.on("snapshot", this, () => {
                this.undoStack = [];
                this.redoStack = [];
                this.isWaitingForUndoRedo = false;
            });
        }
        allowDispatch(cmd) {
            if (this.isWaitingForUndoRedo) {
                return 47 /* WaitingSessionConfirmation */;
            }
            switch (cmd.type) {
                case "REQUEST_UNDO":
                    if (!this.canUndo()) {
                        return 5 /* EmptyUndoStack */;
                    }
                    break;
                case "REQUEST_REDO":
                    if (!this.canRedo()) {
                        return 6 /* EmptyRedoStack */;
                    }
                    break;
            }
            return 0 /* Success */;
        }
        beforeHandle(cmd) { }
        handle(cmd) {
            switch (cmd.type) {
                case "REQUEST_UNDO":
                case "REQUEST_REDO":
                    // History changes (undo & redo) are *not* applied optimistically on the local state.
                    // We wait a global confirmation from the server. The goal is to avoid handling concurrent
                    // history changes on multiple clients which are very hard to manage correctly.
                    this.requestHistoryChange(cmd.type === "REQUEST_UNDO" ? "UNDO" : "REDO");
            }
        }
        finalize() { }
        requestHistoryChange(type) {
            const id = type === "UNDO" ? this.undoStack.pop() : this.redoStack.pop();
            if (!id) {
                return;
            }
            this.isWaitingForUndoRedo = true;
            if (type === "UNDO") {
                this.session.undo(id);
                this.redoStack.push(id);
            }
            else {
                this.session.redo(id);
                this.undoStack.push(id);
            }
        }
        canUndo() {
            return this.undoStack.length > 0;
        }
        canRedo() {
            return this.redoStack.length > 0;
        }
        drop(revisionIds) {
            this.undoStack = this.undoStack.filter((id) => !revisionIds.includes(id));
            this.redoStack = [];
            this.isWaitingForUndoRedo = false;
        }
        onNewLocalStateUpdate({ id }) {
            this.undoStack.push(id);
            this.redoStack = [];
            if (this.undoStack.length > MAX_HISTORY_STEPS) {
                this.undoStack.shift();
            }
        }
        selectiveUndo(commands) {
            this.dispatch("UNDO", { commands });
            this.isWaitingForUndoRedo = false;
        }
        selectiveRedo(commands) {
            this.dispatch("REDO", { commands });
            this.isWaitingForUndoRedo = false;
        }
    }

    class RangeAdapter {
        constructor(getters) {
            this.providers = [];
            this.getters = getters;
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        allowDispatch(command) {
            return 0 /* Success */;
        }
        beforeHandle(command) { }
        handle(cmd) {
            switch (cmd.type) {
                case "REMOVE_COLUMNS_ROWS": {
                    let start = cmd.dimension === "COL" ? "left" : "top";
                    let end = cmd.dimension === "COL" ? "right" : "bottom";
                    let dimension = cmd.dimension === "COL" ? "columns" : "rows";
                    cmd.elements.sort((a, b) => b - a);
                    const groups = groupConsecutive(cmd.elements);
                    this.executeOnAllRanges((range) => {
                        if (range.sheetId !== cmd.sheetId) {
                            return { changeType: "NONE" };
                        }
                        let newRange = range;
                        let changeType = "NONE";
                        for (let group of groups) {
                            const min = Math.min(...group);
                            const max = Math.max(...group);
                            if (range.zone[start] <= min && min <= range.zone[end]) {
                                const toRemove = Math.min(range.zone[end], max) - min + 1;
                                changeType = "RESIZE";
                                newRange = this.createAdaptedRange(newRange, dimension, changeType, -toRemove);
                            }
                            else if (range.zone[start] >= min && range.zone[end] <= max) {
                                changeType = "REMOVE";
                            }
                            else if (range.zone[start] <= max && range.zone[end] >= max) {
                                const toRemove = max - range.zone[start] + 1;
                                changeType = "RESIZE";
                                newRange = this.createAdaptedRange(newRange, dimension, changeType, -toRemove);
                                newRange = this.createAdaptedRange(newRange, dimension, "MOVE", -(range.zone[start] - min));
                            }
                            else if (min < range.zone[start]) {
                                changeType = "MOVE";
                                newRange = this.createAdaptedRange(newRange, dimension, changeType, -(max - min + 1));
                            }
                        }
                        if (changeType !== "NONE") {
                            return { changeType, range: newRange };
                        }
                        return { changeType: "NONE" };
                    }, cmd.sheetId);
                    break;
                }
                case "ADD_COLUMNS_ROWS": {
                    let start = cmd.dimension === "COL" ? "left" : "top";
                    let end = cmd.dimension === "COL" ? "right" : "bottom";
                    let dimension = cmd.dimension === "COL" ? "columns" : "rows";
                    this.executeOnAllRanges((range) => {
                        if (range.sheetId !== cmd.sheetId) {
                            return { changeType: "NONE" };
                        }
                        if (cmd.position === "after") {
                            if (range.zone[start] <= cmd.base && cmd.base < range.zone[end]) {
                                return {
                                    changeType: "RESIZE",
                                    range: this.createAdaptedRange(range, dimension, "RESIZE", cmd.quantity),
                                };
                            }
                            if (cmd.base < range.zone[start]) {
                                return {
                                    changeType: "MOVE",
                                    range: this.createAdaptedRange(range, dimension, "MOVE", cmd.quantity),
                                };
                            }
                        }
                        else {
                            if (range.zone[start] < cmd.base && cmd.base <= range.zone[end]) {
                                return {
                                    changeType: "RESIZE",
                                    range: this.createAdaptedRange(range, dimension, "RESIZE", cmd.quantity),
                                };
                            }
                            if (cmd.base <= range.zone[start]) {
                                return {
                                    changeType: "MOVE",
                                    range: this.createAdaptedRange(range, dimension, "MOVE", cmd.quantity),
                                };
                            }
                        }
                        return { changeType: "NONE" };
                    }, cmd.sheetId);
                    break;
                }
                case "DELETE_SHEET": {
                    this.executeOnAllRanges((range) => {
                        if (range.sheetId !== cmd.sheetId) {
                            return { changeType: "NONE" };
                        }
                        range = {
                            ...range,
                            zone: { ...range.zone },
                            invalidSheetName: this.getters.getSheetName(cmd.sheetId),
                            sheetId: "",
                        };
                        return { changeType: "REMOVE", range };
                    }, cmd.sheetId);
                    break;
                }
                case "RENAME_SHEET": {
                    this.executeOnAllRanges((range) => {
                        if (range.sheetId === cmd.sheetId) {
                            return { changeType: "CHANGE", range };
                        }
                        if (cmd.name && range.invalidSheetName === cmd.name) {
                            const newRange = { ...range, zone: { ...range.zone } };
                            newRange.invalidSheetName = undefined;
                            newRange.sheetId = cmd.sheetId;
                            return { changeType: "CHANGE", range: newRange };
                        }
                        return { changeType: "NONE" };
                    });
                    break;
                }
            }
        }
        finalize() { }
        /**
         * Return a modified adapting function that verifies that after adapting a range, the range is still valid.
         * Any range that gets adapted by the function adaptRange in parameter does so
         * without caring if the start and end of the range in both row and column
         * direction can be incorrect. This function ensure that an incorrect range gets removed.
         */
        verifyRangeRemoved(adaptRange) {
            return (range) => {
                const result = adaptRange(range);
                if (result.changeType !== "NONE" && !isZoneValid(result.range.zone)) {
                    return { range: result.range, changeType: "REMOVE" };
                }
                return result;
            };
        }
        createAdaptedRange(range, dimension, operation, by) {
            return {
                ...range,
                zone: createAdaptedZone(range.zone, dimension, operation, by),
            };
        }
        executeOnAllRanges(adaptRange, sheetId) {
            const func = this.verifyRangeRemoved(adaptRange);
            for (const provider of this.providers) {
                provider(func, sheetId);
            }
        }
        /**
         * Stores the functions bound to each plugin to be able to iterate over all ranges of the application,
         * without knowing any details of the internal data structure of the plugins and without storing ranges
         * in the range adapter.
         *
         * @param provider a function bound to a plugin that will loop over its internal data structure to find
         * all ranges
         */
        addRangeProvider(provider) {
            this.providers.push(provider);
        }
        /**
         * Check that a zone is valid regarding the order of top-bottom and left-right.
         * Left should be smaller than right, top should be smaller than bottom.
         * If it's not the case, simply invert them, and invert the linked parts
         * (in place!)
         */
        orderZone(zone, parts) {
            if (zone.right < zone.left) {
                let right = zone.right;
                zone.right = zone.left;
                zone.left = right;
                let rightFixed = parts[1].colFixed;
                parts[1].colFixed = parts[0].colFixed;
                parts[0].colFixed = rightFixed;
            }
            if (zone.bottom < zone.top) {
                let bottom = zone.bottom;
                zone.bottom = zone.top;
                zone.top = bottom;
                let bottomFixed = parts[1].rowFixed;
                parts[1].rowFixed = parts[0].rowFixed;
                parts[0].rowFixed = bottomFixed;
            }
        }
        // ---------------------------------------------------------------------------
        // Getters
        // ---------------------------------------------------------------------------
        createAdaptedRanges(ranges, offsetX, offsetY, sheetId) {
            return ranges.map((range) => {
                if (!isZoneValid(range.zone)) {
                    return range;
                }
                range = {
                    ...range,
                    sheetId: range.prefixSheet ? range.sheetId : sheetId,
                    zone: {
                        left: range.zone.left + (range.parts[0].colFixed ? 0 : offsetX),
                        right: range.zone.right + ((range.parts[1] || range.parts[0]).colFixed ? 0 : offsetX),
                        top: range.zone.top + (range.parts[0].rowFixed ? 0 : offsetY),
                        bottom: range.zone.bottom + ((range.parts[1] || range.parts[0]).rowFixed ? 0 : offsetY),
                    },
                };
                this.orderZone(range.zone, range.parts);
                return range;
            });
        }
        /**
         * Creates a range from a XC reference that can contain a sheet reference
         * @param defaultSheetId the sheet to default to if the sheetXC parameter does not contain a sheet reference (usually the active sheet Id)
         * @param sheetXC the string description of a range, in the form SheetName!XC:XC
         */
        getRangeFromSheetXC(defaultSheetId, sheetXC) {
            let xc = sheetXC;
            let sheetName = "";
            let sheetId;
            let invalidSheetName;
            let prefixSheet = false;
            if (!rangeReference.test(sheetXC)) {
                return this.buildInvalidRange(sheetXC);
            }
            if (sheetXC.includes("!")) {
                [xc, sheetName] = sheetXC.split("!").reverse();
                if (sheetName) {
                    sheetId = this.getters.getSheetIdByName(sheetName);
                    prefixSheet = true;
                    if (!sheetId) {
                        invalidSheetName = sheetName;
                    }
                }
                else {
                    invalidSheetName = sheetName;
                }
            }
            const zone = toZoneWithoutBoundaryChanges(xc);
            let rangeParts = xc.split(":").map((p) => {
                return {
                    colFixed: p.startsWith("$"),
                    rowFixed: p.includes("$", 1),
                };
            });
            this.orderZone(zone, rangeParts);
            return {
                sheetId: sheetId || defaultSheetId,
                zone: zone,
                parts: rangeParts,
                invalidSheetName,
                prefixSheet,
            };
        }
        /**
         * Gets the string that represents the range as it is at the moment of the call.
         * The string will be prefixed with the sheet name if the call specified a sheet id in `forSheetId`
         * different than the sheet on which the range has been created.
         *
         * @param range the range (received from getRangeFromXC or getRangeFromZone)
         * @param forSheetId the id of the sheet where the range string is supposed to be used.
         */
        getRangeString(range, forSheetId) {
            if (!range) {
                return INCORRECT_RANGE_STRING;
            }
            if (range.invalidXc) {
                return range.invalidXc;
            }
            if (range.zone.bottom - range.zone.top < 0 || range.zone.right - range.zone.left < 0) {
                return INCORRECT_RANGE_STRING;
            }
            if (range.zone.left < 0 || range.zone.top < 0) {
                return INCORRECT_RANGE_STRING;
            }
            let prefixSheet = range.sheetId !== forSheetId || range.invalidSheetName || range.prefixSheet;
            let sheetName = "";
            if (prefixSheet) {
                if (range.invalidSheetName) {
                    sheetName = range.invalidSheetName;
                }
                else {
                    sheetName = getComposerSheetName(this.getters.getSheetName(range.sheetId));
                }
            }
            if (prefixSheet && !sheetName) {
                return INCORRECT_RANGE_STRING;
            }
            let ref = Array(9);
            ref[0] = range.parts && range.parts[0].colFixed ? "$" : "";
            ref[1] = numberToLetters(range.zone.left);
            ref[2] = range.parts && range.parts[0].rowFixed ? "$" : "";
            ref[3] = String(range.zone.top + 1);
            if (range.parts && range.parts.length === 2) {
                // this if converts A2:A2 into A2 except if any part of the original range had fixed row or column (with $)
                if (range.zone.top !== range.zone.bottom ||
                    range.zone.left !== range.zone.right ||
                    range.parts[0].rowFixed ||
                    range.parts[0].colFixed ||
                    range.parts[1].rowFixed ||
                    range.parts[1].colFixed) {
                    ref[4] = ":";
                    ref[5] = range.parts[1].colFixed ? "$" : "";
                    ref[6] = numberToLetters(range.zone.right);
                    ref[7] = range.parts[1].rowFixed ? "$" : "";
                    ref[8] = String(range.zone.bottom + 1);
                }
            }
            return `${prefixSheet ? sheetName + "!" : ""}${ref.join("")}`;
        }
        // ---------------------------------------------------------------------------
        // Private
        // ---------------------------------------------------------------------------
        buildInvalidRange(invalidXc) {
            return {
                parts: [],
                prefixSheet: false,
                zone: { left: -1, top: -1, right: -1, bottom: -1 },
                sheetId: "",
                invalidXc,
            };
        }
    }
    RangeAdapter.getters = ["getRangeString", "getRangeFromSheetXC", "createAdaptedRanges"];

    class StateObserver {
        constructor() {
            this.changes = [];
            this.commands = [];
        }
        /**
         * Record the changes which could happen in the given callback, save them in a
         * new revision with the given id and userId.
         */
        recordChanges(callback) {
            this.changes = [];
            this.commands = [];
            callback();
            return { changes: this.changes, commands: this.commands };
        }
        addCommand(command) {
            this.commands.push(command);
        }
        addChange(...args) {
            const val = args.pop();
            const [root, ...path] = args;
            let value = root;
            let key = path[path.length - 1];
            for (let pathIndex = 0; pathIndex <= path.length - 2; pathIndex++) {
                const p = path[pathIndex];
                if (value[p] === undefined) {
                    const nextPath = path[pathIndex + 1];
                    value[p] = createEmptyStructure(nextPath);
                }
                value = value[p];
            }
            if (value[key] === val) {
                return;
            }
            this.changes.push({
                root,
                path,
                before: value[key],
                after: val,
            });
            if (val === undefined) {
                delete value[key];
            }
            else {
                value[key] = val;
            }
        }
    }

    const XLSX_FORMAT_MAP = {
        General: 0,
        "0": 1,
        "0.00": 2,
        "#,#00": 3,
        "#,##0.00": 4,
        "0%": 9,
        "0.00%": 10,
        "0.00E+00": 11,
        "# ?/?": 12,
        "# ??/??": 13,
        "mm-dd-yy": 14,
        "d-mm-yy": 15,
        "mm-yy": 16,
        "mmm-yy": 17,
        "h:mm AM/PM": 18,
        "h:mm:ss AM/PM": 19,
        "h:mm": 20,
        "h:mm:ss": 21,
        "m/d/yy h:mm": 22,
        "#,##0 ;(#,##0)": 37,
        "#,##0 ;[Red](#,##0)": 38,
        "#,##0.00;(#,##0.00)": 39,
        "#,##0.00;[Red](#,##0.00)": 40,
        "mm:ss": 45,
        "[h]:mm:ss": 46,
        "mmss.0": 47,
        "##0.0E+0": 48,
        "@": 49,
        "hh:mm:ss a": 19, // TODO: discuss: this format is not recognized by excel for example (doesn't follow their guidelines I guess)
    };
    const XLSX_ICONSET_MAP = {
        arrow: "3Arrows",
        smiley: "3Symbols",
        dot: "3TrafficLights1",
    };
    const NAMESPACE = {
        styleSheet: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
        sst: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
        Relationships: "http://schemas.openxmlformats.org/package/2006/relationships",
        Types: "http://schemas.openxmlformats.org/package/2006/content-types",
        worksheet: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
        workbook: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
        drawing: "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing",
    };
    const DRAWING_NS_A = "http://schemas.openxmlformats.org/drawingml/2006/main";
    const DRAWING_NS_C = "http://schemas.openxmlformats.org/drawingml/2006/chart";
    const CONTENT_TYPES = {
        workbook: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
        sheet: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
        sharedStrings: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
        styles: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
        drawing: "application/vnd.openxmlformats-officedocument.drawing+xml",
        chart: "application/vnd.openxmlformats-officedocument.drawingml.chart+xml",
    };
    const RELATIONSHIP_NSR = "http://schemas.openxmlformats.org/officeDocument/2006/relationships";
    const HEIGHT_FACTOR = 0.75; // 100px => 75 u
    const WIDTH_FACTOR = 0.1425; // 100px => 14.25 u
    const FIRST_NUMFMT_ID = 164;
    const FORCE_DEFAULT_ARGS_FUNCTIONS = {
        FLOOR: [{ type: "NUMBER", value: 1 }],
        CEILING: [{ type: "NUMBER", value: 1 }],
        ROUND: [{ type: "NUMBER", value: 0 }],
        ROUNDUP: [{ type: "NUMBER", value: 0 }],
        ROUNDDOWN: [{ type: "NUMBER", value: 0 }],
    };
    /**
     * This list contains all "future" functions that are not compatible with older versions of Excel
     * For more information, see https://docs.microsoft.com/en-us/openspecs/office_standards/ms-xlsx/5d1b6d44-6fc1-4ecd-8fef-0b27406cc2bf
     */
    const NON_RETROCOMPATIBLE_FUNCTIONS = [
        "ACOT",
        "ACOTH",
        "AGGREGATE",
        "ARABIC",
        "BASE",
        "BETA.DIST",
        "BETA.INV",
        "BINOM.DIST",
        "BINOM.DIST.RANGE",
        "BINOM.INV",
        "BITAND",
        "BITLSHIFT",
        "BITOR",
        "BITRSHIFT",
        "BITXOR",
        "CEILING.MATH",
        "CEILING.PRECISE",
        "CHISQ.DIST",
        "CHISQ.DIST.RT",
        "CHISQ.INV",
        "CHISQ.INV.RT",
        "CHISQ.TEST",
        "COMBINA",
        "CONCAT",
        "CONFIDENCE.NORM",
        "CONFIDENCE.T",
        "COT",
        "COTH",
        "COVARIANCE.P",
        "COVARIANCE.S",
        "CSC",
        "CSCH",
        "DAYS",
        "DECIMAL",
        "ERF.PRECISE",
        "ERFC.PRECISE",
        "EXPON.DIST",
        "F.DIST",
        "F.DIST.RT",
        "F.INV",
        "F.INV.RT",
        "F.TEST",
        "FILTERXML",
        "FLOOR.MATH",
        "FLOOR.PRECISE",
        "FORECAST.ETS",
        "FORECAST.ETS.CONFINT",
        "FORECAST.ETS.SEASONALITY",
        "FORECAST.ETS.STAT",
        "FORECAST.LINEAR",
        "FORMULATEXT",
        "GAMMA",
        "GAMMA.DIST",
        "GAMMA.INV",
        "GAMMALN.PRECISE",
        "GAUSS",
        "HYPGEOM.DIST",
        "IFNA",
        "IFS",
        "IMCOSH",
        "IMCOT",
        "IMCSC",
        "IMCSCH",
        "IMSEC",
        "IMSECH",
        "IMSINH",
        "IMTAN",
        "ISFORMULA",
        "ISOWEEKNUM",
        "LOGNORM.DIST",
        "LOGNORM.INV",
        "MAXIFS",
        "MINIFS",
        "MODE.MULT",
        "MODE.SNGL",
        "MUNIT",
        "NEGBINOM.DIST",
        "NORM.DIST",
        "NORM.INV",
        "NORM.S.DIST",
        "NORM.S.INV",
        "NUMBERVALUE",
        "PDURATION",
        "PERCENTILE.EXC",
        "PERCENTILE.INC",
        "PERCENTRANK.EXC",
        "PERCENTRANK.INC",
        "PERMUTATIONA",
        "PHI",
        "POISSON.DIST",
        "QUARTILE.EXC",
        "QUARTILE.INC",
        "QUERYSTRING",
        "RANK.AVG",
        "RANK.EQ",
        "RRI",
        "SEC",
        "SECH",
        "SHEET",
        "SHEETS",
        "SKEW.P",
        "STDEV.P",
        "STDEV.S",
        "SWITCH",
        "T.DIST",
        "T.DIST.2T",
        "T.DIST.RT",
        "T.INV",
        "T.INV.2T",
        "T.TEST",
        "TEXTJOIN",
        "UNICHAR",
        "UNICODE",
        "VAR.P",
        "VAR.S",
        "WEBSERVICE",
        "WEIBULL.DIST",
        "XOR",
        "Z.TEST",
    ];

    // -------------------------------------
    //            CF HELPERS
    // -------------------------------------
    /**
     * Convert the conditional formatting o-spreadsheet operator to
     * the corresponding excel operator.
     * */
    function convertOperator(operator) {
        switch (operator) {
            case "IsNotEmpty":
                return "notContainsBlanks";
            case "IsEmpty":
                return "containsBlanks";
            case "NotContains":
                return "notContainsBlanks";
            default:
                return operator.charAt(0).toLowerCase() + operator.slice(1);
        }
    }
    // -------------------------------------
    //        WORKSHEET HELPERS
    // -------------------------------------
    function getCellType(value) {
        switch (typeof value) {
            case "boolean":
                return "b";
            case "string":
                return "str";
            case "number":
                return "n";
        }
    }
    /**
     * For some reason, Excel will only take the devicePixelRatio (i.e. interface scale on Windows desktop)
     * into account for the height.
     */
    function convertHeight(height) {
        return Math.round(HEIGHT_FACTOR * height * window.devicePixelRatio * 100) / 100;
    }
    function convertWidth(width) {
        return Math.round(WIDTH_FACTOR * width * 100) / 100;
    }
    function extractStyle(cell, data) {
        let style = {};
        if (cell.style) {
            style = data.styles[cell.style];
        }
        let border = {};
        if (cell.border) {
            border = data.borders[cell.border];
        }
        const styles = {
            font: {
                size: (style === null || style === void 0 ? void 0 : style.fontSize) || DEFAULT_FONT_SIZE,
                color: (style === null || style === void 0 ? void 0 : style.textColor) ? style.textColor : "000000",
                family: 2,
                name: "Arial",
            },
            fill: (style === null || style === void 0 ? void 0 : style.fillColor)
                ? {
                    fgColor: style.fillColor,
                }
                : { reservedAttribute: "none" },
            numFmt: cell.format,
            border: border || {},
            verticalAlignment: "center",
            horizontalAlignment: style === null || style === void 0 ? void 0 : style.align,
        };
        styles.font["strike"] = !!(style === null || style === void 0 ? void 0 : style.strikethrough) || undefined;
        styles.font["underline"] = !!(style === null || style === void 0 ? void 0 : style.underline) || undefined;
        styles.font["bold"] = !!(style === null || style === void 0 ? void 0 : style.bold) || undefined;
        styles.font["italic"] = !!(style === null || style === void 0 ? void 0 : style.italic) || undefined;
        return styles;
    }
    function normalizeStyle(construct, styles) {
        const { id: fontId } = pushElement(styles["font"], construct.fonts);
        const { id: fillId } = pushElement(styles["fill"], construct.fills);
        const { id: borderId } = pushElement(styles["border"], construct.borders);
        // Normalize this
        const numFmtId = convertFormat(styles["numFmt"], construct.numFmts);
        const style = {
            fontId,
            fillId,
            borderId,
            numFmtId,
            verticalAlignment: styles["verticalAlignment"],
            horizontalAlignment: styles["horizontalAlignment"],
        };
        const { id } = pushElement(style, construct.styles);
        return id;
    }
    function convertFormat(format, numFmtStructure) {
        if (!format) {
            return 0;
        }
        let formatId = XLSX_FORMAT_MAP[format];
        if (!formatId) {
            const { id } = pushElement(format, numFmtStructure);
            formatId = id + FIRST_NUMFMT_ID;
        }
        return formatId;
    }
    /**
     * Add a relation to the given file and return its id.
     */
    function addRelsToFile(relsFiles, path, rel) {
        let relsFile = relsFiles.find((file) => file.path === path);
        // the id is a one-based int casted as string
        let id;
        if (!relsFile) {
            id = "rId1";
            relsFiles.push({ path, rels: [{ ...rel, id }] });
        }
        else {
            id = `rId${(relsFile.rels.length + 1).toString()}`;
            relsFile.rels.push({
                ...rel,
                id,
            });
        }
        return id;
    }
    function pushElement(property, propertyList) {
        for (let [key, value] of Object.entries(propertyList)) {
            if (JSON.stringify(value) === JSON.stringify(property)) {
                return { id: parseInt(key, 10), list: propertyList };
            }
        }
        let elemId = propertyList.findIndex((elem) => JSON.stringify(elem) === JSON.stringify(property));
        if (elemId === -1) {
            propertyList.push(property);
            elemId = propertyList.length - 1;
        }
        return {
            id: elemId,
            list: propertyList,
        };
    }
    const chartIds = [];
    /**
     * Convert a chart o-spreadsheet id to a xlsx id which
     * are unsigned integers (starting from 1).
     */
    function convertChartId(chartId) {
        const xlsxId = chartIds.findIndex((id) => id === chartId);
        if (xlsxId === -1) {
            chartIds.push(chartId);
            return chartIds.length;
        }
        return xlsxId + 1;
    }
    /**
     * Convert a value expressed in dot to EMU.
     * EMU = English Metrical Unit
     * There are 914400 EMU per inch.
     *
     * /!\ A value expressed in EMU cannot be fractional.
     * See https://docs.microsoft.com/en-us/windows/win32/vml/msdn-online-vml-units#other-units-of-measurement
     */
    function convertDotValueToEMU(value) {
        const DPI = 96;
        return Math.round((value * 914400) / DPI);
    }

    /**
     * Represent a raw XML string
     */
    class XMLString {
        /**
         * @param xmlString should be a well formed, properly escaped XML string
         */
        constructor(xmlString) {
            this.xmlString = xmlString;
        }
        toString() {
            return this.xmlString;
        }
    }

    // -------------------------------------
    //            XML HELPERS
    // -------------------------------------
    function createXMLFile(doc, path, contentType) {
        return {
            content: new XMLSerializer().serializeToString(doc),
            path,
            contentType,
        };
    }
    function xmlEscape(str) {
        return String(str)
            .replace(/\&/g, "&amp;")
            .replace(/\</g, "&lt;")
            .replace(/\>/g, "&gt;")
            .replace(/\"/g, "&quot;")
            .replace(/\'/g, "&apos;");
    }
    function formatAttributes(attrs) {
        return new XMLString(attrs.map(([key, val]) => `${key}="${xmlEscape(val)}"`).join(" "));
    }
    function parseXML(xmlString) {
        const document = new DOMParser().parseFromString(xmlString.toString(), "text/xml");
        const parserError = document.querySelector("parsererror");
        if (parserError) {
            const errorString = parserError.innerHTML;
            const lineNumber = parseInt(errorString.split(":")[0], 10);
            const xmlStringArray = xmlString.toString().trim().split("\n");
            const xmlPreview = xmlStringArray
                .slice(Math.max(lineNumber - 3, 0), Math.min(lineNumber + 2, xmlStringArray.length))
                .join("\n");
            throw new Error(`XML string could not be parsed: ${errorString}\n${xmlPreview}`);
        }
        return document;
    }
    function getDefaultXLSXStructure() {
        return {
            relsFiles: [],
            sharedStrings: [],
            // default Values that will always be part of the style sheet
            styles: [
                {
                    fontId: 0,
                    fillId: 0,
                    numFmtId: 0,
                    borderId: 0,
                    verticalAlignment: "center",
                },
            ],
            fonts: [
                {
                    size: DEFAULT_FONT_SIZE,
                    family: 2,
                    color: "000000",
                    name: "Calibri",
                },
            ],
            fills: [{ reservedAttribute: "none" }, { reservedAttribute: "gray125" }],
            borders: [{}],
            numFmts: [],
            dxfs: [],
        };
    }
    function createOverride(partName, contentType) {
        return escapeXml /*xml*/ `
    <Override ContentType="${contentType}" PartName="${partName}" />
  `;
    }
    function joinXmlNodes(xmlNodes) {
        return new XMLString(xmlNodes.join("\n"));
    }
    /**
     * Escape interpolated values except if the value is already
     * a properly escaped XML string.
     *
     * ```
     * escapeXml`<t>${"This will be escaped"}</t>`
     * ```
     */
    function escapeXml(strings, ...expressions) {
        let str = [strings[0]];
        for (let i = 0; i < expressions.length; i++) {
            const value = expressions[i] instanceof XMLString ? expressions[i] : xmlEscape(expressions[i]);
            str.push(value + strings[i + 1]);
        }
        return new XMLString(str.join(""));
    }

    /**
     * Each axis present inside a graph needs to be identified by an unsigned integer
     * The value does not matter, it can be hardcoded.
     */
    const catAxId = 17781237;
    const valAxId = 88853993;
    function createChart(chart) {
        const namespaces = [
            ["xmlns:r", RELATIONSHIP_NSR],
            ["xmlns:a", DRAWING_NS_A],
            ["xmlns:c", DRAWING_NS_C],
        ];
        const chartShapeProperty = shapeProperty({
            backgroundColor: toHex6(chart.data.backgroundColor),
            line: { color: "000000" },
        });
        // <manualLayout/> to manually position the chart in the figure container
        let title = escapeXml ``;
        if (chart.data.title) {
            title = escapeXml /*xml*/ `
      <c:title>
        ${insertText(chart.data.title)}
        <c:overlay val="0" />
      </c:title>
    `;
        }
        // switch on chart type
        let plot = escapeXml ``;
        switch (chart.data.type) {
            case "bar":
                plot = addBarChart(chart.data);
                break;
            case "line":
                plot = addLineChart(chart.data);
                break;
            case "pie":
                plot = addDoughnutChart(chart.data, { holeSize: 0 });
                break;
        }
        let position = "t";
        switch (chart.data.legendPosition) {
            case "bottom":
                position = "b";
                break;
            case "left":
                position = "l";
                break;
            case "right":
                position = "r";
                break;
            case "top":
                position = "t";
                break;
        }
        const xml = escapeXml /*xml*/ `
    <c:chartSpace ${formatAttributes(namespaces)}>
      <c:roundedCorners val="0" />
      <!-- <manualLayout/> to manually position the chart in the figure container -->
      ${chartShapeProperty}
      <c:chart>
        ${title}
        <c:autoTitleDeleted val="0" />
        <c:plotArea>
          <!-- how the chart element is placed on the chart -->
          <c:layout />
          ${plot}
          ${shapeProperty({ backgroundColor: toHex6(chart.data.backgroundColor) })}
        </c:plotArea>
        ${addLegend(position)}
      </c:chart>
    </c:chartSpace>
  `;
        return parseXML(xml);
    }
    function shapeProperty(params) {
        return escapeXml /*xml*/ `
    <c:spPr>
      ${params.backgroundColor ? solidFill(params.backgroundColor) : ""}
      ${params.line ? lineAttributes(params.line) : ""}
    </c:spPr>
  `;
    }
    function solidFill(color) {
        return escapeXml /*xml*/ `
    <a:solidFill>
      <a:srgbClr val="${color}"/>
    </a:solidFill>
  `;
    }
    function lineAttributes(params) {
        const attrs = [["cmpd", "sng"]];
        if (params.width) {
            attrs.push(["w", convertDotValueToEMU(params.width)]);
        }
        const lineStyle = params.style ? escapeXml /*xml*/ `<a:prstDash val="${params.style}"/>` : "";
        return escapeXml /*xml*/ `
    <a:ln ${formatAttributes(attrs)}>
      ${solidFill(params.color)}
      ${lineStyle}
    </a:ln>
  `;
    }
    function insertText(text, fontsize = 22) {
        return escapeXml /*xml*/ `
    <c:tx>
      <c:rich>
        <a:bodyPr />
        <a:lstStyle />
        <a:p>
          <a:pPr lvl="0">
            <a:defRPr b="0">
              ${solidFill("000000")}
              <a:latin typeface="+mn-lt"/>
            </a:defRPr>
          </a:pPr>
          <a:r> <!-- Runs -->
            <a:rPr sz="${fontsize * 100}"/>
            <a:t>${text}</a:t>
          </a:r>
        </a:p>
      </c:rich>
    </c:tx>
  `;
    }
    function insertTextProperties(fontsize = 12, bold = false, italic = false) {
        const defPropertiesAttributes = [
            ["b", bold ? "1" : "0"],
            ["i", italic ? "1" : "0"],
            ["sz", fontsize * 100],
        ];
        return escapeXml /*xml*/ `
    <c:txPr>
      <a:bodyPr/>
      <a:lstStyle/>
      <a:p>
        <a:pPr lvl="0">
          <a:defRPr ${formatAttributes(defPropertiesAttributes)}>
            ${solidFill("000000")}
            <a:latin typeface="+mn-lt"/>
          </a:defRPr>
        </a:pPr>
      </a:p>
    </c:txPr>
  `;
    }
    function addBarChart(chart) {
        // gapWitdh and overlap that define the space between clusters (in %) and the overlap between datasets (from -100: completely scattered to 100, completely overlapped)
        // see gapWidth : https://c-rex.net/projects/samples/ooxml/e1/Part4/OOXML_P4_DOCX_gapWidth_topic_ID0EFVEQB.html#topic_ID0EFVEQB
        // see overlap : https://c-rex.net/projects/samples/ooxml/e1/Part4/OOXML_P4_DOCX_overlap_topic_ID0ELYQQB.html#topic_ID0ELYQQB
        //
        // overlap and gapWitdh seems to be by default at -20 and 20 in chart.js.
        // See https://www.chartjs.org/docs/latest/charts/bar.html and https://www.chartjs.org/docs/latest/charts/bar.html#barpercentage-vs-categorypercentage
        const colors = new ChartColors();
        const dataSetsNodes = [];
        for (const [dsIndex, dataset] of Object.entries(chart.dataSets)) {
            const color = toHex6(colors.next());
            const dataShapeProperty = shapeProperty({
                backgroundColor: color,
                line: { color },
            });
            dataSetsNodes.push(escapeXml /*xml*/ `
      <c:ser>
        <c:idx val="${dsIndex}"/>
        <c:order val="${dsIndex}"/>
        ${dataset.label ? escapeXml /*xml*/ `<c:tx>${stringRef(dataset.label)}</c:tx>` : ""}
        ${dataShapeProperty}
        ${chart.labelRange ? escapeXml /*xml*/ `<c:cat>${stringRef(chart.labelRange)}</c:cat>` : ""} <!-- x-coordinate values -->
        <c:val> <!-- x-coordinate values -->
          ${numberRef(dataset.range)}
        </c:val>
      </c:ser>
    `);
        }
        // Excel does not support this feature
        const axisPos = chart.verticalAxisPosition === "left" ? "l" : "r";
        const grouping = chart.stackedBar ? "stacked" : "clustered";
        const overlap = chart.stackedBar ? 100 : -20;
        return escapeXml /*xml*/ `
    <c:barChart>
      <c:barDir val="col"/>
      <c:grouping val="${grouping}"/>
      <c:overlap val="${overlap}"/>
      <c:gapWidth val="70"/>
      <!-- each data marker in the series does not have a different color -->
      <c:varyColors val="0"/>
      ${joinXmlNodes(dataSetsNodes)}
      <c:axId val="${catAxId}" />
      <c:axId val="${valAxId}" />
    </c:barChart>
    ${addAx("b", "c:catAx", catAxId, valAxId)}
    ${addAx(axisPos, "c:valAx", valAxId, catAxId)}
  `;
    }
    function addLineChart(chart) {
        const colors = new ChartColors();
        const dataSetsNodes = [];
        for (const [dsIndex, dataset] of Object.entries(chart.dataSets)) {
            const dataShapeProperty = shapeProperty({
                line: {
                    width: 2.5,
                    style: "solid",
                    color: toHex6(colors.next()),
                },
            });
            dataSetsNodes.push(escapeXml /*xml*/ `
      <c:ser>
        <c:idx val="${dsIndex}"/>
        <c:order val="${dsIndex}"/>
        <c:smooth val="0"/>
        <c:marker>
          <c:symbol val="circle" />
          <c:size val="5"/>
        </c:marker>
        ${dataset.label ? escapeXml `<c:tx>${stringRef(dataset.label)}</c:tx>` : ""}
        ${dataShapeProperty}
        ${chart.labelRange ? escapeXml `<c:cat>${stringRef(chart.labelRange)}</c:cat>` : ""} <!-- x-coordinate values -->
        <c:val> <!-- x-coordinate values -->
          ${numberRef(dataset.range)}
        </c:val>
      </c:ser>
    `);
        }
        // Excel does not support this feature
        const axisPos = chart.verticalAxisPosition === "left" ? "l" : "r";
        return escapeXml /*xml*/ `
    <c:lineChart>
      <!-- each data marker in the series does not have a different color -->
      <c:varyColors val="0"/>
      ${joinXmlNodes(dataSetsNodes)}
      <c:axId val="${catAxId}" />
      <c:axId val="${valAxId}" />
    </c:lineChart>
    ${addAx("b", "c:catAx", catAxId, valAxId)}
    ${addAx(axisPos, "c:valAx", valAxId, catAxId)}
  `;
    }
    function addDoughnutChart(chart, { holeSize } = { holeSize: 50 }) {
        const colors = new ChartColors();
        const maxLength = Math.max(...chart.dataSets.map((ds) => {
            const zone = toZone(ds.range);
            const { height, width } = zoneToDimension(zone);
            return height * width;
        }));
        const doughnutColors = range(0, maxLength).map(() => toHex6(colors.next()));
        const dataSetsNodes = [];
        for (const [dsIndex, dataset] of Object.entries(chart.dataSets).reverse()) {
            //dataset slice labels
            const zone = toZone(dataset.range);
            const { height, width } = zoneToDimension(zone);
            const dataPoints = [];
            for (const index of range(0, height * width)) {
                const pointShapeProperty = shapeProperty({
                    backgroundColor: doughnutColors[index],
                    line: { color: "FFFFFF", width: 1.5 },
                });
                dataPoints.push(escapeXml /*xml*/ `
        <c:dPt>
          <c:idx val="${index}"/>
          ${pointShapeProperty}
        </c:dPt>
      `);
            }
            dataSetsNodes.push(escapeXml /*xml*/ `
      <c:ser>
        <c:idx val="${dsIndex}"/>
        <c:order val="${dsIndex}"/>
        ${dataset.label ? escapeXml `<c:tx>${stringRef(dataset.label)}</c:tx>` : ""}
        ${joinXmlNodes(dataPoints)}
        ${insertDataLabels({ showLeaderLines: true })}
        ${chart.labelRange ? escapeXml `<c:cat>${stringRef(chart.labelRange)}</c:cat>` : ""}
        <c:val>
          ${numberRef(dataset.range)}
        </c:val>
      </c:ser>
    `);
        }
        return escapeXml /*xml*/ `
    <c:doughnutChart>
      <c:varyColors val="1" />
      <c:holeSize val="${holeSize}" />
      ${insertDataLabels()}
      ${joinXmlNodes(dataSetsNodes)}
    </c:doughnutChart>
  `;
    }
    function insertDataLabels({ showLeaderLines } = { showLeaderLines: false }) {
        return escapeXml /*xml*/ `
    <dLbls>
      <c:showLegendKey val="0"/>
      <c:showVal val="0"/>
      <c:showCatName val="0"/>
      <c:showSerName val="0"/>
      <c:showPercent val="0"/>
      <c:showBubbleSize val="0"/>
      <c:showLeaderLines val="${showLeaderLines ? "1" : "0"}"/>
    </dLbls>
  `;
    }
    function addAx(position, axisName, axId, crossAxId) {
        // Each Axis present inside a graph needs to be identified by an unsigned integer in order to be referenced by its crossAxis.
        // I.e. x-axis, will reference y-axis and vice-versa.
        return escapeXml /*xml*/ `
    <${axisName}>
      <c:axId val="${axId}"/>
      <c:crossAx val="${crossAxId}"/> <!-- reference to the other axe of the chart -->
      <c:delete val="0"/> <!-- by default, axis are not displayed -->
      <c:scaling>
        <c:orientation  val="minMax" />
      </c:scaling>
      <c:axPos val="${position}" />
      ${insertMajorGridLines()}
      <c:majorTickMark val="out" />
      <c:minorTickMark val="none" />
      <c:numFmt formatCode="General" sourceLinked="1" />
      <c:title>
        ${insertText("")}
      </c:title>
      ${insertTextProperties(10)}
    </${axisName}>
    <!-- <tickLblPos/> omitted -->
  `;
    }
    function addLegend(position) {
        return escapeXml /*xml*/ `
    <c:legend>
      <c:legendPos val="${position}"/>
      <c:overlay val="0"/>
      ${insertTextProperties(10)}
    </c:legend>
  `;
    }
    function insertMajorGridLines(color = "B7B7B7") {
        return escapeXml /*xml*/ `
    <c:majorGridlines>
      ${shapeProperty({ line: { color } })}
    </c:majorGridlines>
  `;
    }
    function stringRef(reference) {
        return escapeXml /*xml*/ `
    <c:strRef>
      <c:f>${reference}</c:f>
    </c:strRef>
  `;
    }
    function numberRef(reference) {
        return escapeXml /*xml*/ `
    <c:numRef>
      <c:f>${reference}</c:f>
      <c:numCache />
    </c:numRef>
  `;
    }

    function addFormula(cell) {
        const formula = cell.content;
        const functions = functionRegistry.content;
        const tokens = tokenize(formula);
        const attrs = [];
        let node = escapeXml ``;
        const isExported = tokens
            .filter((tk) => tk.type === "FUNCTION")
            .every((tk) => functions[tk.value.toUpperCase()].isExported);
        if (isExported) {
            let cycle = escapeXml ``;
            const XlsxFormula = adaptFormulaToExcel(formula);
            // hack for cycles : if we don't set a value (be it 0 or #VALUE!), it will appear as invisible on excel,
            // Making it very hard for the client to find where the recursion is.
            if (cell.value === "#CYCLE") {
                attrs.push(["t", "str"]);
                cycle = escapeXml /*xml*/ `<v>${cell.value}</v>`;
            }
            node = escapeXml /*xml*/ `
      <f>
        ${XlsxFormula}
      </f>
      ${cycle}
    `;
            return { attrs, node };
        }
        else {
            // Shouldn't we always output the value then ?
            const value = cell.value;
            // what if value = 0? Is this condition correct?
            if (value) {
                const type = getCellType(value);
                attrs.push(["t", type]);
                node = escapeXml /*xml*/ `<v>${value}</v>`;
            }
            return { attrs, node };
        }
    }
    function addContent(content, sharedStrings) {
        let value = content;
        const attrs = [];
        if (["TRUE", "FALSE"].includes(value.trim())) {
            value = value === "TRUE" ? "1" : "0";
            attrs.push(["t", "b"]);
        }
        else if (!isNumber(value)) {
            const { id } = pushElement(content, sharedStrings);
            value = id.toString();
            attrs.push(["t", "s"]);
        }
        return { attrs, node: escapeXml /*xml*/ `<v>${value}</v>` };
    }
    function adaptFormulaToExcel(formulaText) {
        if (formulaText[0] === "=") {
            formulaText = formulaText.slice(1);
        }
        let ast;
        try {
            ast = parse(formulaText);
        }
        catch (error) {
            return formulaText;
        }
        ast = convertAstNodes(ast, "STRING", convertDateFormat);
        ast = convertAstNodes(ast, "FUNCALL", (ast) => {
            ast = { ...ast, value: ast.value.toUpperCase() };
            ast = prependNonRetrocompatibleFunction(ast);
            ast = addMissingRequiredArgs(ast);
            return ast;
        });
        return ast ? astToFormula(ast) : formulaText;
    }
    /**
     * Some Excel function need required args that might not be mandatory in o-spreadsheet.
     * This adds those missing args.
     */
    function addMissingRequiredArgs(ast) {
        const formulaName = ast.value.toUpperCase();
        const args = ast.args;
        const exportDefaultArgs = FORCE_DEFAULT_ARGS_FUNCTIONS[formulaName];
        if (exportDefaultArgs) {
            const requiredArgs = functionRegistry.content[formulaName].args.filter((el) => !el.optional);
            const diffArgs = requiredArgs.length - ast.args.length;
            if (diffArgs) {
                // We know that we have at least 1 default Value missing
                for (let i = ast.args.length; i < requiredArgs.length; i++) {
                    const currentDefaultArg = exportDefaultArgs[i - diffArgs];
                    args.push({ type: currentDefaultArg.type, value: currentDefaultArg.value });
                }
            }
        }
        return { ...ast, args };
    }
    /**
     * Prepend function names that are not compatible with Old Excel versions
     */
    function prependNonRetrocompatibleFunction(ast) {
        const formulaName = ast.value.toUpperCase();
        return {
            ...ast,
            value: NON_RETROCOMPATIBLE_FUNCTIONS.includes(formulaName)
                ? `_xlfn.${formulaName}`
                : formulaName,
        };
    }
    /**
     * Convert strings that correspond to a date to the format YYYY-DD-MM
     */
    function convertDateFormat(ast) {
        const value = ast.value.replace(new RegExp('"', "g"), "");
        const internalDate = parseDateTime(value);
        if (internalDate) {
            let format = [];
            if (value.match(mdyDateRegexp) || value.match(ymdDateRegexp)) {
                format.push("yyyy-mm-dd");
            }
            if (value.match(timeRegexp)) {
                format.push("hh:mm:ss");
            }
            return {
                ...ast,
                value: `"${formatDateTime({ value: internalDate.value, format: format.join(" ") })}"`,
            };
        }
        else {
            return { ...ast, value: ast.value.replace(/\\"/g, `""`) };
        }
    }

    function addConditionalFormatting(dxfs, conditionalFormats) {
        // Conditional Formats
        const cfNodes = [];
        for (const cf of conditionalFormats) {
            // Special case for each type of rule: might be better to extract that logic in dedicated functions
            switch (cf.rule.type) {
                case "CellIsRule":
                    cfNodes.push(addCellIsRule(cf, cf.rule, dxfs));
                    break;
                case "ColorScaleRule":
                    cfNodes.push(addColorScaleRule(cf, cf.rule));
                    break;
                case "IconSetRule":
                    cfNodes.push(addIconSetRule(cf, cf.rule));
                    break;
                default:
                    // @ts-ignore Typescript knows it will never happen at compile time
                    console.warn(`Conditional formatting ${cf.rule.type} not implemented`);
                    break;
            }
        }
        return cfNodes;
    }
    // ----------------------
    //         RULES
    // ----------------------
    function addCellIsRule(cf, rule, dxfs) {
        const ruleAttributes = commonCfAttributes(cf);
        const operator = convertOperator(rule.operator);
        ruleAttributes.push(...cellRuleTypeAttributes(rule), ["operator", operator]);
        const formulas = cellRuleFormula(cf.ranges, rule).map((formula) => escapeXml /*xml*/ `<formula>${formula}</formula>`);
        const dxf = {
            font: {
                color: rule.style.textColor,
                bold: rule.style.bold,
                italic: rule.style.italic,
                strike: rule.style.strikethrough,
                underline: rule.style.underline,
            },
        };
        if (rule.style.fillColor) {
            dxf.fill = { fgColor: rule.style.fillColor };
        }
        const { id } = pushElement(dxf, dxfs);
        ruleAttributes.push(["dxfId", id]);
        return escapeXml /*xml*/ `
    <conditionalFormatting sqref="${cf.ranges.join(" ")}">
      <cfRule ${formatAttributes(ruleAttributes)}>
        ${joinXmlNodes(formulas)}
      </cfRule>
    </conditionalFormatting>
  `;
    }
    function cellRuleFormula(ranges, rule) {
        const firstCell = ranges[0].split(":")[0];
        const values = rule.values;
        switch (rule.operator) {
            case "ContainsText":
                return [`NOT(ISERROR(SEARCH("${values[0]}",${firstCell})))`];
            case "NotContains":
                return [`ISERROR(SEARCH("${values[0]}",${firstCell}))`];
            case "BeginsWith":
                return [`LEFT(${firstCell},LEN("${values[0]}"))="${values[0]}"`];
            case "EndsWith":
                return [`RIGHT(${firstCell},LEN("${values[0]}"))="${values[0]}"`];
            case "IsEmpty":
                return [`LEN(TRIM(${firstCell}))=0`];
            case "IsNotEmpty":
                return [`LEN(TRIM(${firstCell}))>0`];
            case "Equal":
            case "NotEqual":
            case "GreaterThan":
            case "GreaterThanOrEqual":
            case "LessThan":
            case "LessThanOrEqual":
                return [values[0]];
            case "Between":
            case "NotBetween":
                return [values[0], values[1]];
        }
    }
    function cellRuleTypeAttributes(rule) {
        const operator = convertOperator(rule.operator);
        switch (rule.operator) {
            case "ContainsText":
            case "NotContains":
            case "BeginsWith":
            case "EndsWith":
                return [
                    ["type", operator],
                    ["text", rule.values[0]],
                ];
            case "IsEmpty":
            case "IsNotEmpty":
                return [["type", operator]];
            case "Equal":
            case "NotEqual":
            case "GreaterThan":
            case "GreaterThanOrEqual":
            case "LessThan":
            case "LessThanOrEqual":
            case "Between":
            case "NotBetween":
                return [["type", "cellIs"]];
        }
    }
    function addColorScaleRule(cf, rule) {
        const ruleAttributes = commonCfAttributes(cf);
        ruleAttributes.push(["type", "colorScale"]);
        /** mimic our flow:
         * for a given ColorScale CF, each range of the "ranges set" has its own behaviour.
         */
        const conditionalFormats = [];
        for (const range of cf.ranges) {
            const cfValueObject = [];
            const colors = [];
            let canExport = true;
            for (let position of ["minimum", "midpoint", "maximum"]) {
                const threshold = rule[position];
                if (!threshold) {
                    // pass midpoint if not defined
                    continue;
                }
                if (threshold.type === "formula") {
                    canExport = false;
                    continue;
                }
                cfValueObject.push(thresholdAttributes(threshold, position));
                colors.push([["rgb", colorNumberString(threshold.color)]]);
            }
            if (!canExport) {
                console.warn("Conditional formats with formula rules are not supported at the moment. The rule is therefore skipped.");
                continue;
            }
            const cfValueObjectNodes = cfValueObject.map((attrs) => escapeXml /*xml*/ `<cfvo ${formatAttributes(attrs)}/>`);
            const cfColorNodes = colors.map((attrs) => escapeXml /*xml*/ `<color ${formatAttributes(attrs)}/>`);
            conditionalFormats.push(escapeXml /*xml*/ `
      <conditionalFormatting sqref="${range}">
        <cfRule ${formatAttributes(ruleAttributes)}>
          <colorScale>
            ${joinXmlNodes(cfValueObjectNodes)}
            ${joinXmlNodes(cfColorNodes)}
          </colorScale>
        </cfRule>
      </conditionalFormatting>
    `);
        }
        return joinXmlNodes(conditionalFormats);
    }
    function addIconSetRule(cf, rule) {
        const ruleAttributes = commonCfAttributes(cf);
        ruleAttributes.push(["type", "iconSet"]);
        /** mimic our flow:
         * for a given IconSet CF, each range of the "ranges set" has its own behaviour.
         */
        const conditionalFormats = [];
        for (const range of cf.ranges) {
            const cfValueObject = [
                // It looks like they always want 3 cfvo and they add a dummy entry
                [
                    ["type", "percent"],
                    ["val", 0],
                ],
            ];
            let canExport = true;
            for (let position of ["lowerInflectionPoint", "upperInflectionPoint"]) {
                if (rule[position].type === "formula") {
                    canExport = false;
                    continue;
                }
                const threshold = rule[position];
                cfValueObject.push([
                    ...thresholdAttributes(threshold, position),
                    ["gte", threshold.operator === "ge" ? "1" : "0"],
                ]);
            }
            if (!canExport) {
                console.warn("Conditional formats with formula rules are not supported at the moment. The rule is therefore skipped.");
                continue;
            }
            const cfValueObjectNodes = cfValueObject.map((attrs) => escapeXml /*xml*/ `<cfvo ${formatAttributes(attrs)} />`);
            conditionalFormats.push(escapeXml /*xml*/ `
      <conditionalFormatting sqref="${range}">
        <cfRule ${formatAttributes(ruleAttributes)}>
          <iconSet iconSet="${getIconSet(rule.icons)}">
            ${joinXmlNodes(cfValueObjectNodes)}
          </iconSet>
        </cfRule>
      </conditionalFormatting>
    `);
        }
        return joinXmlNodes(conditionalFormats);
    }
    // ----------------------
    //         MISC
    // ----------------------
    function commonCfAttributes(cf) {
        return [
            ["priority", 1],
            ["stopIfTrue", cf.stopIfTrue ? 1 : 0],
        ];
    }
    function getIconSet(iconSet) {
        return XLSX_ICONSET_MAP[Object.keys(XLSX_ICONSET_MAP).find((key) => iconSet.upper.toLowerCase().startsWith(key)) ||
            "dots"];
    }
    function thresholdAttributes(threshold, position) {
        const type = getExcelThresholdType(threshold.type, position);
        const attrs = [["type", type]];
        if (type !== "min" && type !== "max") {
            // what if the formula is not correct
            // references cannot be relative :/
            let val = threshold.value;
            if (type === "formula") {
                try {
                    checkRelativeReferences(threshold.value);
                    val = adaptFormulaToExcel(threshold.value);
                }
                catch (error) {
                    val = threshold.value;
                }
            }
            attrs.push(["val", val]); // value is undefined only for type="value")
        }
        return attrs;
    }
    /**
     * This function adapts our Threshold types to their Excel equivalents.
     *
     * if type === "value" ,then we must replace it by min or max according to the position
     * if type === "number", then it becomes num
     * if type === "percentage", it becomes "percent"
     * rest of the time, the type is unchanged
     */
    function getExcelThresholdType(type, position) {
        switch (type) {
            case "value":
                return position === "minimum" ? "min" : "max";
            case "number":
                return "num";
            case "percentage":
                return "percent";
            default:
                return type;
        }
    }
    /**
     * Relative references are not supported in formula
     */
    function checkRelativeReferences(formula) {
        const { dependencies } = normalize(formula);
        if (dependencies.references.length) {
            console.warn("Relative references might not work in conditional format formula thresholds in Excel.");
        }
    }

    function createDrawing(chartRelIds, sheet, figures) {
        const namespaces = [
            ["xmlns:xdr", NAMESPACE.drawing],
            ["xmlns:r", RELATIONSHIP_NSR],
            ["xmlns:a", DRAWING_NS_A],
            ["xmlns:c", DRAWING_NS_C],
        ];
        const figuresNodes = [];
        for (const [figureIndex, figure] of Object.entries(figures)) {
            // position
            const { from, to } = convertFigureData(figure, sheet);
            const chartId = convertChartId(figure.id);
            const cNvPrAttrs = [
                ["id", chartId],
                ["name", `Chart ${chartId}`],
                ["title", "Chart"],
            ];
            figuresNodes.push(escapeXml /*xml*/ `
      <xdr:twoCellAnchor>
        <xdr:from>
          <xdr:col>${from.col}</xdr:col>
          <xdr:colOff>${from.colOff}</xdr:colOff>
          <xdr:row>${from.row}</xdr:row>
          <xdr:rowOff>${from.rowOff}</xdr:rowOff>
        </xdr:from>
        <xdr:to>
          <xdr:col>${to.col}</xdr:col>
          <xdr:colOff>${to.colOff}</xdr:colOff>
          <xdr:row>${to.row}</xdr:row>
          <xdr:rowOff>${to.rowOff}</xdr:rowOff>
        </xdr:to>
        <xdr:graphicFrame>
          <xdr:nvGraphicFramePr>
            <xdr:cNvPr ${formatAttributes(cNvPrAttrs)} />
            <xdr:cNvGraphicFramePr />
          </xdr:nvGraphicFramePr>
          <xdr:xfrm>
            <a:off x="0" y="0"/>
            <a:ext cx="0" cy="0"/>
          </xdr:xfrm>
          <a:graphic>
            <a:graphicData uri="${DRAWING_NS_C}">
              <c:chart r:id="${chartRelIds[figureIndex]}" />
            </a:graphicData>
          </a:graphic>
        </xdr:graphicFrame>
        <xdr:clientData fLocksWithSheet="0"/>
      </xdr:twoCellAnchor>
    `);
        }
        const xml = escapeXml /*xml*/ `
    <xdr:wsDr ${formatAttributes(namespaces)}>
      ${joinXmlNodes(figuresNodes)}
    </xdr:wsDr>
  `;
        return parseXML(xml);
    }
    /**
     *  Returns the coordinates of topLeft (from) and BottomRight (to) of the chart in English Metric Units (EMU)
     */
    function convertFigureData(figure, sheet) {
        const { x, y, height, width } = figure;
        const cols = Object.values(sheet.cols);
        const rows = Object.values(sheet.rows);
        const { index: colFrom, offset: offsetColFrom } = figureCoordinates(cols, x);
        const { index: colTo, offset: offsetColTo } = figureCoordinates(cols, x + width);
        const { index: rowFrom, offset: offsetRowFrom } = figureCoordinates(rows, y);
        const { index: rowTo, offset: offsetRowTo } = figureCoordinates(rows, y + height);
        return {
            from: {
                col: colFrom,
                colOff: offsetColFrom,
                row: rowFrom,
                rowOff: offsetRowFrom,
            },
            to: {
                col: colTo,
                colOff: offsetColTo,
                row: rowTo,
                rowOff: offsetRowTo,
            },
        };
    }
    /** Returns figure coordinates in EMU for a specific header dimension
     *  See https://docs.microsoft.com/en-us/windows/win32/vml/msdn-online-vml-units#other-units-of-measurement
     */
    function figureCoordinates(headers, position) {
        let currentPosition = 0;
        for (const [headerIndex, header] of Object.entries(headers)) {
            if (currentPosition <= position && position < currentPosition + header.size) {
                return {
                    index: parseInt(headerIndex),
                    offset: convertDotValueToEMU(position - currentPosition + FIGURE_BORDER_SIZE),
                };
            }
            else {
                currentPosition += header.size;
            }
        }
        return {
            index: headers.length - 1,
            offset: convertDotValueToEMU(position - currentPosition + FIGURE_BORDER_SIZE),
        };
    }

    function addNumberFormats(numFmts) {
        const numFmtNodes = [];
        for (let [index, numFmt] of Object.entries(numFmts)) {
            const numFmtAttrs = [
                ["numFmtId", parseInt(index) + FIRST_NUMFMT_ID],
                ["formatCode", numFmt],
            ];
            numFmtNodes.push(escapeXml /*xml*/ `
      <numFmt ${formatAttributes(numFmtAttrs)}/>
    `);
        }
        return escapeXml /*xml*/ `
    <numFmts count="${numFmts.length}">
      ${joinXmlNodes(numFmtNodes)}
    </numFmts>
  `;
    }
    function addFont(font) {
        if (Object.values(font).filter(isDefined).length === 0) {
            return escapeXml /*xml*/ ``;
        }
        return escapeXml /*xml*/ `
    <font>
      ${font.bold ? escapeXml /*xml*/ `<b />` : ""}
      ${font.italic ? escapeXml /*xml*/ `<i />` : ""}
      ${font.underline ? escapeXml /*xml*/ `<u />` : ""}
      ${font.strike ? escapeXml /*xml*/ `<strike />` : ""}
      ${font.size ? escapeXml /*xml*/ `<sz val="${font.size}" />` : ""}
      ${font.color ? escapeXml /*xml*/ `<color rgb="${toHex6(font.color)}" />` : ""}
      ${font.name ? escapeXml /*xml*/ `<name val="${font.name}" />` : ""}
    </font>
  `;
    }
    function addFonts(fonts) {
        return escapeXml /*xml*/ `
    <fonts count="${fonts.length}">
      ${joinXmlNodes(Object.values(fonts).map(addFont))}
    </fonts>
  `;
    }
    function addFills(fills) {
        const fillNodes = [];
        for (let fill of Object.values(fills)) {
            if (fill.reservedAttribute !== undefined) {
                fillNodes.push(escapeXml /*xml*/ `
        <fill>
          <patternFill patternType="${fill.reservedAttribute}" />
        </fill>
      `);
            }
            else {
                fillNodes.push(escapeXml /*xml*/ `
        <fill>
          <patternFill patternType="solid">
            <fgColor rgb="${toHex6(fill.fgColor)}" />
            <bgColor indexed="64" />
          </patternFill>
        </fill>
      `);
            }
        }
        return escapeXml /*xml*/ `
    <fills count="${fills.length}">
    ${joinXmlNodes(fillNodes)}
    </fills>
  `;
    }
    function addBorders(borders) {
        const borderNodes = [];
        for (let border of Object.values(borders)) {
            borderNodes.push(escapeXml /*xml*/ `
      <border>
        <left ${formatBorderAttribute(border["left"])} />
        <right ${formatBorderAttribute(border["right"])} />
        <top ${formatBorderAttribute(border["top"])} />
        <bottom ${formatBorderAttribute(border["bottom"])} />
        <diagonal ${formatBorderAttribute(border["diagonal"])} />
      </border>
    `);
        }
        return escapeXml /*xml*/ `
    <borders count="${borders.length}">
      ${joinXmlNodes(borderNodes)}
    </borders>
  `;
    }
    function formatBorderAttribute(description) {
        if (!description) {
            return escapeXml ``;
        }
        return formatAttributes([
            ["style", description[0]],
            ["color", toHex6(description[1])],
        ]);
    }
    function addStyles(styles) {
        const styleNodes = [];
        for (let style of styles) {
            const attributes = [
                ["numFmtId", style.numFmtId],
                ["fillId", style.fillId],
                ["fontId", style.fontId],
                ["borderId", style.borderId],
            ];
            // Note: the apply${substyleName} does not seem to be required
            const alignAttrs = [];
            if (style.verticalAlignment) {
                alignAttrs.push(["vertical", style.verticalAlignment]);
            }
            if (style.horizontalAlignment) {
                alignAttrs.push(["horizontal", style.horizontalAlignment]);
            }
            styleNodes.push(escapeXml /*xml*/ `
      <xf ${formatAttributes(attributes)}>
        ${alignAttrs ? escapeXml /*xml*/ `<alignment ${formatAttributes(alignAttrs)} />` : ""}
      </xf>
    `);
        }
        return escapeXml /*xml*/ `
    <cellXfs count="${styles.length}">
      ${joinXmlNodes(styleNodes)}
    </cellXfs>
  `;
    }
    /**
     * DXFS : Differential Formatting Records - Conditional formats
     */
    function addCellWiseConditionalFormatting(dxfs // cell-wise CF
    ) {
        const dxfNodes = [];
        for (const dxf of dxfs) {
            let fontNode = escapeXml ``;
            if (dxf.font) {
                fontNode = addFont(dxf.font);
            }
            let fillNode = escapeXml ``;
            if (dxf.fill) {
                fillNode = escapeXml /*xml*/ `
        <fill>
          <patternFill>
            <bgColor rgb="${toHex6(dxf.fill.fgColor)}" />
          </patternFill>
        </fill>
      `;
            }
            dxfNodes.push(escapeXml /*xml*/ `
      <dxf>
        ${fontNode}
        ${fillNode}
      </dxf>
    `);
        }
        return escapeXml /*xml*/ `
    <dxfs count="${dxfs.length}">
      ${joinXmlNodes(dxfNodes)}
    </dxfs>
  `;
    }

    function addColumns(cols) {
        if (!Object.values(cols).length) {
            return escapeXml ``;
        }
        const colNodes = [];
        for (let [id, col] of Object.entries(cols)) {
            // Always force our own col width
            const attributes = [
                ["min", parseInt(id) + 1],
                ["max", parseInt(id) + 1],
                ["width", convertWidth(col.size || DEFAULT_CELL_WIDTH)],
                ["customWidth", 1],
                ["hidden", col.isHidden ? 1 : 0],
            ];
            colNodes.push(escapeXml /*xml*/ `
      <col ${formatAttributes(attributes)}/>
    `);
        }
        return escapeXml /*xml*/ `
    <cols>
      ${joinXmlNodes(colNodes)}
    </cols>
  `;
    }
    function addRows(construct, data, sheet) {
        const rowNodes = [];
        for (let r = 0; r < sheet.rowNumber; r++) {
            const rowAttrs = [["r", r + 1]];
            const row = sheet.rows[r] || {};
            // Always force our own row height
            rowAttrs.push(["ht", convertHeight(row.size || DEFAULT_CELL_HEIGHT)], ["customHeight", 1], ["hidden", row.isHidden ? 1 : 0]);
            const cellNodes = [];
            for (let c = 0; c < sheet.colNumber; c++) {
                const xc = toXC(c, r);
                const cell = sheet.cells[xc];
                if (cell) {
                    const attributes = [["r", xc]];
                    // style
                    const id = normalizeStyle(construct, extractStyle(cell, data));
                    attributes.push(["s", id]);
                    let additionalAttrs = [];
                    let cellNode = escapeXml ``;
                    // Either formula or static value inside the cell
                    if (cell.isFormula) {
                        ({ attrs: additionalAttrs, node: cellNode } = addFormula(cell));
                    }
                    else if (cell.content && isMarkdownLink(cell.content)) {
                        const { label } = parseMarkdownLink(cell.content);
                        ({ attrs: additionalAttrs, node: cellNode } = addContent(label, construct.sharedStrings));
                    }
                    else if (cell.content && cell.content !== "") {
                        ({ attrs: additionalAttrs, node: cellNode } = addContent(cell.content, construct.sharedStrings));
                    }
                    attributes.push(...additionalAttrs);
                    cellNodes.push(escapeXml /*xml*/ `
          <c ${formatAttributes(attributes)}>
            ${cellNode}
          </c>
        `);
                }
            }
            if (cellNodes.length) {
                rowNodes.push(escapeXml /*xml*/ `
        <row ${formatAttributes(rowAttrs)}>
          ${joinXmlNodes(cellNodes)}
        </row>
      `);
            }
        }
        return escapeXml /*xml*/ `
    <sheetData>
      ${joinXmlNodes(rowNodes)}
    </sheetData>
  `;
    }
    function addHyperlinks(construct, data, sheetIndex) {
        var _a;
        const sheet = data.sheets[sheetIndex];
        const cells = sheet.cells;
        const linkNodes = [];
        for (const xc in cells) {
            const content = (_a = cells[xc]) === null || _a === void 0 ? void 0 : _a.content;
            if (content && isMarkdownLink(content)) {
                const { label, url } = parseMarkdownLink(content);
                if (isMarkdownSheetLink(content)) {
                    const sheetId = parseSheetLink(url);
                    const sheet = data.sheets.find((sheet) => sheet.id === sheetId);
                    const location = sheet ? `${sheet.name}!A1` : INCORRECT_RANGE_STRING;
                    linkNodes.push(escapeXml /*xml*/ `
          <hyperlink display="${label}" location="${location}" ref="${xc}"/>
        `);
                }
                else {
                    const linkRelId = addRelsToFile(construct.relsFiles, `xl/worksheets/_rels/sheet${sheetIndex}.xml.rels`, {
                        target: url,
                        type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
                        targetMode: "External",
                    });
                    linkNodes.push(escapeXml /*xml*/ `
          <hyperlink r:id="${linkRelId}" ref="${xc}"/>
        `);
                }
            }
        }
        if (!linkNodes.length) {
            return escapeXml ``;
        }
        return escapeXml /*xml*/ `
    <hyperlinks>
      ${joinXmlNodes(linkNodes)}
    </hyperlinks>
  `;
    }
    function addMerges(merges) {
        if (merges.length) {
            const mergeNodes = merges.map((merge) => escapeXml /*xml*/ `<mergeCell ref="${merge}" />`);
            return escapeXml /*xml*/ `
      <mergeCells count="${merges.length}">
        ${joinXmlNodes(mergeNodes)}
      </mergeCells>
    `;
        }
        else
            return escapeXml ``;
    }

    /**
     * Return the spreadsheet data in the Office Open XML file format.
     * See ECMA-376 standard.
     * https://www.ecma-international.org/publications-and-standards/standards/ecma-376/
     */
    function getXLSX(data) {
        const files = [];
        const construct = getDefaultXLSXStructure();
        files.push(createWorkbook(data, construct));
        files.push(...createWorksheets(data, construct));
        files.push(createStylesSheet(construct));
        files.push(createSharedStrings(construct.sharedStrings));
        files.push(...createRelsFiles(construct.relsFiles));
        files.push(createContentTypes(files));
        files.push(createRelRoot());
        return {
            name: `my_spreadsheet.xlsx`,
            files,
        };
    }
    function createWorkbook(data, construct) {
        const namespaces = [
            ["xmlns", NAMESPACE["workbook"]],
            ["xmlns:r", RELATIONSHIP_NSR],
        ];
        const sheetNodes = [];
        for (const [index, sheet] of Object.entries(data.sheets)) {
            const attributes = [
                ["name", sheet.name],
                ["sheetId", parseInt(index) + 1],
                ["r:id", `rId${parseInt(index) + 1}`],
            ];
            sheetNodes.push(escapeXml /*xml*/ `
      <sheet ${formatAttributes(attributes)} />
    `);
            addRelsToFile(construct.relsFiles, "xl/_rels/workbook.xml.rels", {
                type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
                target: `worksheets/sheet${index}.xml`,
            });
        }
        const xml = escapeXml /*xml*/ `
    <workbook ${formatAttributes(namespaces)}>
      <sheets>
        ${joinXmlNodes(sheetNodes)}
      </sheets>
    </workbook>
  `;
        return createXMLFile(parseXML(xml), "xl/workbook.xml", "workbook");
    }
    function createWorksheets(data, construct) {
        const files = [];
        for (const [sheetIndex, sheet] of Object.entries(data.sheets)) {
            const namespaces = [
                ["xmlns", NAMESPACE["worksheet"]],
                ["xmlns:r", RELATIONSHIP_NSR],
            ];
            const sheetFormatAttributes = [
                ["defaultRowHeight", convertHeight(DEFAULT_CELL_HEIGHT)],
                ["defaultColWidth", convertWidth(DEFAULT_CELL_WIDTH)],
            ];
            // Figures and Charts
            let drawingNode = escapeXml ``;
            const charts = sheet.charts;
            if (charts.length) {
                const chartRelIds = [];
                for (const chart of charts) {
                    const xlsxChartId = convertChartId(chart.id);
                    const chartRelId = addRelsToFile(construct.relsFiles, `xl/drawings/_rels/drawing${sheetIndex}.xml.rels`, {
                        target: `../charts/chart${xlsxChartId}.xml`,
                        type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
                    });
                    chartRelIds.push(chartRelId);
                    files.push(createXMLFile(createChart(chart), `xl/charts/chart${xlsxChartId}.xml`, "chart"));
                }
                const drawingRelId = addRelsToFile(construct.relsFiles, `xl/worksheets/_rels/sheet${sheetIndex}.xml.rels`, {
                    target: `../drawings/drawing${sheetIndex}.xml`,
                    type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
                });
                files.push(createXMLFile(createDrawing(chartRelIds, sheet, charts), `xl/drawings/drawing${sheetIndex}.xml`, "drawing"));
                drawingNode = escapeXml /*xml*/ `<drawing r:id="${drawingRelId}" />`;
            }
            const sheetXml = escapeXml /*xml*/ `
      <worksheet ${formatAttributes(namespaces)}>
        <sheetFormatPr ${formatAttributes(sheetFormatAttributes)} />
        ${addColumns(sheet.cols)}
        ${addRows(construct, data, sheet)}
        ${addMerges(sheet.merges)}
        ${joinXmlNodes(addConditionalFormatting(construct.dxfs, sheet.conditionalFormats))}
        ${addHyperlinks(construct, data, sheetIndex)}
        ${drawingNode}
      </worksheet>
    `;
            files.push(createXMLFile(parseXML(sheetXml), `xl/worksheets/sheet${sheetIndex}.xml`, "sheet"));
        }
        addRelsToFile(construct.relsFiles, "xl/_rels/workbook.xml.rels", {
            type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
            target: "sharedStrings.xml",
        });
        addRelsToFile(construct.relsFiles, "xl/_rels/workbook.xml.rels", {
            type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
            target: "styles.xml",
        });
        return files;
    }
    function createStylesSheet(construct) {
        const namespaces = [
            ["xmlns", NAMESPACE["styleSheet"]],
            ["xmlns:r", RELATIONSHIP_NSR],
        ];
        const styleXml = escapeXml /*xml*/ `
    <styleSheet ${formatAttributes(namespaces)}>
      ${addNumberFormats(construct.numFmts)}
      ${addFonts(construct.fonts)}
      ${addFills(construct.fills)}
      ${addBorders(construct.borders)}
      ${addStyles(construct.styles)}
      ${addCellWiseConditionalFormatting(construct.dxfs)}
    </styleSheet>
  `;
        return createXMLFile(parseXML(styleXml), "xl/styles.xml", "styles");
    }
    function createSharedStrings(strings) {
        const namespaces = [
            ["xmlns", NAMESPACE["sst"]],
            ["count", strings.length],
            ["uniqueCount", strings.length],
        ];
        const stringNodes = strings.map((string) => escapeXml /*xml*/ `<si><t>${string}</t></si>`);
        const xml = escapeXml /*xml*/ `
    <sst ${formatAttributes(namespaces)}>
      ${joinXmlNodes(stringNodes)}
    </sst>
  `;
        return createXMLFile(parseXML(xml), "xl/sharedStrings.xml", "sharedStrings");
    }
    function createRelsFiles(relsFiles) {
        const XMLRelsFiles = [];
        for (const relFile of relsFiles) {
            const relationNodes = [];
            for (const rel of relFile.rels) {
                const attributes = [
                    ["Id", rel.id],
                    ["Target", rel.target],
                    ["Type", rel.type],
                ];
                if (rel.targetMode) {
                    attributes.push(["TargetMode", rel.targetMode]);
                }
                relationNodes.push(escapeXml /*xml*/ `
        <Relationship ${formatAttributes(attributes)} />
      `);
            }
            const xml = escapeXml /*xml*/ `
      <Relationships xmlns="${NAMESPACE["Relationships"]}">
        ${joinXmlNodes(relationNodes)}
      </Relationships>
    `;
            XMLRelsFiles.push(createXMLFile(parseXML(xml), relFile.path));
        }
        return XMLRelsFiles;
    }
    function createContentTypes(files) {
        const overrideNodes = [];
        for (const file of files) {
            if (file.contentType) {
                overrideNodes.push(createOverride("/" + file.path, CONTENT_TYPES[file.contentType]));
            }
        }
        const xml = escapeXml /*xml*/ `
    <Types xmlns="${NAMESPACE["Types"]}">
      <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
      <Default Extension="xml" ContentType="application/xml" />
      ${joinXmlNodes(overrideNodes)}
    </Types>
  `;
        return createXMLFile(parseXML(xml), "[Content_Types].xml");
    }
    function createRelRoot() {
        const attributes = [
            ["Id", "rId1"],
            ["Type", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument"],
            ["Target", "xl/workbook.xml"],
        ];
        const xml = escapeXml /*xml*/ `
    <Relationships xmlns="${NAMESPACE["Relationships"]}">
      <Relationship ${formatAttributes(attributes)} />
    </Relationships>
  `;
        return createXMLFile(parseXML(xml), "_rels/.rels");
    }

    var Status;
    (function (Status) {
        Status[Status["Ready"] = 0] = "Ready";
        Status[Status["Running"] = 1] = "Running";
        Status[Status["RunningCore"] = 2] = "RunningCore";
        Status[Status["Finalizing"] = 3] = "Finalizing";
        Status[Status["Interactive"] = 4] = "Interactive";
    })(Status || (Status = {}));
    class Model extends owl__namespace.core.EventBus {
        constructor(data = {}, config = {}, stateUpdateMessages = [], uuidGenerator = new UuidGenerator()) {
            super();
            this.corePlugins = [];
            this.uiPlugins = [];
            this.dataSources = new DataSourceRegistry();
            /**
             * A plugin can draw some contents on the canvas. But even better: it can do
             * so multiple times.  The order of the render calls will determine a list of
             * "layers" (i.e., earlier calls will be obviously drawn below later calls).
             * This list simply keeps the renderers+layer information so the drawing code
             * can just iterate on it
             */
            this.renderers = [];
            /**
             * Internal status of the model. Important for command handling coordination
             */
            this.status = 0 /* Ready */;
            /**
             * The dispatch method is the only entry point to manipulate data in the model.
             * This is through this method that commands are dispatched most of the time
             * recursively until no plugin want to react anymore.
             *
             * CoreCommands dispatched from this function are saved in the history.
             *
             * Small technical detail: it is defined as an arrow function.  There are two
             * reasons for this:
             * 1. this means that the dispatch method can be "detached" from the model,
             *    which is done when it is put in the environment (see the Spreadsheet
             *    component)
             * 2. This allows us to define its type by using the interface CommandDispatcher
             */
            this.dispatch = (type, payload) => {
                const command = { type, ...payload };
                let status = command.interactive ? 4 /* Interactive */ : this.status;
                if (this.config.isReadonly && !canExecuteInReadonly(command)) {
                    return new DispatchResult(50 /* Readonly */);
                }
                switch (status) {
                    case 0 /* Ready */:
                        const result = this.checkDispatchAllowed(command);
                        if (!result.isSuccessful) {
                            return result;
                        }
                        this.status = 1 /* Running */;
                        const { changes, commands } = this.state.recordChanges(() => {
                            if (isCoreCommand(command)) {
                                this.state.addCommand(command);
                            }
                            this.dispatchToHandlers(this.handlers, command);
                            this.finalize();
                        });
                        this.session.save(commands, changes);
                        this.status = 0 /* Ready */;
                        if (this.config.mode !== "headless") {
                            this.trigger("update");
                        }
                        break;
                    case 1 /* Running */:
                        if (isCoreCommand(command)) {
                            const dispatchResult = this.checkDispatchAllowed(command);
                            if (!dispatchResult.isSuccessful) {
                                return dispatchResult;
                            }
                            this.state.addCommand(command);
                            this.dispatchToHandlers(this.handlers, command);
                        }
                        else {
                            this.dispatchToHandlers(this.handlers, command);
                        }
                        break;
                    case 4 /* Interactive */:
                        if (isCoreCommand(command)) {
                            this.state.addCommand(command);
                        }
                        this.dispatchToHandlers(this.handlers, command);
                        break;
                    case 3 /* Finalizing */:
                        throw new Error(_lt("Cannot dispatch commands in the finalize state"));
                    case 2 /* RunningCore */:
                        throw new Error("A UI plugin cannot dispatch while handling a core command");
                }
                return DispatchResult.Success;
            };
            /**
             * Dispatch a command from a Core Plugin (or the History).
             * A command dispatched from this function is not added to the history.
             */
            this.dispatchFromCorePlugin = (type, payload) => {
                const command = { type, ...payload };
                const previousStatus = this.status;
                this.status = 2 /* RunningCore */;
                this.dispatchToHandlers(this.handlers, command);
                this.status = previousStatus;
                return DispatchResult.Success;
            };
            DEBUG.model = this;
            stateUpdateMessages = repairInitialMessages(data, stateUpdateMessages);
            const workbookData = load(data);
            this.state = new StateObserver();
            this.uuidGenerator = uuidGenerator;
            this.config = this.setupConfig(config);
            this.session = this.setupSession(workbookData.revisionId);
            this.config.moveClient = this.session.move.bind(this.session);
            this.history = new LocalHistory(this.dispatchFromCorePlugin, this.session);
            this.getters = {
                isReadonly: () => this.config.isReadonly,
                canUndo: this.history.canUndo.bind(this.history),
                canRedo: this.history.canRedo.bind(this.history),
                getClient: this.session.getClient.bind(this.session),
                getConnectedClients: this.session.getConnectedClients.bind(this.session),
                isFullySynchronized: this.session.isFullySynchronized.bind(this.session),
            };
            this.range = new RangeAdapter(this.getters);
            this.getters.getRangeString = this.range.getRangeString.bind(this.range);
            this.getters.getRangeFromSheetXC = this.range.getRangeFromSheetXC.bind(this.range);
            this.getters.createAdaptedRanges = this.range.createAdaptedRanges.bind(this.range);
            this.uuidGenerator.setIsFastStrategy(true);
            // registering plugins
            for (let Plugin of corePluginRegistry.getAll()) {
                this.setupCorePlugin(Plugin, workbookData);
            }
            for (let Plugin of uiPluginRegistry.getAll()) {
                this.setupUiPlugin(Plugin);
            }
            this.uuidGenerator.setIsFastStrategy(false);
            // starting plugins
            this.dispatch("START");
            // This should be done after construction of LocalHistory due to order of
            // events
            this.setupSessionEvents();
            // Load the initial revisions
            this.session.loadInitialMessages(stateUpdateMessages);
            this.joinSession(config.client);
            if (config.snapshotRequested) {
                this.session.snapshot(this.exportData());
            }
        }
        get handlers() {
            return [this.range, ...this.corePlugins, ...this.uiPlugins, this.history];
        }
        joinSession(client) {
            this.session.join(client);
        }
        leaveSession() {
            this.session.leave();
        }
        destroy() {
            delete DEBUG.model;
        }
        setupUiPlugin(Plugin) {
            if (Plugin.modes.includes(this.config.mode)) {
                const plugin = new Plugin(this.getters, this.state, this.dispatch, this.config);
                for (let name of Plugin.getters) {
                    if (!(name in plugin)) {
                        throw new Error(`Invalid getter name: ${name} for plugin ${plugin.constructor}`);
                    }
                    this.getters[name] = plugin[name].bind(plugin);
                }
                this.uiPlugins.push(plugin);
                const layers = Plugin.layers.map((l) => [plugin, l]);
                this.renderers.push(...layers);
                this.renderers.sort((p1, p2) => p1[1] - p2[1]);
            }
        }
        /**
         * Initialize and properly configure a plugin.
         *
         * This method is private for now, but if the need arise, there is no deep
         * reason why the model could not add dynamically a plugin while it is running.
         */
        setupCorePlugin(Plugin, data) {
            if (Plugin.modes.includes(this.config.mode)) {
                const plugin = new Plugin(this.getters, this.state, this.range, this.dispatchFromCorePlugin, this.config, this.uuidGenerator);
                plugin.import(data);
                for (let name of Plugin.getters) {
                    if (!(name in plugin)) {
                        throw new Error(`Invalid getter name: ${name} for plugin ${plugin.constructor}`);
                    }
                    this.getters[name] = plugin[name].bind(plugin);
                }
                this.corePlugins.push(plugin);
            }
        }
        onRemoteRevisionReceived({ commands }) {
            for (let command of commands) {
                this.dispatchToHandlers(this.uiPlugins, command);
            }
            this.finalize();
        }
        setupSession(revisionId) {
            const session = new Session(buildRevisionLog(revisionId, this.state.recordChanges.bind(this.state), (command) => this.dispatchToHandlers([this.range, ...this.corePlugins], command)), this.config.transportService, revisionId);
            return session;
        }
        setupSessionEvents() {
            this.session.on("remote-revision-received", this, this.onRemoteRevisionReceived);
            this.session.on("revision-redone", this, this.finalize);
            this.session.on("revision-undone", this, this.finalize);
            // How could we improve communication between the session and UI?
            // It feels weird to have the model piping specific session events to its own bus.
            this.session.on("unexpected-revision-id", this, () => this.trigger("unexpected-revision-id"));
            this.session.on("collaborative-event-received", this, () => {
                this.trigger("update");
            });
        }
        setupConfig(config) {
            const client = config.client || {
                id: this.uuidGenerator.uuidv4(),
                name: _lt("Anonymous").toString(),
            };
            const transportService = config.transportService || new LocalTransportService();
            return {
                mode: config.mode || "normal",
                openSidePanel: config.openSidePanel || (() => { }),
                notifyUser: config.notifyUser || (() => { }),
                askConfirmation: config.askConfirmation || (() => { }),
                editText: config.editText || (() => { }),
                evalContext: config.evalContext || {},
                transportService,
                client,
                moveClient: () => { },
                isHeadless: config.mode === "headless" || false,
                isReadonly: config.isReadonly || false,
                snapshotRequested: false,
                dataSources: this.dataSources,
            };
        }
        // ---------------------------------------------------------------------------
        // Command Handling
        // ---------------------------------------------------------------------------
        /**
         * Check if the given command is allowed by all the plugins and the history.
         */
        checkDispatchAllowed(command) {
            const results = this.handlers.map((handler) => handler.allowDispatch(command));
            return new DispatchResult(results.flat());
        }
        finalize() {
            this.status = 3 /* Finalizing */;
            for (const h of this.handlers) {
                h.finalize();
            }
            this.status = 0 /* Ready */;
        }
        /**
         * Dispatch the given command to the given handlers.
         * It will call `beforeHandle` and `handle`
         */
        dispatchToHandlers(handlers, command) {
            for (const handler of handlers) {
                handler.beforeHandle(command);
            }
            for (const handler of handlers) {
                handler.handle(command);
            }
        }
        // ---------------------------------------------------------------------------
        // Grid Rendering
        // ---------------------------------------------------------------------------
        /**
         * When the Grid component is ready (= mounted), it has a reference to its
         * canvas and need to draw the grid on it.  This is then done by calling this
         * method, which will dispatch the call to all registered plugins.
         *
         * Note that nothing prevent multiple grid components from calling this method
         * each, or one grid component calling it multiple times with a different
         * context. This is probably the way we should do if we want to be able to
         * freeze a part of the grid (so, we would need to render different zones)
         */
        drawGrid(context) {
            // we make sure here that the viewport is properly positioned: the offsets
            // correspond exactly to a cell
            context.viewport = this.getters.getActiveSnappedViewport(); //snaped one
            for (let [renderer, layer] of this.renderers) {
                context.ctx.save();
                renderer.drawGrid(context, layer);
                context.ctx.restore();
            }
        }
        // ---------------------------------------------------------------------------
        // Data Export
        // ---------------------------------------------------------------------------
        /**
         * As the name of this method strongly implies, it is useful when we need to
         * export date out of the model.
         */
        exportData() {
            let data = createEmptyWorkbookData();
            for (let handler of this.handlers) {
                if (handler instanceof CorePlugin) {
                    handler.export(data);
                }
            }
            data.revisionId = this.session.getRevisionId() || DEFAULT_REVISION_ID;
            data = JSON.parse(JSON.stringify(data));
            return data;
        }
        /**
         * Change the configuration of the model to put it in readonly or read-write mode
         * @param isReadonly
         */
        updateReadOnly(isReadonly) {
            if (isReadonly) {
                this.dispatch("STOP_EDITION", { cancel: true });
            }
            this.config.isReadonly = isReadonly || false;
        }
        /**
         * Wait until all cells that depends on dataSources in spreadsheet are computed
         */
        waitForIdle() {
            return this.dataSources.waitForReady();
        }
        /**
         * Exports the current model data into a list of serialized XML files
         * to be zipped together as an *.xlsx file.
         *
         * We need to trigger a cell revaluation  on every sheet and ensure that even
         * async functions are evaluated.
         * This prove to be necessary if the client did not trigger that evaluation in the first place
         * (e.g. open a document with several sheet and click on download before visiting each sheet)
         */
        async exportXLSX() {
            await this.waitForIdle();
            this.dispatch("EVALUATE_ALL_SHEETS");
            let data = createEmptyExcelWorkbookData();
            for (let handler of this.handlers) {
                if (handler instanceof CorePlugin) {
                    handler.exportForExcel(data);
                }
            }
            data = JSON.parse(JSON.stringify(data));
            return getXLSX(data);
        }
    }

    const { useComponent, useState: useState$e, onPatched, useRef: useRef$7, onMounted: onMounted$1 } = owl.hooks;
    /**
     * Return the o-spreadsheet element position relative
     * to the browser viewport.
     */
    function useSpreadsheetPosition() {
        const position = useState$e({ x: 0, y: 0 });
        let spreadsheetElement = document.querySelector(".o-spreadsheet");
        function updatePosition() {
            if (!spreadsheetElement) {
                spreadsheetElement = document.querySelector(".o-spreadsheet");
            }
            if (spreadsheetElement) {
                const { top, left } = spreadsheetElement.getBoundingClientRect();
                position.x = left;
                position.y = top;
            }
        }
        onMounted$1(updatePosition);
        onPatched(updatePosition);
        return position;
    }
    /**
     * Return the component (or ref's component) top left position (in pixels) relative
     * to the upper left corner of the spreadsheet.
     *
     * Note: when used with a <Portal/> component, it will
     * return the portal position, not the teleported position.
     */
    function useAbsolutePosition(ref) {
        const position = useState$e({ x: 0, y: 0 });
        const component = useComponent();
        const spreadsheet = useSpreadsheetPosition();
        function updateElPosition() {
            const el = (ref === null || ref === void 0 ? void 0 : ref.el) || component.el;
            const { top, left } = el.getBoundingClientRect();
            const x = left - spreadsheet.x;
            const y = top - spreadsheet.y;
            if (x !== position.x || y !== position.y) {
                position.x = x;
                position.y = y;
            }
        }
        onMounted$1(updateElPosition);
        onPatched(updateElPosition);
        return position;
    }

    const { Component: Component$i, tags: tags$3 } = owl__namespace;
    const { Portal } = owl__namespace.misc;
    const { xml: xml$l } = tags$3;
    const TEMPLATE$j = xml$l /* xml */ `
  <Portal target="'.o-spreadsheet'">
    <div t-att-style="style">
      <t t-slot="default"/>
    </div>
  </Portal>
`;
    class Popover extends Component$i {
        constructor() {
            super(...arguments);
            this.getters = this.env.getters;
        }
        get style() {
            const horizontalPosition = `left:${this.horizontalPosition()}`;
            const verticalPosition = `top:${this.verticalPosition()}`;
            const height = `max-height:${this.viewportDimension.height - BOTTOMBAR_HEIGHT - SCROLLBAR_WIDTH$1}`;
            return `
      position: absolute;
      z-index: 5;
      ${verticalPosition}px;
      ${horizontalPosition}px;
      ${height}px;
      width:${this.props.childWidth}px;
      overflow-y: auto;
      overflow-x: hidden;
      box-shadow: 1px 2px 5px 2px rgb(51 51 51 / 15%);
    `;
        }
        get viewportDimension() {
            return this.getters.getViewportDimension();
        }
        get shouldRenderRight() {
            const { x } = this.props.position;
            return x + this.props.childWidth < this.viewportDimension.width;
        }
        get shouldRenderBottom() {
            const { y } = this.props.position;
            return y + this.props.childHeight < this.viewportDimension.height + TOPBAR_HEIGHT;
        }
        horizontalPosition() {
            const { x } = this.props.position;
            if (this.shouldRenderRight) {
                return x;
            }
            return x - this.props.childWidth - this.props.flipHorizontalOffset;
        }
        verticalPosition() {
            const { y } = this.props.position;
            if (this.shouldRenderBottom) {
                return y;
            }
            return Math.max(y - this.props.childHeight + this.props.flipVerticalOffset, this.props.marginTop);
        }
    }
    Popover.template = TEMPLATE$j;
    Popover.components = { Portal };
    Popover.defaultProps = {
        flipHorizontalOffset: 0,
        flipVerticalOffset: 0,
        verticalOffset: 0,
        marginTop: 0,
    };

    const { xml: xml$k, css: css$j } = owl.tags;
    const { useExternalListener: useExternalListener$2, useRef: useRef$6 } = owl.hooks;
    //------------------------------------------------------------------------------
    // Context Menu Component
    //------------------------------------------------------------------------------
    const TEMPLATE$i = xml$k /* xml */ `
    <Popover
      position="props.position"
      childWidth="${MENU_WIDTH}"
      childHeight="menuHeight"
      flipHorizontalOffset="popover.flipHorizontalOffset"
      flipVerticalOffset="popover.flipVerticalOffset"
      marginTop="popover.marginTop"
      >
      <div t-ref="menu" class="o-menu" t-on-scroll="onScroll" t-on-wheel.stop="" t-on-click.stop="" t-on-contextmenu.prevent="">
        <t t-foreach="props.menuItems" t-as="menuItem" t-key="menuItem.id">
          <t t-set="isMenuRoot" t-value="isRoot(menuItem)"/>
          <t t-set="isMenuEnabled" t-value="isEnabled(menuItem)"/>
          <div
            t-att-title="getName(menuItem)"
            t-att-data-name="menuItem.id"
            t-on-click="onClickMenu(menuItem, menuItem_index)"
            t-on-mouseover="onMouseOver(menuItem, menuItem_index)"
            class="o-menu-item"
            t-att-class="{
              'o-menu-root': isMenuRoot,
              'disabled': !isMenuEnabled,
            }">
            <t t-esc="getName(menuItem)"/>
            <span class="o-menu-item-shortcut" t-esc="getShortCut(menuItem)"/>
            <t t-if="isMenuRoot">
              ${TRIANGLE_RIGHT_ICON}
            </t>
            <t t-elif="menuItem.icon">
              <i t-att-class="menuItem.icon" class="o-menu-item-icon"/>
            </t>
          </div>
          <div t-if="menuItem.separator and !menuItem_last" class="o-separator"/>
        </t>
      </div>
      <Menu t-if="subMenu.isOpen"
        position="subMenuPosition"
        menuItems="subMenu.menuItems"
        depth="props.depth + 1"
        t-ref="subMenuRef"
        t-on-close="subMenu.isOpen=false"/>
    </Popover>`;
    const CSS$h = css$j /* scss */ `
  .o-menu {
    background-color: white;
    padding: 8px 0px;
    .o-menu-item {
      display: flex;
      justify-content: space-between;
      box-sizing: border-box;
      height: ${MENU_ITEM_HEIGHT}px;
      padding: 4px 16px;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      cursor: pointer;
      user-select: none;

      &.o-menu-root {
        display: flex;
        justify-content: space-between;
      }
      .o-menu-item-icon {
        margin-top: auto;
        margin-bottom: auto;
      }
      .o-icon {
        width: 10px;
      }

      &:not(.disabled) {
        &:hover {
          background-color: #ebebeb;
        }
        .o-menu-item-shortcut {
          color: grey;
        }
      }
      &.disabled {
        color: ${MENU_ITEM_DISABLED_COLOR};
        cursor: not-allowed;
      }
    }

    .o-separator {
      border-bottom: ${MENU_SEPARATOR_BORDER_WIDTH}px solid #e0e2e4;
      margin-top: ${MENU_SEPARATOR_PADDING}px;
      margin-bottom: ${MENU_SEPARATOR_PADDING}px;
    }
  }
`;
    class Menu extends owl.Component {
        constructor() {
            super(...arguments);
            this.position = useAbsolutePosition(useRef$6("menu"));
            this.subMenuRef = useRef$6("subMenuRef");
            useExternalListener$2(window, "click", this.onClick);
            useExternalListener$2(window, "contextmenu", this.onContextMenu);
            this.subMenu = owl.useState({
                isOpen: false,
                position: null,
                scrollOffset: 0,
                menuItems: [],
            });
        }
        get subMenuPosition() {
            const position = Object.assign({}, this.subMenu.position);
            position.y -= this.subMenu.scrollOffset || 0;
            return position;
        }
        get menuHeight() {
            return this.menuComponentHeight(this.props.menuItems);
        }
        get subMenuHeight() {
            return this.menuComponentHeight(this.subMenu.menuItems);
        }
        get popover() {
            const isRoot = this.props.depth === 1;
            return {
                // some margin between the header and the component
                marginTop: HEADER_HEIGHT + 6 + TOPBAR_HEIGHT,
                flipHorizontalOffset: MENU_WIDTH * (this.props.depth - 1),
                flipVerticalOffset: isRoot ? 0 : MENU_ITEM_HEIGHT,
            };
        }
        async activateMenu(menu) {
            const result = await menu.action(this.env);
            this.close();
            this.trigger(`menu-clicked`, result);
        }
        close() {
            this.subMenu.isOpen = false;
            this.trigger("close");
        }
        /**
         * Return the number of pixels between the top of the menu
         * and the menu item at a given index.
         */
        subMenuVerticalPosition(position) {
            const menusAbove = this.props.menuItems.slice(0, position);
            return this.menuComponentHeight(menusAbove) + this.position.y;
        }
        onClick(ev) {
            // Don't close a root menu when clicked to open the submenus.
            if (this.el && isChildEvent(this.el, ev)) {
                return;
            }
            this.close();
        }
        onContextMenu(ev) {
            // Don't close a root menu when clicked to open the submenus.
            if (this.el && isChildEvent(this.el, ev)) {
                return;
            }
            this.subMenu.isOpen = false;
        }
        /**
         * Return the total height (in pixels) needed for some
         * menu items
         */
        menuComponentHeight(menuItems) {
            const separators = menuItems.filter((m) => m.separator);
            const others = menuItems;
            return MENU_ITEM_HEIGHT * others.length + separators.length * MENU_SEPARATOR_HEIGHT;
        }
        getName(menu) {
            return cellMenuRegistry.getName(menu, this.env);
        }
        getShortCut(menu) {
            return cellMenuRegistry.getShortCut(menu);
        }
        isRoot(menu) {
            return !menu.action;
        }
        isEnabled(menu) {
            if (menu.isEnabled(this.env)) {
                return this.env.getters.isReadonly() ? menu.isReadonlyAllowed : true;
            }
            return false;
        }
        closeSubMenus() {
            if (this.subMenuRef.comp) {
                this.subMenuRef.comp.closeSubMenus();
            }
            this.subMenu.isOpen = false;
        }
        onScroll(ev) {
            this.subMenu.scrollOffset = ev.target.scrollTop;
        }
        /**
         * If the given menu is not disabled, open it's submenu at the
         * correct position according to available surrounding space.
         */
        openSubMenu(menu, position) {
            this.closeSubMenus();
            const y = this.subMenuVerticalPosition(position);
            this.subMenu.position = {
                x: this.position.x + MENU_WIDTH,
                y: y - (this.subMenu.scrollOffset || 0),
            };
            this.subMenu.menuItems = cellMenuRegistry
                .getChildren(menu, this.env)
                .filter((item) => !item.isVisible || item.isVisible(this.env));
            this.subMenu.isOpen = true;
        }
        onClickMenu(menu, position) {
            if (this.isEnabled(menu)) {
                if (this.isRoot(menu)) {
                    this.openSubMenu(menu, position);
                }
                else {
                    this.activateMenu(menu);
                }
            }
        }
        onMouseOver(menu, position) {
            if (menu.isEnabled(this.env)) {
                if (this.isRoot(menu)) {
                    this.openSubMenu(menu, position);
                }
                else {
                    this.subMenu.isOpen = false;
                }
            }
        }
    }
    Menu.template = TEMPLATE$i;
    Menu.components = { Menu, Popover };
    Menu.style = CSS$h;
    Menu.defaultProps = {
        depth: 1,
    };

    const { Component: Component$h } = owl__namespace;
    const { xml: xml$j, css: css$i } = owl__namespace.tags;
    const { useState: useState$d } = owl__namespace.hooks;
    // -----------------------------------------------------------------------------
    // SpreadSheet
    // -----------------------------------------------------------------------------
    const TEMPLATE$h = xml$j /* xml */ `
  <div class="o-spreadsheet-bottom-bar">
    <div class="o-sheet-item o-add-sheet" t-att-class="{'disabled': getters.isReadonly()}" t-on-click="addSheet">${PLUS}</div>
    <div class="o-sheet-item o-list-sheets" t-on-click="listSheets">${LIST}</div>
    <div class="o-all-sheets">
      <t t-foreach="getters.getSheets()" t-as="sheet" t-key="sheet.id">
        <div class="o-sheet-item o-sheet" t-on-click="activateSheet(sheet.id)"
             t-on-contextmenu.prevent="onContextMenu(sheet.id)"
             t-att-title="sheet.name"
             t-att-data-id="sheet.id"
             t-att-class="{active: sheet.id === getters.getActiveSheetId()}">
          <span class="o-sheet-name" t-esc="sheet.name" t-on-dblclick="onDblClick(sheet.id)"/>
          <span class="o-sheet-icon" t-on-click.stop="onIconClick(sheet.id)">${TRIANGLE_DOWN_ICON}</span>
        </div>
      </t>
    </div>
    <t t-set="aggregate" t-value="getters.getAggregate()"/>
    <div t-if="aggregate !== null" class="o-aggregate">Sum: <t t-esc="aggregate"/></div>
    <Menu t-if="menuState.isOpen"
          position="menuState.position"
          menuItems="menuState.menuItems"
          t-on-close="menuState.isOpen=false"/>
  </div>`;
    const CSS$g = css$i /* scss */ `
  .o-spreadsheet-bottom-bar {
    background-color: ${BACKGROUND_GRAY_COLOR};
    padding-left: ${HEADER_WIDTH}px;
    display: flex;
    align-items: center;
    font-size: 15px;
    border-top: 1px solid lightgrey;
    overflow: hidden;

    .o-add-sheet,
    .o-list-sheets {
      margin-right: 5px;
    }

    .o-add-sheet.disabled {
      cursor: not-allowed;
    }

    .o-sheet-item {
      display: flex;
      align-items: center;
      padding: 5px;
      cursor: pointer;
      &:hover {
        background-color: rgba(0, 0, 0, 0.08);
      }
    }

    .o-all-sheets {
      display: flex;
      align-items: center;
      max-width: 80%;
      overflow: hidden;
    }

    .o-sheet {
      color: #666;
      padding: 0 15px;
      padding-right: 10px;
      height: ${BOTTOMBAR_HEIGHT}px;
      line-height: ${BOTTOMBAR_HEIGHT}px;
      user-select: none;
      white-space: nowrap;
      border-left: 1px solid #c1c1c1;

      &:last-child {
        border-right: 1px solid #c1c1c1;
      }

      &.active {
        color: #484;
        background-color: white;
        box-shadow: 0 1px 3px 1px rgba(60, 64, 67, 0.15);
      }

      .o-sheet-icon {
        margin-left: 5px;

        &:hover {
          background-color: rgba(0, 0, 0, 0.08);
        }
      }
    }

    .o-aggregate {
      background-color: white;
      margin-left: auto;
      font-size: 14px;
      margin-right: 20px;
      padding: 4px 8px;
      color: #333;
      border-radius: 3px;
      box-shadow: 0 1px 3px 1px rgba(60, 64, 67, 0.15);
    }
    .fade-enter-active {
      transition: opacity 0.5s;
    }

    .fade-enter {
      opacity: 0;
    }
  }
`;
    class BottomBar extends Component$h {
        constructor() {
            super(...arguments);
            this.getters = this.env.getters;
            this.menuState = useState$d({ isOpen: false, position: null, menuItems: [] });
        }
        mounted() {
            this.focusSheet();
        }
        patched() {
            this.focusSheet();
        }
        focusSheet() {
            const div = this.el.querySelector(`[data-id="${this.getters.getActiveSheetId()}"]`);
            if (div && div.scrollIntoView) {
                div.scrollIntoView();
            }
        }
        addSheet() {
            const activeSheetId = this.env.getters.getActiveSheetId();
            const position = this.env.getters.getVisibleSheets().findIndex((sheetId) => sheetId === activeSheetId) + 1;
            const sheetId = this.env.uuidGenerator.uuidv4();
            const name = this.getters.getNextSheetName(this.env._t("Sheet"));
            this.env.dispatch("CREATE_SHEET", { sheetId, position, name });
            this.env.dispatch("ACTIVATE_SHEET", { sheetIdFrom: activeSheetId, sheetIdTo: sheetId });
        }
        listSheets(ev) {
            const registry = new MenuItemRegistry();
            const from = this.getters.getActiveSheetId();
            let i = 0;
            for (let sheet of this.getters.getSheets()) {
                registry.add(sheet.id, {
                    name: sheet.name,
                    sequence: i,
                    isReadonlyAllowed: true,
                    action: (env) => env.dispatch("ACTIVATE_SHEET", { sheetIdFrom: from, sheetIdTo: sheet.id }),
                });
                i++;
            }
            this.openContextMenu(ev.currentTarget, registry);
        }
        activateSheet(name) {
            this.env.dispatch("ACTIVATE_SHEET", {
                sheetIdFrom: this.getters.getActiveSheetId(),
                sheetIdTo: name,
            });
        }
        onDblClick(sheetId) {
            this.env.dispatch("RENAME_SHEET", { interactive: true, sheetId });
        }
        openContextMenu(target, registry) {
            const x = target.offsetLeft;
            const y = target.offsetTop;
            this.menuState.isOpen = true;
            this.menuState.menuItems = registry.getAll().filter((x) => x.isVisible(this.env));
            this.menuState.position = { x, y };
        }
        onIconClick(sheet, ev) {
            if (this.getters.getActiveSheetId() !== sheet) {
                this.activateSheet(sheet);
            }
            if (this.menuState.isOpen) {
                this.menuState.isOpen = false;
            }
            else {
                this.openContextMenu(ev.currentTarget.parentElement, sheetMenuRegistry);
            }
        }
        onContextMenu(sheet, ev) {
            if (this.getters.getActiveSheetId() !== sheet) {
                this.activateSheet(sheet);
            }
            this.openContextMenu(ev.currentTarget, sheetMenuRegistry);
        }
    }
    BottomBar.template = TEMPLATE$h;
    BottomBar.style = CSS$g;
    BottomBar.components = { Menu };

    function startDnd(onMouseMove, onMouseUp) {
        const _onMouseUp = (ev) => {
            onMouseUp(ev);
            window.removeEventListener("mouseup", _onMouseUp);
            window.removeEventListener("dragstart", _onDragStart);
            window.removeEventListener("mousemove", onMouseMove);
            window.removeEventListener("wheel", onMouseMove);
        };
        function _onDragStart(ev) {
            ev.preventDefault();
        }
        window.addEventListener("mouseup", _onMouseUp);
        window.addEventListener("dragstart", _onDragStart);
        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("wheel", onMouseMove);
    }
    /**
     * Function to be used during a mousedown event, this function allows to
     * perform actions related to the mousemove and mouseup events and adjusts the viewport
     * when the new position related to the mousemove event is outside of it.
     * Among inputs are two callback functions. First intended for actions performed during
     * the mousemove event, it receives as parameters the current position of the mousemove
     * (occurrence of the current column and the current row). Second intended for actions
     * performed during the mouseup event.
     */
    function dragAndDropBeyondTheViewport(element, env, cbMouseMove, cbMouseUp) {
        const position = element.getBoundingClientRect();
        let timeOutId = null;
        let currentEv;
        const onMouseMove = (ev) => {
            currentEv = ev;
            if (timeOutId) {
                return;
            }
            const offsetX = currentEv.clientX - position.left;
            const offsetY = currentEv.clientY - position.top;
            const edgeScrollInfoX = env.getters.getEdgeScrollCol(offsetX);
            const edgeScrollInfoY = env.getters.getEdgeScrollRow(offsetY);
            const { top, left, bottom, right } = env.getters.getActiveSnappedViewport();
            let colIndex;
            if (edgeScrollInfoX.canEdgeScroll) {
                colIndex = edgeScrollInfoX.direction > 0 ? right : left - 1;
            }
            else {
                colIndex = env.getters.getColIndex(offsetX, left);
            }
            let rowIndex;
            if (edgeScrollInfoY.canEdgeScroll) {
                rowIndex = edgeScrollInfoY.direction > 0 ? bottom : top - 1;
            }
            else {
                rowIndex = env.getters.getRowIndex(offsetY, top);
            }
            cbMouseMove(colIndex, rowIndex);
            if (edgeScrollInfoX.canEdgeScroll) {
                const { left, offsetY } = env.getters.getActiveSnappedViewport();
                const { cols } = env.getters.getActiveSheet();
                const offsetX = cols[left + edgeScrollInfoX.direction].start;
                env.dispatch("SET_VIEWPORT_OFFSET", { offsetX, offsetY });
                timeOutId = setTimeout(() => {
                    timeOutId = null;
                    onMouseMove(currentEv);
                }, Math.round(edgeScrollInfoX.delay));
            }
            if (edgeScrollInfoY.canEdgeScroll) {
                const { top, offsetX } = env.getters.getActiveSnappedViewport();
                const { rows } = env.getters.getActiveSheet();
                const offsetY = rows[top + edgeScrollInfoY.direction].start;
                env.dispatch("SET_VIEWPORT_OFFSET", { offsetX, offsetY });
                timeOutId = setTimeout(() => {
                    timeOutId = null;
                    onMouseMove(currentEv);
                }, Math.round(edgeScrollInfoY.delay));
            }
        };
        const onMouseUp = () => {
            clearTimeout(timeOutId);
            cbMouseUp();
        };
        startDnd(onMouseMove, onMouseUp);
    }

    const { Component: Component$g } = owl__namespace;
    const { xml: xml$i, css: css$h } = owl__namespace.tags;
    const { useState: useState$c } = owl__namespace.hooks;
    // -----------------------------------------------------------------------------
    // Autofill
    // -----------------------------------------------------------------------------
    const TEMPLATE$g = xml$i /* xml */ `
  <div class="o-autofill" t-on-mousedown="onMouseDown" t-att-style="style" t-on-dblclick="onDblClick">
    <div class="o-autofill-handler" t-att-style="styleHandler"/>
    <t t-set="tooltip" t-value="getTooltip()"/>
    <div t-if="tooltip" class="o-autofill-nextvalue" t-att-style="styleNextvalue">
      <t t-component="tooltip.component" t-props="tooltip.props"/>
    </div>
  </div>
`;
    const CSS$f = css$h /* scss */ `
  .o-autofill {
    height: 6px;
    width: 6px;
    border: 1px solid white;
    position: absolute;
    background-color: #1a73e8;

    .o-autofill-handler {
      position: absolute;
      height: ${AUTOFILL_EDGE_LENGTH}px;
      width: ${AUTOFILL_EDGE_LENGTH}px;

      &:hover {
        cursor: crosshair;
      }
    }

    .o-autofill-nextvalue {
      position: absolute;
      background-color: white;
      border: 1px solid black;
      padding: 5px;
      font-size: 12px;
      pointer-events: none;
      white-space: nowrap;
    }
  }
`;
    class Autofill extends Component$g {
        constructor() {
            super(...arguments);
            this.state = useState$c({
                position: { left: 0, top: 0 },
                handler: false,
            });
        }
        get style() {
            const { left, top } = this.props.position;
            return `top:${top}px;left:${left}px`;
        }
        get styleHandler() {
            let position = this.state.handler ? this.state.position : { left: 0, top: 0 };
            return `top:${position.top}px;left:${position.left}px;`;
        }
        get styleNextvalue() {
            let position = this.state.handler ? this.state.position : { left: 0, top: 0 };
            return `top:${position.top + 5}px;left:${position.left + 15}px;`;
        }
        getTooltip() {
            const tooltip = this.env.getters.getAutofillTooltip();
            if (tooltip && !tooltip.component) {
                tooltip.component = TooltipComponent;
            }
            return tooltip;
        }
        onMouseDown(ev) {
            this.state.handler = true;
            this.state.position = { left: 0, top: 0 };
            const { offsetY, offsetX } = this.env.getters.getActiveSnappedViewport();
            const start = {
                left: ev.clientX + offsetX,
                top: ev.clientY + offsetY,
            };
            let lastCol;
            let lastRow;
            const onMouseUp = () => {
                this.state.handler = false;
                this.env.dispatch("AUTOFILL");
            };
            const onMouseMove = (ev) => {
                const parent = this.el.parentElement;
                const position = parent.getBoundingClientRect();
                const { top: viewportTop, left: viewportLeft, offsetY, offsetX, } = this.env.getters.getActiveSnappedViewport();
                this.state.position = {
                    left: ev.clientX - start.left + offsetX,
                    top: ev.clientY - start.top + offsetY,
                };
                const col = this.env.getters.getColIndex(ev.clientX - position.left, viewportLeft);
                const row = this.env.getters.getRowIndex(ev.clientY - position.top, viewportTop);
                if (lastCol !== col || lastRow !== row) {
                    const activeSheet = this.env.getters.getActiveSheet();
                    lastCol = col === -1 ? lastCol : clip(col, 0, activeSheet.cols.length);
                    lastRow = row === -1 ? lastRow : clip(row, 0, activeSheet.rows.length);
                    if (lastCol !== undefined && lastRow !== undefined) {
                        this.env.dispatch("AUTOFILL_SELECT", { col: lastCol, row: lastRow });
                    }
                }
            };
            startDnd(onMouseMove, onMouseUp);
        }
        onDblClick() {
            this.env.dispatch("AUTOFILL_AUTO");
        }
    }
    Autofill.template = TEMPLATE$g;
    Autofill.style = CSS$f;
    class TooltipComponent extends Component$g {
    }
    TooltipComponent.template = xml$i /* xml */ `
    <div t-esc="props.content"/>
  `;

    const { Component: Component$f } = owl__namespace;
    const { css: css$g, xml: xml$h } = owl__namespace.tags;
    const TEMPLATE$f = xml$h /* xml */ `
  <div>
    <div
      class="o-client-tag"
      t-att-style="tagStyle"
      t-esc="props.name"
    />
  </div>
`;
    const CSS$e = css$g /* scss */ `
  .o-client-tag {
    position: absolute;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    font-size: ${DEFAULT_FONT_SIZE};
    color: white;
    opacity: 0;
    pointer-events: none;
  }
`;
    class ClientTag extends Component$f {
        get tagStyle() {
            const { col, row, color } = this.props;
            const viewport = this.env.getters.getActiveSnappedViewport();
            const { height } = this.env.getters.getViewportDimension();
            const [x, y, ,] = this.env.getters.getRect({ left: col, top: row, right: col, bottom: row }, viewport);
            return `bottom: ${height - y + 15}px;left: ${x - 1}px;border: 1px solid ${color};background-color: ${color};${this.props.active ? "opacity:1 !important" : ""}`;
        }
    }
    ClientTag.template = TEMPLATE$f;
    ClientTag.style = CSS$e;

    const { Component: Component$e, useState: useState$b } = owl__namespace;
    const { xml: xml$g, css: css$f } = owl__namespace.tags;
    const functions$1 = functionRegistry.content;
    const providerRegistry = new Registry();
    providerRegistry.add("functions", () => {
        return Object.keys(functions$1).map((key) => {
            return {
                text: key,
                description: functions$1[key].description,
            };
        });
    });
    // -----------------------------------------------------------------------------
    // Autocomplete DropDown component
    // -----------------------------------------------------------------------------
    const TEMPLATE$e = xml$g /* xml */ `
  <div t-att-class="{'o-autocomplete-dropdown':state.values.length}"
       t-att-style="state.values.length > 0 ? props.borderStyle : null"
    >
    <t t-foreach="state.values" t-as="v" t-key="v.text">
        <div t-att-class="{'o-autocomplete-value-focus': state.selectedIndex === v_index}" t-on-click.stop.prevent="fillValue(v_index)">
             <div class="o-autocomplete-value" t-esc="v.text"/>
             <div class="o-autocomplete-description" t-esc="v.description" t-if="state.selectedIndex === v_index"/>
        </div>
    </t>
  </div>`;
    const CSS$d = css$f /* scss */ `
  .o-autocomplete-dropdown {
    pointer-events: auto;
    background-color: #fff;
    & > div:hover {
      background-color: #f2f2f2;
    }
    .o-autocomplete-value-focus {
      background-color: rgba(0, 0, 0, 0.08);
    }

    & > div {
      display: flex;
      flex-direction: column;
      padding: 1px 0 5px 5px;
      .o-autocomplete-description {
        padding: 0 0 0 5px;
        font-size: 11px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
    }
  }
`;
    class TextValueProvider extends Component$e {
        constructor() {
            super(...arguments);
            this.state = useState$b({
                values: [],
                selectedIndex: 0,
            });
        }
        mounted() {
            this.filter(this.props.search);
        }
        willUpdateProps(nextProps) {
            if (nextProps.search !== this.props.search) {
                this.filter(nextProps.search);
            }
            return super.willUpdateProps(nextProps);
        }
        async filter(searchTerm) {
            const provider = providerRegistry.get(this.props.provider);
            let values = provider();
            if (this.props.filter) {
                values = this.props.filter(searchTerm, values);
            }
            else {
                values = values
                    .filter((t) => t.text.toUpperCase().startsWith(searchTerm.toUpperCase()))
                    .sort((l, r) => (l.text < r.text ? -1 : l.text > r.text ? 1 : 0));
            }
            this.state.values = values.slice(0, 10);
            this.state.selectedIndex = 0;
        }
        fillValue(index) {
            this.state.selectedIndex = index;
            this.trigger("completed", { text: this.getValueToFill() });
        }
        moveDown() {
            this.state.selectedIndex = (this.state.selectedIndex + 1) % this.state.values.length;
        }
        moveUp() {
            this.state.selectedIndex--;
            if (this.state.selectedIndex < 0) {
                this.state.selectedIndex = this.state.values.length - 1;
            }
        }
        getValueToFill() {
            if (this.state.values.length) {
                return this.state.values[this.state.selectedIndex].text;
            }
        }
    }
    TextValueProvider.template = TEMPLATE$e;
    TextValueProvider.style = CSS$d;

    class ContentEditableHelper {
        constructor(el) {
            this.el = el;
        }
        updateEl(el) {
            this.el = el;
        }
        /**
         * select the text at position start to end, no matter the children
         */
        selectRange(start, end) {
            let selection = window.getSelection();
            this.removeSelection();
            let range = document.createRange();
            if (start == end && start === 0) {
                range.setStart(this.el, 0);
                range.setEnd(this.el, 0);
                selection.addRange(range);
            }
            else {
                if (start < 0 || end > this.el.textContent.length) {
                    console.warn(`wrong selection asked start ${start}, end ${end}, text content length ${this.el.textContent.length}`);
                    if (start < 0)
                        start = 0;
                    if (end > this.el.textContent.length)
                        end = this.el.textContent.length;
                }
                let startNode = this.findChildAtCharacterIndex(start);
                let endNode = this.findChildAtCharacterIndex(end);
                range.setStart(startNode.node, startNode.offset);
                selection.addRange(range);
                selection.extend(endNode.node, endNode.offset);
            }
        }
        /**
         * finds the dom element that contains the character at `offset`
         */
        findChildAtCharacterIndex(offset) {
            let it = this.iterateChildren(this.el);
            let current, previous;
            let usedCharacters = offset;
            do {
                current = it.next();
                if (!current.done && !current.value.hasChildNodes()) {
                    if (current.value.textContent && current.value.textContent.length < usedCharacters) {
                        usedCharacters -= current.value.textContent.length;
                    }
                    else {
                        it.return(current.value);
                    }
                    previous = current.value;
                }
            } while (!current.done);
            if (current.value) {
                return { node: current.value, offset: usedCharacters };
            }
            return { node: previous, offset: usedCharacters };
        }
        /**
         * Iterate over the dom tree starting at `el` and over all the children depth first.
         * */
        *iterateChildren(el) {
            yield el;
            if (el.hasChildNodes()) {
                for (let child of el.childNodes) {
                    yield* this.iterateChildren(child);
                }
            }
        }
        /**
         * Sets (or Replaces all) the text inside the root element in the form of distinctive
         * span for each element provided in `contents`.
         *
         * Each span will have its own fontcolor and specific class if provided in the HtmlContent object.
         */
        setText(contents) {
            if (contents.length === 0) {
                return;
            }
            for (const content of contents) {
                const span = document.createElement("span");
                span.innerText = content.value;
                if (content.color) {
                    span.style.color = content.color;
                }
                if (content.class) {
                    span.classList.add(content.class);
                }
                this.el.appendChild(span);
            }
        }
        /**
         * remove the current selection of the user
         * */
        removeSelection() {
            let selection = window.getSelection();
            selection.removeAllRanges();
        }
        removeAll() {
            if (this.el) {
                while (this.el.firstChild) {
                    this.el.removeChild(this.el.firstChild);
                }
            }
        }
        /**
         * finds the indexes of the current selection.
         * */
        getCurrentSelection() {
            let { startElement, endElement, startSelectionOffset, endSelectionOffset } = this.getStartAndEndSelection();
            let startSizeBefore = this.findSizeBeforeElement(startElement);
            let endSizeBefore = this.findSizeBeforeElement(endElement);
            return {
                start: startSizeBefore + startSelectionOffset,
                end: endSizeBefore + endSelectionOffset,
            };
        }
        findSizeBeforeElement(nodeToFind) {
            let it = this.iterateChildren(this.el);
            let usedCharacters = 0;
            let current = it.next();
            while (!current.done && current.value !== nodeToFind) {
                if (!current.value.hasChildNodes()) {
                    if (current.value.textContent) {
                        usedCharacters += current.value.textContent.length;
                    }
                }
                current = it.next();
            }
            return usedCharacters;
        }
        getStartAndEndSelection() {
            const selection = document.getSelection();
            return {
                startElement: selection.anchorNode || this.el,
                startSelectionOffset: selection.anchorOffset,
                endElement: selection.focusNode || this.el,
                endSelectionOffset: selection.focusOffset,
            };
        }
    }

    const formulaAssistantTerms = {
        ABOUT: _lt("ABOUT"),
        OPTIONAL: _lt("optional"),
        BY_DEFAULT: _lt("by default"),
        REPEATABLE: _lt("repeatable"),
    };

    const { Component: Component$d } = owl__namespace;
    const { xml: xml$f, css: css$e } = owl__namespace.tags;
    const { useState: useState$a } = owl__namespace.hooks;
    // -----------------------------------------------------------------------------
    // Formula Assistant component
    // -----------------------------------------------------------------------------
    const TEMPLATE$d = xml$f /* xml */ `
  <div class="o-formula-assistant-container"
       t-att-style="props.borderStyle"
       t-att-class="{
         'o-formula-assistant-event-none': assistantState.allowCellSelectionBehind,
         'o-formula-assistant-event-auto': !assistantState.allowCellSelectionBehind
         }">
    <t t-set="context" t-value="getContext()"/>
    <div class="o-formula-assistant" t-if="context.functionName" t-on-mousemove="onMouseMove"
         t-att-class="{'o-formula-assistant-transparency': assistantState.allowCellSelectionBehind}">

      <div class="o-formula-assistant-head">
        <span t-esc="context.functionName"/> (
        <t t-foreach="context.functionDescription.args" t-as="arg" t-key="arg.name" >
          <span t-if="arg_index > '0'" >, </span>
          <span t-att-class="{ 'o-formula-assistant-focus': context.argToFocus === arg_index }" >
            <span>
              <span t-if="arg.optional || arg.repeating || arg.default">[</span>
              <span t-esc="arg.name" />
              <span t-if="arg.repeating">, ...</span>
              <span t-if="arg.optional || arg.repeating || arg.default">]</span>
            </span>
          </span>
        </t> )
      </div>

      <div class="o-formula-assistant-core">
        <div class="o-formula-assistant-gray" t-esc="env._t('${formulaAssistantTerms.ABOUT}')"/>
        <div t-esc="context.functionDescription.description"/>
      </div>

      <t t-foreach="context.functionDescription.args" t-as="arg" t-key="arg.name">
        <div class="o-formula-assistant-arg"
            t-att-class="{
              'o-formula-assistant-gray': context.argToFocus >= '0',
              'o-formula-assistant-focus': context.argToFocus === arg_index,
            }" >
          <div>
            <span t-esc="arg.name" />
            <span t-if="arg.optional || arg.repeating || arg.default "> - [<t t-esc="env._t('${formulaAssistantTerms.OPTIONAL}')"/>] </span>
            <span t-if="arg.default">
              <t t-esc="arg.defaultValue" />
              <t t-esc="env._t(' ${formulaAssistantTerms.BY_DEFAULT}')"/>
            </span>
            <span t-if="arg.repeating" t-esc="env._t('${formulaAssistantTerms.REPEATABLE}')"/>
          </div>
          <div class="o-formula-assistant-arg-description" t-esc="arg.description"/>
        </div>
      </t>

    </div>
  </div>
`;
    const CSS$c = css$e /* scss */ `
  .o-formula-assistant {
    white-space: normal;
    background-color: #fff;
    .o-formula-assistant-head {
      background-color: #f2f2f2;
      padding: 10px;
    }
    .o-formula-assistant-core {
      padding: 0px 0px 10px 0px;
      margin: 10px;
      border-bottom: 1px solid gray;
    }
    .o-formula-assistant-arg {
      padding: 0px 10px 10px 10px;
      display: flex;
      flex-direction: column;
    }
    .o-formula-assistant-arg-description {
      font-size: 85%;
    }
    .o-formula-assistant-focus {
      div:first-child,
      span {
        color: purple;
        text-shadow: 0px 0px 1px purple;
      }
      div:last-child {
        color: black;
      }
    }
    .o-formula-assistant-gray {
      color: gray;
    }
  }
  .o-formula-assistant-container {
    user-select: none;
  }
  .o-formula-assistant-event-none {
    pointer-events: none;
  }
  .o-formula-assistant-event-auto {
    pointer-events: auto;
  }
  .o-formula-assistant-transparency {
    opacity: 0.3;
  }
`;
    class FunctionDescriptionProvider extends Component$d {
        constructor() {
            super(...arguments);
            this.assistantState = useState$a({
                allowCellSelectionBehind: false,
            });
            this.timeOutId = 0;
        }
        willUnmount() {
            if (this.timeOutId) {
                clearTimeout(this.timeOutId);
            }
        }
        getContext() {
            return this.props;
        }
        onMouseMove() {
            this.assistantState.allowCellSelectionBehind = true;
            if (this.timeOutId) {
                clearTimeout(this.timeOutId);
            }
            this.timeOutId = setTimeout(() => {
                this.assistantState.allowCellSelectionBehind = false;
            }, 2000);
        }
    }
    FunctionDescriptionProvider.template = TEMPLATE$d;
    FunctionDescriptionProvider.style = CSS$c;

    const { Component: Component$c } = owl__namespace;
    const { useRef: useRef$5, useState: useState$9 } = owl__namespace.hooks;
    const { xml: xml$e, css: css$d } = owl__namespace.tags;
    const functions = functionRegistry.content;
    const ASSISTANT_WIDTH = 300;
    const FunctionColor = "#4a4e4d";
    const OperatorColor = "#3da4ab";
    const StringColor = "#f6cd61";
    const SelectionIndicatorColor = "darkgrey";
    const NumberColor = "#02c39a";
    const MatchingParenColor = "pink";
    const SelectionIndicatorClass = "selector-flag";
    const tokenColor = {
        OPERATOR: OperatorColor,
        NUMBER: NumberColor,
        STRING: StringColor,
        FUNCTION: FunctionColor,
        DEBUGGER: OperatorColor,
        LEFT_PAREN: FunctionColor,
        RIGHT_PAREN: FunctionColor,
        COMMA: FunctionColor,
    };
    const TEMPLATE$c = xml$e /* xml */ `
<div class="o-composer-container">
  <div
    t-att-class="{ 'o-composer': true, 'text-muted': getters.isReadonly(), 'unfocusable': getters.isReadonly() }"
    t-att-style="props.inputStyle"
    t-ref="o_composer"
    tabindex="1"
    t-att-contenteditable="getters.isReadonly() ? 'false' : 'true'"
    spellcheck="false"

    t-on-keydown="onKeydown"
    t-on-mousedown="onMousedown"
    t-on-input="onInput"
    t-on-keyup="onKeyup"
    t-on-click.stop="onClick"
    t-on-blur="onBlur"
  />

  <div t-if="props.focus !== 'inactive' and (autoCompleteState.showProvider or functionDescriptionState.showDescription)"
    class="o-composer-assistant" t-att-style="assistantStyle">
    <TextValueProvider
        t-if="autoCompleteState.showProvider"
        t-ref="o_autocomplete_provider"
        search="autoCompleteState.search"
        provider="autoCompleteState.provider"
        t-on-completed="onCompleted"
        borderStyle="borderStyle"
    />
    <FunctionDescriptionProvider
        t-if="functionDescriptionState.showDescription"
        t-ref="o_function_description_provider"
        functionName = "functionDescriptionState.functionName"
        functionDescription = "functionDescriptionState.functionDescription"
        argToFocus = "functionDescriptionState.argToFocus"
        borderStyle="borderStyle"
    />
  </div>
</div>
  `;
    const CSS$b = css$d /* scss */ `
  .o-composer-container {
    padding: 0;
    margin: 0;
    border: 0;
    z-index: 5;
    flex-grow: 1;
    max-height: inherit;
    .o-composer {
      caret-color: black;
      padding-left: 3px;
      padding-right: 3px;
      word-break: break-all;
      &:focus {
        outline: none;
      }
      &.unfocusable {
        pointer-events: none;
      }
      span {
        white-space: pre;
        &.${SelectionIndicatorClass}:after {
          content: "${SelectionIndicator}";
          color: ${SelectionIndicatorColor};
        }
      }
    }
    .o-composer-assistant {
      position: absolute;
      margin: 4px;
      pointer-events: none;
    }
  }

  /* Custom css to highlight topbar composer on focus */
  .o-topbar-toolbar .o-composer-container:focus-within {
    border: 1px solid ${SELECTION_BORDER_COLOR};
  }
`;
    class Composer extends Component$c {
        constructor() {
            super(...arguments);
            this.composerRef = useRef$5("o_composer");
            this.autoCompleteRef = useRef$5("o_autocomplete_provider");
            this.getters = this.env.getters;
            this.dispatch = this.env.dispatch;
            this.composerState = useState$9({
                positionStart: 0,
                positionEnd: 0,
            });
            this.autoCompleteState = useState$9({
                showProvider: false,
                provider: "functions",
                search: "",
            });
            this.functionDescriptionState = useState$9({
                showDescription: false,
                functionName: "",
                functionDescription: {},
                argToFocus: 0,
            });
            this.isKeyStillDown = false;
            this.borderStyle = `box-shadow: 0 1px 4px 3px rgba(60, 64, 67, 0.15);`;
            // we can't allow input events to be triggered while we remove and add back the content of the composer in processContent
            this.shouldProcessInputEvents = false;
            this.tokens = [];
            this.keyMapping = {
                ArrowUp: this.processArrowKeys,
                ArrowDown: this.processArrowKeys,
                ArrowLeft: this.processArrowKeys,
                ArrowRight: this.processArrowKeys,
                Enter: this.processEnterKey,
                Escape: this.processEscapeKey,
                F2: () => console.warn("Not implemented"),
                F4: () => console.warn("Not implemented"),
                Tab: (ev) => this.processTabKey(ev),
            };
            this.contentHelper = new ContentEditableHelper(this.composerRef.el);
        }
        get assistantStyle() {
            if (this.props.delimitation && this.props.rect) {
                const [cellX, cellY, , cellHeight] = this.props.rect;
                const remainingHeight = this.props.delimitation.height - (cellY + cellHeight);
                let assistantStyle = "";
                if (cellY > remainingHeight) {
                    // render top
                    assistantStyle += `
          top: -8px;
          transform: translate(0, -100%);
        `;
                }
                if (cellX + ASSISTANT_WIDTH > this.props.delimitation.width) {
                    // render left
                    assistantStyle += `right:0px;`;
                }
                return (assistantStyle += `width:${ASSISTANT_WIDTH}px;`);
            }
            return `width:${ASSISTANT_WIDTH}px;`;
        }
        mounted() {
            DEBUG.composer = this;
            const el = this.composerRef.el;
            this.contentHelper.updateEl(el);
            this.processContent();
        }
        willUnmount() {
            delete DEBUG.composer;
            this.trigger("composer-unmounted");
        }
        patched() {
            if (!this.isKeyStillDown) {
                this.processContent();
            }
        }
        // ---------------------------------------------------------------------------
        // Handlers
        // ---------------------------------------------------------------------------
        processArrowKeys(ev) {
            if (this.getters.isSelectingForComposer()) {
                this.functionDescriptionState.showDescription = false;
                return;
            }
            if (this.props.focus === "cellFocus" && !this.autoCompleteState.showProvider) {
                return;
            }
            ev.stopPropagation();
            const autoCompleteComp = this.autoCompleteRef.comp;
            if (["ArrowUp", "ArrowDown"].includes(ev.key) &&
                this.autoCompleteState.showProvider &&
                autoCompleteComp) {
                ev.preventDefault();
                if (ev.key === "ArrowUp") {
                    autoCompleteComp.moveUp();
                }
                else {
                    autoCompleteComp.moveDown();
                }
            }
        }
        processTabKey(ev) {
            ev.preventDefault();
            ev.stopPropagation();
            const autoCompleteComp = this.autoCompleteRef.comp;
            if (this.autoCompleteState.showProvider && autoCompleteComp) {
                const autoCompleteValue = autoCompleteComp.getValueToFill();
                if (autoCompleteValue) {
                    this.autoComplete(autoCompleteValue);
                    return;
                }
            }
            else {
                // when completing with tab, if there is no value to complete, the active cell will be moved to the right.
                // we can't let the model think that it is for a ref selection.
                // todo: check if this can be removed someday
                this.dispatch("STOP_COMPOSER_RANGE_SELECTION");
            }
            const deltaX = ev.shiftKey ? -1 : 1;
            this.dispatch("MOVE_POSITION", { deltaX, deltaY: 0 });
        }
        processEnterKey(ev) {
            ev.preventDefault();
            ev.stopPropagation();
            this.isKeyStillDown = false;
            const autoCompleteComp = this.autoCompleteRef.comp;
            if (this.autoCompleteState.showProvider && autoCompleteComp) {
                const autoCompleteValue = autoCompleteComp.getValueToFill();
                if (autoCompleteValue) {
                    this.autoComplete(autoCompleteValue);
                    return;
                }
            }
            this.dispatch("STOP_EDITION");
            this.dispatch("MOVE_POSITION", {
                deltaX: 0,
                deltaY: ev.shiftKey ? -1 : 1,
            });
        }
        processEscapeKey() {
            this.dispatch("STOP_EDITION", { cancel: true });
        }
        onKeydown(ev) {
            let handler = this.keyMapping[ev.key];
            if (handler) {
                handler.call(this, ev);
            }
            else {
                ev.stopPropagation();
            }
            const { start, end } = this.contentHelper.getCurrentSelection();
            if (!this.getters.isSelectingForComposer()) {
                this.dispatch("CHANGE_COMPOSER_CURSOR_SELECTION", { start, end });
                this.isKeyStillDown = true;
            }
        }
        /*
         * Triggered automatically by the content-editable between the keydown and key up
         * */
        onInput() {
            if (this.props.focus === "inactive" || !this.shouldProcessInputEvents) {
                return;
            }
            this.dispatch("STOP_COMPOSER_RANGE_SELECTION");
            const el = this.composerRef.el;
            this.dispatch("SET_CURRENT_CONTENT", {
                content: el.childNodes.length ? el.textContent : "",
                selection: this.contentHelper.getCurrentSelection(),
            });
        }
        onKeyup(ev) {
            this.isKeyStillDown = false;
            if (this.props.focus === "inactive" || ["Control", "Shift", "Tab", "Enter"].includes(ev.key)) {
                return;
            }
            if (this.autoCompleteState.showProvider && ["ArrowUp", "ArrowDown"].includes(ev.key)) {
                return; // already processed in keydown
            }
            if (this.getters.isSelectingForComposer() &&
                ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(ev.key)) {
                return; // already processed in keydown
            }
            ev.preventDefault();
            ev.stopPropagation();
            this.autoCompleteState.showProvider = false;
            if (ev.ctrlKey && ev.key === " ") {
                this.autoCompleteState.search = "";
                this.autoCompleteState.showProvider = true;
                this.dispatch("STOP_COMPOSER_RANGE_SELECTION");
                return;
            }
            const { start: oldStart, end: oldEnd } = this.getters.getComposerSelection();
            const { start, end } = this.contentHelper.getCurrentSelection();
            if (start !== oldStart || end !== oldEnd) {
                this.dispatch("CHANGE_COMPOSER_CURSOR_SELECTION", this.contentHelper.getCurrentSelection());
            }
            this.processTokenAtCursor();
            this.processContent();
        }
        onMousedown(ev) {
            if (ev.button > 0) {
                // not main button, probably a context menu
                return;
            }
            this.contentHelper.removeSelection();
        }
        onClick() {
            if (this.getters.isReadonly()) {
                return;
            }
            const newSelection = this.contentHelper.getCurrentSelection();
            this.dispatch("STOP_COMPOSER_RANGE_SELECTION");
            if (this.props.focus === "inactive") {
                this.trigger("composer-content-focused", {
                    selection: newSelection,
                });
            }
            this.dispatch("CHANGE_COMPOSER_CURSOR_SELECTION", newSelection);
            this.processTokenAtCursor();
        }
        onBlur() {
            this.isKeyStillDown = false;
        }
        onCompleted(ev) {
            this.autoComplete(ev.detail.text);
        }
        // ---------------------------------------------------------------------------
        // Private
        // ---------------------------------------------------------------------------
        processContent() {
            this.contentHelper.removeAll(); // removes the content of the composer, to be added just after
            this.shouldProcessInputEvents = false;
            if (this.props.focus !== "inactive") {
                this.contentHelper.selectRange(0, 0); // move the cursor inside the composer at 0 0.
            }
            const content = this.getContent();
            if (content.length !== 0) {
                this.contentHelper.setText(content);
                const { start, end } = this.getters.getComposerSelection();
                if (this.props.focus !== "inactive") {
                    // Put the cursor back where it was before the rendering
                    this.contentHelper.selectRange(start, end);
                }
            }
            this.shouldProcessInputEvents = true;
        }
        getContent() {
            let content;
            let value = this.getters.getCurrentContent();
            if (value === "") {
                content = [];
            }
            else if (value.startsWith("=") && this.getters.getEditionMode() !== "inactive") {
                content = this.getColoredTokens();
            }
            else {
                content = [{ value }];
            }
            return content;
        }
        getColoredTokens() {
            const tokens = this.getters.getCurrentTokens();
            const tokenAtCursor = this.getters.getTokenAtCursor();
            const result = [];
            const { end } = this.getters.getComposerSelection();
            for (let token of tokens) {
                switch (token.type) {
                    case "OPERATOR":
                    case "NUMBER":
                    case "FUNCTION":
                    case "COMMA":
                    case "STRING":
                        result.push({ value: token.value, color: tokenColor[token.type] || "#000" });
                        break;
                    case "SYMBOL":
                        let value = token.value;
                        const [xc, sheet] = value.split("!").reverse();
                        if (rangeReference.test(xc)) {
                            result.push({ value: token.value, color: this.rangeColor(xc, sheet) || "#000" });
                        }
                        else if (["TRUE", "FALSE"].includes(value.toUpperCase())) {
                            result.push({ value: token.value, color: NumberColor });
                        }
                        else {
                            result.push({ value: token.value, color: "#000" });
                        }
                        break;
                    case "LEFT_PAREN":
                    case "RIGHT_PAREN":
                        // Compute the matching parenthesis
                        if (tokenAtCursor &&
                            ["LEFT_PAREN", "RIGHT_PAREN"].includes(tokenAtCursor.type) &&
                            tokenAtCursor.parenIndex &&
                            tokenAtCursor.parenIndex === token.parenIndex) {
                            result.push({ value: token.value, color: MatchingParenColor  });
                        }
                        else {
                            result.push({ value: token.value, color: tokenColor[token.type] || "#000" });
                        }
                        break;
                    default:
                        result.push({ value: token.value, color: "#000" });
                        break;
                }
                // Note: mode === waitingForRangeSelection implies end === start
                if (this.getters.getEditionMode() === "waitingForRangeSelection" && end === token.end) {
                    result[result.length - 1].class = SelectionIndicatorClass;
                }
            }
            return result;
        }
        rangeColor(xc, sheetName) {
            if (this.getters.getEditionMode() === "inactive") {
                return undefined;
            }
            const highlights = this.getters.getHighlights();
            const refSheet = sheetName
                ? this.getters.getSheetIdByName(sheetName)
                : this.getters.getEditionSheet();
            const highlight = highlights.find((highlight) => {
                if (highlight.sheet !== refSheet)
                    return false;
                let zone = toZone(xc);
                const { height, width } = zoneToDimension(zone);
                zone = height * width === 1 ? this.getters.expandZone(refSheet, toZone(xc)) : zone;
                return highlight.sheet === refSheet && isEqual(zone, highlight.zone);
            });
            return highlight && highlight.color ? highlight.color : undefined;
        }
        /**
         * Compute the state of the composer from the tokenAtCursor.
         * If the token is a function or symbol (that isn't a cell/range reference) we have to initialize
         * the autocomplete engine otherwise we initialize the formula assistant.
         */
        processTokenAtCursor() {
            let content = this.getters.getCurrentContent();
            this.autoCompleteState.showProvider = false;
            this.functionDescriptionState.showDescription = false;
            if (content.startsWith("=")) {
                const tokenAtCursor = this.getters.getTokenAtCursor();
                if (tokenAtCursor) {
                    const [xc] = tokenAtCursor.value.split("!").reverse();
                    if (tokenAtCursor.type === "FUNCTION" ||
                        (tokenAtCursor.type === "SYMBOL" && !rangeReference.test(xc))) {
                        // initialize Autocomplete Dropdown
                        this.autoCompleteState.search = tokenAtCursor.value;
                        this.autoCompleteState.showProvider = true;
                    }
                    else if (tokenAtCursor.functionContext && tokenAtCursor.type !== "UNKNOWN") {
                        // initialize Formula Assistant
                        const tokenContext = tokenAtCursor.functionContext;
                        const parentFunction = tokenContext.parent.toUpperCase();
                        const description = functions[parentFunction];
                        const argPosition = tokenContext.argPosition;
                        this.functionDescriptionState.functionName = parentFunction;
                        this.functionDescriptionState.functionDescription = description;
                        this.functionDescriptionState.argToFocus = description.getArgToFocus(argPosition + 1) - 1;
                        this.functionDescriptionState.showDescription = true;
                    }
                }
            }
        }
        autoComplete(value) {
            if (value) {
                const tokenAtCursor = this.getters.getTokenAtCursor();
                if (tokenAtCursor) {
                    let start = tokenAtCursor.end;
                    let end = tokenAtCursor.end;
                    if (["SYMBOL", "FUNCTION"].includes(tokenAtCursor.type)) {
                        start = tokenAtCursor.start;
                    }
                    const tokens = this.getters.getCurrentTokens();
                    if (this.autoCompleteState.provider && tokens.length) {
                        value += "(";
                        const currentTokenIndex = tokens.map((token) => token.start).indexOf(tokenAtCursor.start);
                        if (currentTokenIndex + 1 < tokens.length) {
                            const nextToken = tokens[currentTokenIndex + 1];
                            if (nextToken.type === "LEFT_PAREN") {
                                end++;
                            }
                        }
                    }
                    this.dispatch("CHANGE_COMPOSER_CURSOR_SELECTION", {
                        start,
                        end,
                    });
                }
                this.dispatch("REPLACE_COMPOSER_CURSOR_SELECTION", {
                    text: value,
                });
            }
            this.processTokenAtCursor();
        }
    }
    Composer.template = TEMPLATE$c;
    Composer.style = CSS$b;
    Composer.components = { TextValueProvider, FunctionDescriptionProvider };
    Composer.defaultProps = {
        inputStyle: "",
        focus: "inactive",
    };

    const { Component: Component$b } = owl__namespace;
    const { useState: useState$8 } = owl__namespace.hooks;
    const { xml: xml$d, css: css$c } = owl__namespace.tags;
    const SCROLLBAR_WIDTH = 14;
    const SCROLLBAR_HIGHT = 15;
    const TEMPLATE$b = xml$d /* xml */ `
  <div class="o-grid-composer" t-att-style="containerStyle">
    <Composer
      focus = "props.focus"
      inputStyle = "composerStyle"
      rect = "composerState.rect"
      delimitation = "composerState.delimitation"
      t-on-keydown = "onKeydown"
    />
  </div>
`;
    const COMPOSER_BORDER_WIDTH = 3 * 0.4 * window.devicePixelRatio || 1;
    const CSS$a = css$c /* scss */ `
  .o-grid-composer {
    z-index: 5;
    box-sizing: border-box;
    position: absolute;
    border: ${COMPOSER_BORDER_WIDTH}px solid ${SELECTION_BORDER_COLOR};
  }
`;
    /**
     * This component is a composer which positions itself on the grid at the anchor cell.
     * It also applies the style of the cell to the composer input.
     */
    class GridComposer extends Component$b {
        constructor() {
            super(...arguments);
            this.getters = this.env.getters;
            this.composerState = useState$8({
                rect: null,
                delimitation: null,
            });
            const [col, row] = this.getters.getPosition();
            this.zone = this.getters.expandZone(this.getters.getActiveSheetId(), {
                left: col,
                right: col,
                top: row,
                bottom: row,
            });
            this.rect = this.getters.getRect(this.zone, this.getters.getActiveSnappedViewport());
        }
        get containerStyle() {
            const isFormula = this.getters.getCurrentContent().startsWith("=");
            const style = this.getters.getCurrentStyle();
            // position style
            const [left, top, width, height] = this.rect;
            // color style
            const background = (!isFormula && style.fillColor) || "#ffffff";
            const color = (!isFormula && style.textColor) || "#000000";
            // font style
            const fontSize = (!isFormula && style.fontSize) || 10;
            const fontWeight = !isFormula && style.bold ? "bold" : 500;
            const fontStyle = !isFormula && style.italic ? "italic" : "normal";
            const textDecoration = !isFormula ? getTextDecoration(style) : "none";
            // align style
            let textAlign = "left";
            if (!isFormula) {
                const cell = this.getters.getActiveCell();
                textAlign = style.align || (cell === null || cell === void 0 ? void 0 : cell.defaultAlign) || "left";
            }
            return `
      left: ${left - 1}px;
      top: ${top}px;
      min-width: ${width + 2}px;
      min-height: ${height + 1}px;

      background: ${background};
      color: ${color};

      font-size: ${fontSizeMap[fontSize]}px;
      font-weight: ${fontWeight};
      font-style: ${fontStyle};
      text-decoration: ${textDecoration};

      text-align: ${textAlign};
    `;
        }
        get composerStyle() {
            return `
      line-height: ${DEFAULT_CELL_HEIGHT}px;
      max-height: inherit;
      overflow: hidden;
    `;
        }
        mounted() {
            const el = this.el;
            const maxHeight = el.parentElement.clientHeight - this.rect[1] - SCROLLBAR_HIGHT;
            el.style.maxHeight = (maxHeight + "px");
            const maxWidth = el.parentElement.clientWidth - this.rect[0] - SCROLLBAR_WIDTH;
            el.style.maxWidth = (maxWidth + "px");
            this.composerState.rect = [this.rect[0], this.rect[1], el.clientWidth, el.clientHeight];
            this.composerState.delimitation = {
                width: el.parentElement.clientWidth,
                height: el.parentElement.clientHeight,
            };
        }
        onKeydown(ev) {
            // In selecting mode, arrows should not move the cursor but it should
            // select adjacent cells on the grid.
            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(ev.key)) {
                ev.preventDefault();
            }
        }
    }
    GridComposer.template = TEMPLATE$b;
    GridComposer.style = CSS$a;
    GridComposer.components = { Composer };

    const { Component: Component$a, tags: tags$2 } = owl__namespace;
    const { xml: xml$c, css: css$b } = tags$2;
    const TEMPLATE$a = xml$c /* xml */ `
    <div class="o-error-tooltip"> 
      <t t-esc="props.text"/>
    </div>
`;
    const CSS$9 = css$b /* scss */ `
  .o-error-tooltip {
    font-size: 13px;
    background-color: white;
    border-left: 3px solid red;
    padding: 10px;
  }
`;
    class ErrorToolTip extends Component$a {
    }
    ErrorToolTip.template = TEMPLATE$a;
    ErrorToolTip.style = CSS$9;

    const { useState: useState$7 } = owl__namespace;
    const { xml: xml$b, css: css$a } = owl.tags;
    const { useRef: useRef$4 } = owl.hooks;
    const TEMPLATE$9 = xml$b /* xml */ `
<div class="o-chart-container">
  <div class="o-chart-menu" t-on-click="showMenu">${LIST}</div>
  <canvas t-att-style="canvasStyle" t-ref="graphContainer"/>
  <Menu t-if="menuState.isOpen"
    position="menuState.position"
    menuItems="menuState.menuItems"
    t-on-close="menuState.isOpen=false"/>
</div>`;
    // -----------------------------------------------------------------------------
    // STYLE
    // -----------------------------------------------------------------------------
    const CSS$8 = css$a /* scss */ `
  .o-chart-container {
    width: 100%;
    height: 100%;
    position: relative;

    .o-chart-menu {
      right: 0px;
      display: none;
      position: absolute;
      padding: 5px;
      cursor: pointer;
    }
  }
  .o-figure.active:focus {
    .o-chart-container {
      .o-chart-menu {
        display: flex;
      }
    }
  }
`;
    class ChartFigure extends owl.Component {
        constructor() {
            super(...arguments);
            this.menuState = useState$7({ isOpen: false, position: null, menuItems: [] });
            this.canvas = useRef$4("graphContainer");
            this.state = { background: BACKGROUND_CHART_COLOR };
            this.position = useAbsolutePosition();
        }
        get canvasStyle() {
            return `background-color: ${this.state.background}`;
        }
        mounted() {
            const figure = this.props.figure;
            const chartData = this.env.getters.getChartRuntime(figure.id);
            if (chartData) {
                this.createChart(chartData);
            }
        }
        patched() {
            var _a, _b, _c;
            const figure = this.props.figure;
            const chartData = this.env.getters.getChartRuntime(figure.id);
            if (chartData) {
                if (chartData.type !== this.chart.config.type) {
                    // Updating a chart type requires to update its options accordingly, if feasible at all.
                    // Since we trust Chart.js to generate most of its options, it is safer to just start from scratch.
                    // See https://www.chartjs.org/docs/latest/developers/updates.html
                    // and https://stackoverflow.com/questions/36949343/chart-js-dynamic-changing-of-chart-type-line-to-bar-as-example
                    this.chart && this.chart.destroy();
                    this.createChart(chartData);
                }
                else if (chartData.data && chartData.data.datasets) {
                    this.chart.data = chartData.data;
                    if ((_a = chartData.options) === null || _a === void 0 ? void 0 : _a.title) {
                        this.chart.config.options.title = chartData.options.title;
                    }
                }
                else {
                    this.chart.data.datasets = undefined;
                }
                this.chart.config.options.legend = (_b = chartData.options) === null || _b === void 0 ? void 0 : _b.legend;
                this.chart.config.options.scales = (_c = chartData.options) === null || _c === void 0 ? void 0 : _c.scales;
                this.chart.update({ duration: 0 });
            }
            else {
                this.chart && this.chart.destroy();
            }
            const def = this.env.getters.getChartDefinition(figure.id);
            if (def) {
                this.state.background = def.background;
            }
        }
        createChart(chartData) {
            const canvas = this.canvas.el;
            const ctx = canvas.getContext("2d");
            this.chart = new window.Chart(ctx, chartData);
            const def = this.env.getters.getChartDefinition(this.props.figure.id);
            if (def) {
                this.state.background = def.background;
            }
        }
        showMenu(ev) {
            const registry = new MenuItemRegistry();
            registry.add("edit", {
                name: _lt("Edit"),
                sequence: 1,
                action: () => this.env.openSidePanel("ChartPanel", { figure: this.props.figure }),
            });
            registry.add("delete", {
                name: _lt("Delete"),
                sequence: 10,
                action: () => {
                    this.env.dispatch("DELETE_FIGURE", {
                        sheetId: this.env.getters.getActiveSheetId(),
                        id: this.props.figure.id,
                    });
                    if (this.props.sidePanelIsOpen) {
                        this.env.toggleSidePanel("ChartPanel", { figure: this.props.figure });
                    }
                    this.trigger("figure-deleted");
                },
            });
            registry.add("refresh", {
                name: _lt("Refresh"),
                sequence: 11,
                action: () => {
                    this.env.dispatch("REFRESH_CHART", {
                        id: this.props.figure.id,
                    });
                },
            });
            this.openContextMenu(ev.currentTarget, registry);
        }
        openContextMenu(target, registry) {
            const x = target.offsetLeft;
            const y = target.offsetTop;
            this.menuState.isOpen = true;
            this.menuState.menuItems = registry.getAll().filter((x) => x.isVisible(this.env));
            this.menuState.position = {
                x: this.position.x + x - MENU_WIDTH,
                y: this.position.y + y,
            };
        }
    }
    ChartFigure.template = TEMPLATE$9;
    ChartFigure.style = CSS$8;
    ChartFigure.components = { Menu };

    const { xml: xml$a, css: css$9 } = owl__namespace.tags;
    const { useState: useState$6 } = owl__namespace;
    const TEMPLATE$8 = xml$a /* xml */ `<div>
    <t t-foreach="getVisibleFigures()" t-as="info" t-key="info.id">
        <div class="o-figure-wrapper"
             t-att-style="getStyle(info)"
             t-on-mousedown="onMouseDown(info.figure)"
             >
            <div class="o-figure"
                 t-att-class="{active: info.isSelected, 'o-dragging': info.id === dnd.figureId}"
                 t-att-style="getDims(info)"
                 tabindex="0"
                 t-on-keydown.stop="onKeyDown(info.figure)"
                 t-on-keyup.stop="">
                <t t-component="figureRegistry.get(info.figure.tag).Component"
                   t-key="info.id"
                   sidePanelIsOpen="props.sidePanelIsOpen"
                   figure="info.figure"/>
                <t t-if="info.isSelected">
                    <div class="o-anchor o-top" t-on-mousedown.stop="resize(info.figure, 0,-1)"/>
                    <div class="o-anchor o-topRight" t-on-mousedown.stop="resize(info.figure, 1,-1)"/>
                    <div class="o-anchor o-right" t-on-mousedown.stop="resize(info.figure, 1,0)"/>
                    <div class="o-anchor o-bottomRight" t-on-mousedown.stop="resize(info.figure, 1,1)"/>
                    <div class="o-anchor o-bottom" t-on-mousedown.stop="resize(info.figure, 0,1)"/>
                    <div class="o-anchor o-bottomLeft" t-on-mousedown.stop="resize(info.figure, -1,1)"/>
                    <div class="o-anchor o-left" t-on-mousedown.stop="resize(info.figure, -1,0)"/>
                    <div class="o-anchor o-topLeft" t-on-mousedown.stop="resize(info.figure, -1,-1)"/>
                </t>
            </div>
        </div>
    </t>
</div>
`;
    // -----------------------------------------------------------------------------
    // STYLE
    // -----------------------------------------------------------------------------
    const ANCHOR_SIZE = 8;
    const BORDER_WIDTH = 1;
    const ACTIVE_BORDER_WIDTH = 2;
    const MIN_FIG_SIZE = 80;
    const CSS$7 = css$9 /*SCSS*/ `
  .o-figure-wrapper {
    overflow: hidden;
  }

  .o-figure {
    border: 1px solid black;
    box-sizing: border-box;
    position: absolute;
    bottom: 3px;
    right: 3px;
    &:focus {
      outline: none;
    }
    &.active {
      border: ${ACTIVE_BORDER_WIDTH}px solid ${SELECTION_BORDER_COLOR};
      z-index: 1;
    }

    &.o-dragging {
      opacity: 0.9;
      cursor: grabbing;
    }

    .o-anchor {
      z-index: 1000;
      position: absolute;
      outline: ${BORDER_WIDTH}px solid white;
      width: ${ANCHOR_SIZE}px;
      height: ${ANCHOR_SIZE}px;
      background-color: #1a73e8;
      &.o-top {
        top: -${ANCHOR_SIZE / 2}px;
        right: calc(50% - 4px);
        cursor: n-resize;
      }
      &.o-topRight {
        top: -${ANCHOR_SIZE / 2}px;
        right: -${ANCHOR_SIZE / 2}px;
        cursor: ne-resize;
      }
      &.o-right {
        right: -${ANCHOR_SIZE / 2}px;
        top: calc(50% - 4px);
        cursor: e-resize;
      }
      &.o-bottomRight {
        bottom: -${ANCHOR_SIZE / 2}px;
        right: -${ANCHOR_SIZE / 2}px;
        cursor: se-resize;
      }
      &.o-bottom {
        bottom: -${ANCHOR_SIZE / 2}px;
        right: calc(50% - 4px);
        cursor: s-resize;
      }
      &.o-bottomLeft {
        bottom: -${ANCHOR_SIZE / 2}px;
        left: -${ANCHOR_SIZE / 2}px;
        cursor: sw-resize;
      }
      &.o-left {
        bottom: calc(50% - 4px);
        left: -${ANCHOR_SIZE / 2}px;
        cursor: w-resize;
      }
      &.o-topLeft {
        top: -${ANCHOR_SIZE / 2}px;
        left: -${ANCHOR_SIZE / 2}px;
        cursor: nw-resize;
      }
    }
  }
`;
    class FiguresContainer extends owl.Component {
        constructor() {
            super(...arguments);
            this.figureRegistry = figureRegistry;
            this.dnd = useState$6({
                figureId: "",
                x: 0,
                y: 0,
                width: 0,
                height: 0,
            });
            this.getters = this.env.getters;
            this.dispatch = this.env.dispatch;
        }
        getVisibleFigures() {
            const selectedId = this.getters.getSelectedFigureId();
            return this.getters.getVisibleFigures(this.getters.getActiveSheetId()).map((f) => ({
                id: f.id,
                isSelected: f.id === selectedId,
                figure: f,
            }));
        }
        getDims(info) {
            const { figure, isSelected } = info;
            const borders = 2 * (isSelected ? ACTIVE_BORDER_WIDTH : BORDER_WIDTH);
            const { width, height } = isSelected && this.dnd.figureId ? this.dnd : figure;
            return `width:${width + borders}px;height:${height + borders}px`;
        }
        getStyle(info) {
            const { figure, isSelected } = info;
            const { offsetX, offsetY } = this.getters.getActiveSnappedViewport();
            const target = figure.id === (isSelected && this.dnd.figureId) ? this.dnd : figure;
            const { width, height } = target;
            let x = target.x - offsetX + HEADER_WIDTH - 1;
            let y = target.y - offsetY + HEADER_HEIGHT - 1;
            // width and height of wrapper need to be adjusted so we do not overlap
            // with headers
            const correctionX = Math.max(0, HEADER_WIDTH - x);
            x += correctionX;
            const correctionY = Math.max(0, HEADER_HEIGHT - y);
            y += correctionY;
            if (width < 0 || height < 0) {
                return `position:absolute;display:none;`;
            }
            const offset = ANCHOR_SIZE + ACTIVE_BORDER_WIDTH + (isSelected ? ACTIVE_BORDER_WIDTH : BORDER_WIDTH);
            return `position:absolute; top:${y + 1}px; left:${x + 1}px; width:${width - correctionX + offset}px; height:${height - correctionY + offset}px`;
        }
        mounted() {
            // horrible, but necessary
            // the following line ensures that we render the figures with the correct
            // viewport.  The reason is that whenever we initialize the grid
            // component, we do not know yet the actual size of the viewport, so the
            // first owl rendering is done with an empty viewport.  Only then we can
            // compute which figures should be displayed, so we have to force a
            // new rendering
            this.render();
        }
        resize(figure, dirX, dirY, ev) {
            ev.stopPropagation();
            const initialX = ev.clientX;
            const initialY = ev.clientY;
            this.dnd.figureId = figure.id;
            this.dnd.x = figure.x;
            this.dnd.y = figure.y;
            this.dnd.width = figure.width;
            this.dnd.height = figure.height;
            const onMouseMove = (ev) => {
                const deltaX = dirX * (ev.clientX - initialX);
                const deltaY = dirY * (ev.clientY - initialY);
                this.dnd.width = Math.max(figure.width + deltaX, MIN_FIG_SIZE);
                this.dnd.height = Math.max(figure.height + deltaY, MIN_FIG_SIZE);
                if (dirX < 0) {
                    this.dnd.x = figure.x - deltaX;
                }
                if (dirY < 0) {
                    this.dnd.y = figure.y - deltaY;
                }
            };
            const onMouseUp = (ev) => {
                this.dnd.figureId = "";
                const update = {
                    x: this.dnd.x,
                    y: this.dnd.y,
                };
                if (dirX) {
                    update.width = this.dnd.width;
                }
                if (dirY) {
                    update.height = this.dnd.height;
                }
                this.dispatch("UPDATE_FIGURE", {
                    sheetId: this.getters.getActiveSheetId(),
                    id: figure.id,
                    ...update,
                });
            };
            startDnd(onMouseMove, onMouseUp);
        }
        onMouseDown(figure, ev) {
            if (ev.button > 0) {
                // not main button, probably a context menu
                return;
            }
            const selectResult = this.dispatch("SELECT_FIGURE", { id: figure.id });
            if (!selectResult.isSuccessful) {
                return;
            }
            if (this.props.sidePanelIsOpen) {
                this.env.openSidePanel("ChartPanel", { figure });
            }
            const initialX = ev.clientX;
            const initialY = ev.clientY;
            this.dnd.figureId = figure.id;
            this.dnd.x = figure.x;
            this.dnd.y = figure.y;
            this.dnd.width = figure.width;
            this.dnd.height = figure.height;
            const onMouseMove = (ev) => {
                this.dnd.x = Math.max(figure.x - initialX + ev.clientX, 0);
                this.dnd.y = Math.max(figure.y - initialY + ev.clientY, 0);
            };
            const onMouseUp = (ev) => {
                this.dnd.figureId = "";
                this.dispatch("UPDATE_FIGURE", {
                    sheetId: this.getters.getActiveSheetId(),
                    id: figure.id,
                    x: this.dnd.x,
                    y: this.dnd.y,
                });
            };
            startDnd(onMouseMove, onMouseUp);
        }
        onKeyDown(figure, ev) {
            ev.preventDefault();
            switch (ev.key) {
                case "Delete":
                    this.dispatch("DELETE_FIGURE", { sheetId: this.getters.getActiveSheetId(), id: figure.id });
                    this.trigger("figure-deleted");
                    break;
                case "ArrowDown":
                case "ArrowLeft":
                case "ArrowRight":
                case "ArrowUp":
                    const deltaMap = {
                        ArrowDown: [0, 1],
                        ArrowLeft: [-1, 0],
                        ArrowRight: [1, 0],
                        ArrowUp: [0, -1],
                    };
                    const delta = deltaMap[ev.key];
                    this.dispatch("UPDATE_FIGURE", {
                        sheetId: this.getters.getActiveSheetId(),
                        id: figure.id,
                        x: figure.x + delta[0],
                        y: figure.y + delta[1],
                    });
            }
        }
    }
    FiguresContainer.template = TEMPLATE$8;
    FiguresContainer.style = CSS$7;
    FiguresContainer.components = {};
    figureRegistry.add("chart", { Component: ChartFigure, SidePanelComponent: "ChartPanel" });

    const { Component: Component$9 } = owl__namespace;
    const { xml: xml$9, css: css$8 } = owl__namespace.tags;
    const TEMPLATE$7 = xml$9 /* xml */ `
    <div class="o-border"
        t-on-mousedown="onMouseDown"
        t-att-style="style"
        t-att-class="{
          'o-moving': props.isMoving,
          'o-border-n': props.orientation === 'n',
          'o-border-s': props.orientation === 's',
          'o-border-w': props.orientation === 'w',
          'o-border-e': props.orientation === 'e',
        }"
        >
    </div>
`;
    const CSS$6 = css$8 /* scss */ `
  .o-border {
    position: absolute;
    &:hover {
      cursor: grab;
    }
  }
  }
  .o-moving {
    cursor: grabbing;
  }
`;
    class Border extends Component$9 {
        get style() {
            const isTop = ["n", "w", "e"].includes(this.props.orientation);
            const isLeft = ["n", "w", "s"].includes(this.props.orientation);
            const isHorizontal = ["n", "s"].includes(this.props.orientation);
            const isVertical = ["w", "e"].includes(this.props.orientation);
            const s = this.env.getters.getActiveSheet();
            const z = this.props.zone;
            const margin = 2;
            const left = s.cols[z.left].start + margin;
            const right = s.cols[z.right].end - 2 * margin;
            const top = s.rows[z.top].start + margin;
            const bottom = s.rows[z.bottom].end - 2 * margin;
            const lineWidth = 4;
            const leftValue = isLeft ? left : right;
            const topValue = isTop ? top : bottom;
            const widthValue = isHorizontal ? right - left : lineWidth;
            const heightValue = isVertical ? bottom - top : lineWidth;
            const { offsetX, offsetY } = this.env.getters.getActiveSnappedViewport();
            return `
        left:${leftValue + HEADER_WIDTH - offsetX}px;
        top:${topValue + HEADER_HEIGHT - offsetY}px;
        width:${widthValue}px;
        height:${heightValue}px;
    `;
        }
        onMouseDown(ev) {
            this.trigger("move-highlight", { clientX: ev.clientX, clientY: ev.clientY });
        }
    }
    Border.template = TEMPLATE$7;
    Border.style = CSS$6;

    const { Component: Component$8 } = owl__namespace;
    const { xml: xml$8, css: css$7 } = owl__namespace.tags;
    const TEMPLATE$6 = xml$8 /* xml */ `
    <div class="o-corner"
        t-on-mousedown="onMouseDown"
        t-att-style="style"
        t-att-class="{
          'o-resizing': props.isResizing,
          'o-corner-nw': props.orientation === 'nw',
          'o-corner-ne': props.orientation === 'ne',
          'o-corner-sw': props.orientation === 'sw',
          'o-corner-se': props.orientation === 'se',
        }"
        >
    </div>
`;
    const CSS$5 = css$7 /* scss */ `
  .o-corner {
    position: absolute;
    height: 6px;
    width: 6px;
    border: 1px solid white;
  }
  .o-corner-nw,
  .o-corner-se {
    &:hover {
      cursor: nwse-resize;
    }
  }
  .o-corner-ne,
  .o-corner-sw {
    &:hover {
      cursor: nesw-resize;
    }
  }
  .o-resizing {
    cursor: grabbing;
  }
`;
    class Corner extends Component$8 {
        constructor() {
            super(...arguments);
            this.isTop = this.props.orientation[0] === "n";
            this.isLeft = this.props.orientation[1] === "w";
        }
        get style() {
            const { offsetX, offsetY } = this.env.getters.getActiveSnappedViewport();
            const s = this.env.getters.getActiveSheet();
            const z = this.props.zone;
            const leftValue = this.isLeft ? s.cols[z.left].start : s.cols[z.right].end;
            const topValue = this.isTop ? s.rows[z.top].start : s.rows[z.bottom].end;
            return `
      left:${leftValue + HEADER_WIDTH - offsetX - AUTOFILL_EDGE_LENGTH / 2}px;
      top:${topValue + HEADER_HEIGHT - offsetY - AUTOFILL_EDGE_LENGTH / 2}px;
      background-color:${this.props.color};
    `;
        }
        onMouseDown(ev) {
            this.trigger("resize-highlight", { isLeft: this.isLeft, isTop: this.isTop });
        }
    }
    Corner.template = TEMPLATE$6;
    Corner.style = CSS$5;

    const { Component: Component$7 } = owl__namespace;
    const { xml: xml$7 } = owl__namespace.tags;
    const TEMPLATE$5 = xml$7 /* xml */ `
  <div class="o-highlight">
    <t t-foreach="['nw', 'ne', 'sw', 'se']" t-as="orientation" t-key="orientation">
      <Corner
        t-on-resize-highlight="onResizeHighlight"
        isResizing='highlightState.shiftingMode === "isResizing"'
        orientation="orientation"
        zone="props.zone"
        color="props.color"
      />
    </t>
    <t t-foreach="['n', 's', 'w', 'e']" t-as="orientation" t-key="orientation">
      <Border
        t-on-move-highlight="onMoveHighlight"
        isMoving='highlightState.shiftingMode === "isMoving"'
        orientation="orientation"
        zone="props.zone"
      />
    </t>
  </div>
`;
    class Highlight extends Component$7 {
        constructor() {
            super(...arguments);
            this.highlightState = owl.useState({
                shiftingMode: "none",
            });
        }
        onResizeHighlight(ev) {
            this.highlightState.shiftingMode = "isResizing";
            const z = this.props.zone;
            const pivotCol = ev.detail.isLeft ? z.right : z.left;
            const pivotRow = ev.detail.isTop ? z.bottom : z.top;
            let lastCol = ev.detail.isLeft ? z.left : z.right;
            let lastRow = ev.detail.isTop ? z.top : z.bottom;
            let currentZone = z;
            this.env.dispatch("START_CHANGE_HIGHLIGHT", { zone: currentZone });
            const mouseMove = (col, row) => {
                if (lastCol !== col || lastRow !== row) {
                    const activeSheet = this.env.getters.getActiveSheet();
                    lastCol = clip(col === -1 ? lastCol : col, 0, activeSheet.cols.length - 1);
                    lastRow = clip(row === -1 ? lastRow : row, 0, activeSheet.rows.length - 1);
                    let newZone = {
                        left: Math.min(pivotCol, lastCol),
                        top: Math.min(pivotRow, lastRow),
                        right: Math.max(pivotCol, lastCol),
                        bottom: Math.max(pivotRow, lastRow),
                    };
                    newZone = this.env.getters.expandZone(activeSheet.id, newZone);
                    if (!isEqual(newZone, currentZone)) {
                        this.env.dispatch("CHANGE_HIGHLIGHT", { zone: newZone });
                        currentZone = newZone;
                    }
                }
            };
            const mouseUp = () => {
                this.highlightState.shiftingMode = "none";
                // To do:
                // Command used here to restore focus to the current composer,
                // to be changed when refactoring the 'edition' plugin
                this.env.dispatch("STOP_COMPOSER_RANGE_SELECTION");
            };
            dragAndDropBeyondTheViewport(this.el.parentElement, this.env, mouseMove, mouseUp);
        }
        onMoveHighlight(ev) {
            this.highlightState.shiftingMode = "isMoving";
            const z = this.props.zone;
            const parent = this.el.parentElement;
            const position = parent.getBoundingClientRect();
            const activeSheet = this.env.getters.getActiveSheet();
            const { top: viewportTop, left: viewportLeft } = this.env.getters.getActiveSnappedViewport();
            const initCol = this.env.getters.getColIndex(ev.detail.clientX - position.left, viewportLeft);
            const initRow = this.env.getters.getRowIndex(ev.detail.clientY - position.top, viewportTop);
            const deltaColMin = -z.left;
            const deltaColMax = activeSheet.cols.length - z.right - 1;
            const deltaRowMin = -z.top;
            const deltaRowMax = activeSheet.rows.length - z.bottom - 1;
            let currentZone = z;
            this.env.dispatch("START_CHANGE_HIGHLIGHT", { zone: currentZone });
            let lastCol = initCol;
            let lastRow = initRow;
            const mouseMove = (col, row) => {
                if (lastCol !== col || lastRow !== row) {
                    lastCol = col === -1 ? lastCol : col;
                    lastRow = row === -1 ? lastRow : row;
                    const deltaCol = clip(lastCol - initCol, deltaColMin, deltaColMax);
                    const deltaRow = clip(lastRow - initRow, deltaRowMin, deltaRowMax);
                    let newZone = {
                        left: z.left + deltaCol,
                        top: z.top + deltaRow,
                        right: z.right + deltaCol,
                        bottom: z.bottom + deltaRow,
                    };
                    newZone = this.env.getters.expandZone(activeSheet.id, newZone);
                    if (!isEqual(newZone, currentZone)) {
                        this.env.dispatch("CHANGE_HIGHLIGHT", { zone: newZone });
                        currentZone = newZone;
                    }
                }
            };
            const mouseUp = () => {
                this.highlightState.shiftingMode = "none";
                // To do:
                // Command used here to restore focus to the current composer,
                // to be changed when refactoring the 'edition' plugin
                this.env.dispatch("STOP_COMPOSER_RANGE_SELECTION");
            };
            dragAndDropBeyondTheViewport(parent, this.env, mouseMove, mouseUp);
        }
    }
    Highlight.template = TEMPLATE$5;
    Highlight.components = {
        Corner,
        Border,
    };

    const { Component: Component$6, tags: tags$1 } = owl__namespace;
    const { xml: xml$6, css: css$6 } = tags$1;
    const TEMPLATE$4 = xml$6 /* xml */ `
  <div class="o-link-tool">
    <t t-set="link" t-value="cell.link"/>
    <a t-if="link.isExternal"
      class="o-link"
      t-att-href="link.url"
      target="_blank"
      t-on-click.prevent="openLink"
      t-att-title="link.url">
      <t t-esc="cell.urlRepresentation"/>
    </a>
    <a t-else=""
      class="o-link"
      t-on-click.prevent="openLink"
      t-att-title="cell.urlRepresentation">
      <t t-esc="cell.urlRepresentation"/>
    </a>
    <span class="o-link-icon o-unlink" t-on-click="unlink" title="${LinkEditorTerms.Remove}">${UNLINK}</span>
    <span class="o-link-icon o-edit-link" t-on-click="edit" title="${LinkEditorTerms.Edit}">${EDIT}</span>
  </div>
`;
    const CSS$4 = css$6 /* scss */ `
  .o-link-tool {
    font-size: 13px;
    background-color: white;
    box-shadow: 0 1px 4px 3px rgba(60, 64, 67, 0.15);
    padding: 12px;
    border-radius: 4px;
    display: flex;
    justify-content: space-between;
    a.o-link {
      color: #007bff;
      flex-grow: 2;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    a.o-link:hover {
      text-decoration: underline;
      color: #0056b3;
      cursor: pointer;
    }
  }
  .o-link-icon {
    float: right;
    padding-left: 4%;
    .o-icon {
      height: 16px;
    }
  }
  .o-link-icon.o-unlink .o-icon {
    padding-top: 1px;
    height: 14px;
  }
  .o-link-icon:hover {
    cursor: pointer;
    color: #000;
  }
`;
    class LinkDisplay extends Component$6 {
        constructor() {
            super(...arguments);
            this.getters = this.env.getters;
        }
        get cell() {
            const { col, row } = this.props.cellPosition;
            const sheetId = this.getters.getActiveSheetId();
            const cell = this.getters.getCell(sheetId, col, row);
            if (cell === null || cell === void 0 ? void 0 : cell.isLink()) {
                return cell;
            }
            throw new Error(`LinkDisplay Component can only be used with link cells. ${toXC(col, row)} is not a link.`);
        }
        openLink() {
            this.cell.action(this.env);
        }
        edit() {
            this.env.openLinkEditor();
        }
        unlink() {
            const sheetId = this.getters.getActiveSheetId();
            const [col, row] = this.getters.getPosition();
            const [mainCol, mainRow] = this.getters.getMainCell(sheetId, col, row);
            const style = this.cell.style;
            const textColor = (style === null || style === void 0 ? void 0 : style.textColor) === LINK_COLOR ? undefined : style === null || style === void 0 ? void 0 : style.textColor;
            this.env.dispatch("UPDATE_CELL", {
                col: mainCol,
                row: mainRow,
                sheetId,
                content: this.cell.link.label,
                style: { ...style, textColor, underline: undefined },
            });
        }
    }
    LinkDisplay.template = TEMPLATE$4;
    LinkDisplay.components = { Menu };
    LinkDisplay.style = CSS$4;

    const { Component: Component$5, tags, hooks: hooks$1, useState: useState$5 } = owl__namespace;
    const { xml: xml$5, css: css$5 } = tags;
    const { useRef: useRef$3 } = hooks$1;
    const MENU_OFFSET_X = 320;
    const MENU_OFFSET_Y = 100;
    const PADDING = 12;
    const TEMPLATE$3 = xml$5 /* xml */ `
    <div class="o-link-editor" t-on-click.stop="menu.isOpen=false" t-on-keydown.stop="onKeyDown">
      <div class="o-section">
        <div t-esc="env._t('${LinkEditorTerms.Text}')" class="o-section-title"/>
        <div class="d-flex">
          <input type="text" class="o-input flex-grow-1" t-model="state.link.label"></input>
        </div>

        <div t-esc="env._t('${LinkEditorTerms.Link}')" class="o-section-title mt-3"/>
        <div class="o-link-url">
          <t t-if="state.isUrlEditable">
            <input type="text" t-ref="urlInput" t-model="state.link.url"></input>
          </t>
          <t t-else="">
            <input type="text" t-att-value="state.urlRepresentation" disabled="1"></input>
          </t>
          <button t-if="state.link.url" t-on-click="removeLink" class="o-remove-url">✖</button>
          <button t-if="!state.link.url" t-on-click.stop="openMenu" class="o-special-link">${LIST}</button>
        </div>
      </div>
      <Menu
        t-if="menu.isOpen"
        position="menuPosition"
        menuItems="menuItems"
        t-on-menu-clicked="onSpecialLink"
        t-on-close.stop="menu.isOpen=false"/>
      <div class="o-buttons">
        <button t-on-click="cancel" class="o-button o-cancel" t-esc="env._t('${LinkEditorTerms.Cancel}')"></button>
        <button t-on-click="save" class="o-button o-save" t-esc="env._t('${LinkEditorTerms.Confirm}')" t-att-disabled="!state.link.url" ></button>
      </div>
    </div>`;
    const CSS$3 = css$5 /* scss */ `
  .o-link-editor {
    font-size: 13px;
    background-color: white;
    box-shadow: 0 1px 4px 3px rgba(60, 64, 67, 0.15);
    padding: ${PADDING}px;
    display: flex;
    flex-direction: column;
    border-radius: 4px;
    .o-section {
      .o-section-title {
        font-weight: bold;
        color: dimgrey;
        margin-bottom: 5px;
      }
    }
    .o-buttons {
      padding-left: 16px;
      padding-top: 16px;
      padding-bottom: 16px;
      text-align: right;
      .o-button {
        border: 1px solid lightgrey;
        padding: 0px 20px 0px 20px;
        border-radius: 4px;
        font-weight: 500;
        font-size: 14px;
        height: 30px;
        line-height: 16px;
        background: white;
        margin-right: 8px;
        &:hover:enabled {
          background-color: rgba(0, 0, 0, 0.08);
        }
      }
      .o-button:enabled {
        cursor: pointer;
      }
      .o-button:last-child {
        margin-right: 0px;
      }
    }
    input {
      box-sizing: border-box;
      width: 100%;
      border-radius: 4px;
      padding: 4px 23px 4px 10px;
      border: none;
      height: 24px;
      border: 1px solid lightgrey;
    }
    .o-link-url {
      position: relative;
      flex-grow: 1;
      button {
        position: absolute;
        right: 0px;
        top: 0px;
        border: none;
        height: 20px;
        width: 20px;
        background-color: #fff;
        margin: 2px 3px 1px 0px;
        padding: 0px 1px 0px 0px;
      }
      button:hover {
        cursor: pointer;
      }
    }
  }
`;
    class LinkEditor extends Component$5 {
        constructor() {
            super(...arguments);
            this.menuItems = linkMenuRegistry.getAll();
            this.getters = this.env.getters;
            this.state = useState$5(this.defaultState);
            this.menu = useState$5({
                isOpen: false,
            });
            this.position = useAbsolutePosition();
            this.urlInput = useRef$3("urlInput");
        }
        mounted() {
            var _a;
            (_a = this.urlInput.el) === null || _a === void 0 ? void 0 : _a.focus();
        }
        get defaultState() {
            const { col, row } = this.props.cellPosition;
            const sheetId = this.getters.getActiveSheetId();
            const cell = this.getters.getCell(sheetId, col, row);
            if (cell === null || cell === void 0 ? void 0 : cell.isLink()) {
                return {
                    link: { url: cell.link.url, label: cell.formattedValue },
                    urlRepresentation: cell.urlRepresentation,
                    isUrlEditable: cell.isUrlEditable,
                };
            }
            return {
                link: { url: "", label: (cell === null || cell === void 0 ? void 0 : cell.formattedValue) || "" },
                isUrlEditable: true,
                urlRepresentation: "",
            };
        }
        get menuPosition() {
            return {
                x: this.position.x + MENU_OFFSET_X - PADDING - 2,
                y: this.position.y + MENU_OFFSET_Y,
            };
        }
        onSpecialLink(ev) {
            const { detail } = ev;
            this.state.link.url = detail.link.url;
            this.state.link.label = detail.link.label;
            this.state.isUrlEditable = detail.isUrlEditable;
            this.state.urlRepresentation = detail.urlRepresentation;
        }
        openMenu() {
            this.menu.isOpen = true;
        }
        removeLink() {
            this.state.link.url = "";
            this.state.urlRepresentation = "";
            this.state.isUrlEditable = true;
        }
        save() {
            const { col, row } = this.props.cellPosition;
            const label = this.state.link.label || this.state.link.url;
            this.env.dispatch("UPDATE_CELL", {
                col: col,
                row: row,
                sheetId: this.getters.getActiveSheetId(),
                content: markdownLink(label, this.state.link.url),
            });
            this.trigger("link-editor-closed");
        }
        cancel() {
            this.trigger("link-editor-closed");
        }
        onKeyDown(ev) {
            switch (ev.key) {
                case "Enter":
                    if (this.state.link.url) {
                        this.save();
                    }
                    break;
                case "Escape":
                    this.cancel();
                    break;
            }
        }
    }
    LinkEditor.template = TEMPLATE$3;
    LinkEditor.components = { Menu };
    LinkEditor.style = CSS$3;

    const { Component: Component$4 } = owl__namespace;
    const { xml: xml$4, css: css$4 } = owl__namespace.tags;
    const { useState: useState$4 } = owl__namespace.hooks;
    // -----------------------------------------------------------------------------
    // Resizer component
    // -----------------------------------------------------------------------------
    class AbstractResizer extends Component$4 {
        constructor() {
            super(...arguments);
            this.PADDING = 0;
            this.MAX_SIZE_MARGIN = 0;
            this.MIN_ELEMENT_SIZE = 0;
            this.lastSelectedElementIndex = null;
            this.getters = this.env.getters;
            this.dispatch = this.env.dispatch;
            this.state = useState$4({
                resizerIsActive: false,
                isResizing: false,
                isMoving: false,
                isSelecting: false,
                waitingForMove: false,
                activeElement: 0,
                draggerLinePosition: 0,
                draggerShadowPosition: 0,
                draggerShadowThickness: 0,
                delta: 0,
                base: 0,
            });
        }
        _computeHandleDisplay(ev) {
            const position = this._getEvOffset(ev);
            const elementIndex = this._getElementIndex(position);
            if (elementIndex < 0) {
                return;
            }
            const element = this._getElement(elementIndex);
            const offset = this._getStateOffset();
            if (position - (element.start - offset) < this.PADDING &&
                elementIndex !== this._getViewportOffset()) {
                this.state.resizerIsActive = true;
                this.state.draggerLinePosition = element.start - offset - this._getHeaderSize();
                this.state.activeElement = this._getPreviousVisibleElement(elementIndex);
            }
            else if (element.end - offset - position < this.PADDING) {
                this.state.resizerIsActive = true;
                this.state.draggerLinePosition = element.end - offset - this._getHeaderSize();
                this.state.activeElement = elementIndex;
            }
            else {
                this.state.resizerIsActive = false;
            }
        }
        _computeGrabDisplay(ev) {
            const index = this._getElementIndex(this._getEvOffset(ev));
            const activeElements = this._getActiveElements();
            const selectedZoneStart = this._getSelectedZoneStart();
            const selectedZoneEnd = this._getSelectedZoneEnd();
            if (activeElements.has(selectedZoneStart)) {
                if (selectedZoneStart <= index && index <= selectedZoneEnd) {
                    this.state.waitingForMove = true;
                    return;
                }
            }
            this.state.waitingForMove = false;
        }
        onMouseMove(ev) {
            if (this.state.isResizing || this.state.isMoving || this.state.isSelecting) {
                return;
            }
            this._computeHandleDisplay(ev);
            this._computeGrabDisplay(ev);
        }
        onMouseLeave() {
            this.state.resizerIsActive = this.state.isResizing;
            this.state.waitingForMove = false;
        }
        onDblClick() {
            this._fitElementSize(this.state.activeElement);
            this.state.isResizing = false;
        }
        onMouseDown(ev) {
            this.state.isResizing = true;
            this.state.delta = 0;
            const initialPosition = this._getClientPosition(ev);
            const styleValue = this.state.draggerLinePosition;
            const size = this._getElement(this.state.activeElement).size;
            const minSize = styleValue - size + this.MIN_ELEMENT_SIZE;
            const maxSize = this._getMaxSize();
            const onMouseUp = (ev) => {
                this.state.isResizing = false;
                if (this.state.delta !== 0) {
                    this._updateSize();
                }
            };
            const onMouseMove = (ev) => {
                this.state.delta = this._getClientPosition(ev) - initialPosition;
                this.state.draggerLinePosition = styleValue + this.state.delta;
                if (this.state.draggerLinePosition < minSize) {
                    this.state.draggerLinePosition = minSize;
                    this.state.delta = this.MIN_ELEMENT_SIZE - size;
                }
                if (this.state.draggerLinePosition > maxSize) {
                    this.state.draggerLinePosition = maxSize;
                    this.state.delta = maxSize - styleValue;
                }
            };
            startDnd(onMouseMove, onMouseUp);
        }
        select(ev) {
            if (ev.button > 0) {
                // not main button, probably a context menu
                return;
            }
            const index = this._getElementIndex(this._getEvOffset(ev));
            if (index < 0) {
                return;
            }
            if (this.state.waitingForMove === true) {
                this.startMovement(ev);
                return;
            }
            this.startSelection(ev, index);
        }
        startMovement(ev) {
            this.state.waitingForMove = false;
            this.state.isMoving = true;
            const startElement = this._getElement(this._getSelectedZoneStart());
            const endElement = this._getElement(this._getSelectedZoneEnd());
            const initialPosition = this._getClientPosition(ev);
            const defaultPosition = startElement.start - this._getStateOffset() - this._getHeaderSize();
            this.state.draggerLinePosition = defaultPosition;
            this.state.base = this._getSelectedZoneStart();
            this.state.draggerShadowPosition = defaultPosition;
            this.state.draggerShadowThickness = endElement.end - startElement.start;
            const mouseMoveMovement = (elementIndex, currentEv) => {
                if (elementIndex >= 0) {
                    // define draggerLinePosition
                    const element = this._getElement(elementIndex);
                    const offset = this._getStateOffset() + this._getHeaderSize();
                    if (elementIndex <= this._getSelectedZoneStart()) {
                        this.state.draggerLinePosition = element.start - offset;
                        this.state.base = elementIndex;
                    }
                    else if (this._getSelectedZoneEnd() < elementIndex) {
                        this.state.draggerLinePosition = element.end - offset;
                        this.state.base = elementIndex + 1;
                    }
                    else {
                        this.state.draggerLinePosition = startElement.start - offset;
                        this.state.base = this._getSelectedZoneStart();
                    }
                    // define draggerShadowPosition
                    const delta = this._getClientPosition(currentEv) - initialPosition;
                    this.state.draggerShadowPosition = Math.max(defaultPosition + delta, 0);
                }
            };
            const mouseUpMovement = (finalEv) => {
                this.state.isMoving = false;
                if (this.state.base !== this._getSelectedZoneStart()) {
                    this._moveElements();
                }
                this._computeGrabDisplay(finalEv);
            };
            this.dragOverlayBeyondTheViewport(ev, mouseMoveMovement, mouseUpMovement);
        }
        startSelection(ev, index) {
            this.state.isSelecting = true;
            this.dispatch(ev.ctrlKey ? "START_SELECTION_EXPANSION" : "START_SELECTION");
            if (ev.shiftKey) {
                this._increaseSelection(index);
            }
            else {
                this._selectElement(index, ev.ctrlKey);
            }
            this.lastSelectedElementIndex = index;
            const mouseMoveSelect = (elementIndex, currentEv) => {
                if (elementIndex !== this.lastSelectedElementIndex && elementIndex !== -1) {
                    this._increaseSelection(elementIndex);
                    this.lastSelectedElementIndex = elementIndex;
                }
            };
            const mouseUpSelect = () => {
                this.state.isSelecting = false;
                this.lastSelectedElementIndex = null;
                this.dispatch(ev.ctrlKey ? "PREPARE_SELECTION_EXPANSION" : "STOP_SELECTION");
                this._computeGrabDisplay(ev);
            };
            this.dragOverlayBeyondTheViewport(ev, mouseMoveSelect, mouseUpSelect);
        }
        dragOverlayBeyondTheViewport(ev, cbMouseMove, cbMouseUp) {
            let timeOutId = null;
            let currentEv;
            const initialPosition = this._getClientPosition(ev);
            const initialOffset = this._getEvOffset(ev);
            const onMouseMove = (ev) => {
                currentEv = ev;
                if (timeOutId) {
                    return;
                }
                const position = this._getClientPosition(currentEv) - initialPosition + initialOffset;
                const EdgeScrollInfo = this._getEdgeScroll(position);
                const { first, last } = this._getBoundaries();
                let elementIndex;
                if (EdgeScrollInfo.canEdgeScroll) {
                    elementIndex = EdgeScrollInfo.direction > 0 ? last : first - 1;
                }
                else {
                    elementIndex = this._getElementIndex(position);
                }
                cbMouseMove(elementIndex, currentEv);
                // adjust viewport if necessary
                if (EdgeScrollInfo.canEdgeScroll) {
                    this._adjustViewport(EdgeScrollInfo.direction);
                    timeOutId = setTimeout(() => {
                        timeOutId = null;
                        onMouseMove(currentEv);
                    }, Math.round(EdgeScrollInfo.delay));
                }
            };
            const onMouseUp = (finalEv) => {
                clearTimeout(timeOutId);
                cbMouseUp(finalEv);
            };
            startDnd(onMouseMove, onMouseUp);
        }
        onMouseUp(ev) {
            this.lastSelectedElementIndex = null;
        }
        onContextMenu(ev) {
            ev.preventDefault();
            const index = this._getElementIndex(this._getEvOffset(ev));
            if (index < 0)
                return;
            if (!this._getActiveElements().has(index)) {
                this._selectElement(index, false);
            }
            const type = this._getType();
            const { x, y } = this._getXY(ev);
            this.trigger("open-contextmenu", { type, x, y });
        }
    }
    class ColResizer extends AbstractResizer {
        constructor() {
            super(...arguments);
            this.PADDING = 15;
            this.MAX_SIZE_MARGIN = 90;
            this.MIN_ELEMENT_SIZE = MIN_COL_WIDTH;
        }
        _getEvOffset(ev) {
            return ev.offsetX + HEADER_WIDTH;
        }
        _getStateOffset() {
            return this.getters.getActiveSnappedViewport().offsetX - HEADER_WIDTH;
        }
        _getViewportOffset() {
            return this.getters.getActiveSnappedViewport().left;
        }
        _getClientPosition(ev) {
            return ev.clientX;
        }
        _getElementIndex(index) {
            return this.getters.getColIndex(index, this.getters.getActiveSnappedViewport().left);
        }
        _getSelectedZoneStart() {
            return this.getters.getSelectedZone().left;
        }
        _getSelectedZoneEnd() {
            return this.getters.getSelectedZone().right;
        }
        _getEdgeScroll(position) {
            return this.getters.getEdgeScrollCol(position);
        }
        _getBoundaries() {
            const { left, right } = this.getters.getActiveSnappedViewport();
            return { first: left, last: right };
        }
        _getElement(index) {
            return this.getters.getCol(this.getters.getActiveSheetId(), index);
        }
        _getBottomRightValue(element) {
            return element.end;
        }
        _getHeaderSize() {
            return HEADER_WIDTH;
        }
        _getMaxSize() {
            return this.el.clientWidth;
        }
        _updateSize() {
            const index = this.state.activeElement;
            const size = this.state.delta + this._getElement(index).size;
            const cols = this.getters.getActiveCols();
            this.dispatch("RESIZE_COLUMNS_ROWS", {
                dimension: "COL",
                sheetId: this.getters.getActiveSheetId(),
                elements: cols.has(index) ? [...cols] : [index],
                size,
            });
        }
        _moveElements() {
            const elements = [];
            const start = this._getSelectedZoneStart();
            const end = this._getSelectedZoneEnd();
            for (let colIndex = start; colIndex <= end; colIndex++) {
                elements.push(colIndex);
            }
            this.dispatch("MOVE_COLUMNS_ROWS", {
                sheetId: this.getters.getActiveSheetId(),
                dimension: "COL",
                base: this.state.base,
                elements,
            });
        }
        _selectElement(index, ctrlKey) {
            this.dispatch("SELECT_COLUMN", { index, createRange: ctrlKey });
        }
        _increaseSelection(index) {
            this.dispatch("SELECT_COLUMN", { index, updateRange: true });
        }
        _adjustViewport(direction) {
            const { left, offsetY } = this.getters.getActiveSnappedViewport();
            const { cols } = this.getters.getActiveSheet();
            const offsetX = cols[left + direction].start;
            this.dispatch("SET_VIEWPORT_OFFSET", { offsetX, offsetY });
        }
        _fitElementSize(index) {
            const cols = this.getters.getActiveCols();
            this.dispatch("AUTORESIZE_COLUMNS", {
                sheetId: this.getters.getActiveSheetId(),
                cols: cols.has(index) ? [...cols] : [index],
            });
        }
        _getType() {
            return "COL";
        }
        _getActiveElements() {
            return this.getters.getActiveCols();
        }
        _getXY(ev) {
            return {
                x: ev.offsetX + HEADER_WIDTH,
                y: ev.offsetY,
            };
        }
        _getPreviousVisibleElement(index) {
            const cols = this.getters.getActiveSheet().cols.slice(0, index);
            const step = cols.reverse().findIndex((col) => !col.isHidden);
            return index - 1 - step;
        }
        unhide(hiddenElements) {
            this.dispatch("UNHIDE_COLUMNS_ROWS", {
                sheetId: this.getters.getActiveSheetId(),
                elements: hiddenElements,
                dimension: "COL",
            });
        }
        unhideStyleValue(hiddenIndex) {
            const col = this.getters.getCol(this.getters.getActiveSheetId(), hiddenIndex);
            const offset = this._getStateOffset();
            return col.start - offset - this._getHeaderSize();
        }
    }
    ColResizer.template = xml$4 /* xml */ `
    <div class="o-col-resizer" t-on-mousemove.self="onMouseMove" t-on-mouseleave="onMouseLeave" t-on-mousedown.self.prevent="select"
      t-on-mouseup.self="onMouseUp" t-on-contextmenu.self="onContextMenu" t-att-class="{'o-grab': state.waitingForMove, 'o-dragging': state.isMoving, }">
      <div t-if="state.isMoving" class="dragging-col-line" t-attf-style="left:{{state.draggerLinePosition}}px;"/>
      <div t-if="state.isMoving" class="dragging-col-shadow" t-attf-style="left:{{state.draggerShadowPosition}}px; width:{{state.draggerShadowThickness}}px"/>
      <t t-if="state.resizerIsActive">
        <div class="o-handle" t-on-mousedown="onMouseDown" t-on-dblclick="onDblClick" t-on-contextmenu.prevent=""
        t-attf-style="left:{{state.draggerLinePosition - 2}}px;">
        <div class="dragging-resizer" t-if="state.isResizing"/>
        </div>
      </t>
      <t t-foreach="getters.getHiddenColsGroups(getters.getActiveSheetId())" t-as="hiddenItem" t-key="hiddenItem_index">
        <t t-if="!hiddenItem.includes(0)">
          <div class="o-unhide" t-att-data-index="hiddenItem_index" t-attf-style="left:{{unhideStyleValue(hiddenItem[0]) - 17}}px; margin-right:6px;" t-on-click="unhide(hiddenItem)">
          ${TRIANGLE_LEFT_ICON}
          </div>
        </t>
        <t t-if="!hiddenItem.includes(getters.getActiveSheet().cols.length-1)">
          <div class="o-unhide" t-att-data-index="hiddenItem_index" t-attf-style="left:{{unhideStyleValue(hiddenItem[0]) + 3}}px;" t-on-click="unhide(hiddenItem)">
          ${TRIANGLE_RIGHT_ICON}
          </div>
        </t>
      </t>
    </div>`;
    ColResizer.style = css$4 /* scss */ `
    .o-col-resizer {
      position: absolute;
      top: 0;
      left: ${HEADER_WIDTH}px;
      right: 0;
      height: ${HEADER_HEIGHT}px;
      &.o-dragging {
        cursor: grabbing;
      }
      &.o-grab {
        cursor: grab;
      }
      .dragging-col-line {
        top: ${HEADER_HEIGHT}px;
        position: absolute;
        width: 2px;
        height: 10000px;
        background-color: black;
      }
      .dragging-col-shadow {
        top: ${HEADER_HEIGHT}px;
        position: absolute;
        height: 10000px;
        background-color: black;
        opacity: 0.1;
      }
      .o-handle {
        position: absolute;
        height: ${HEADER_HEIGHT}px;
        width: 4px;
        cursor: e-resize;
        background-color: ${SELECTION_BORDER_COLOR};
      }
      .dragging-resizer {
        top: ${HEADER_HEIGHT}px;
        position: absolute;
        margin-left: 2px;
        width: 1px;
        height: 10000px;
        background-color: ${SELECTION_BORDER_COLOR};
      }
      .o-unhide {
        width: ${UNHIDE_ICON_EDGE_LENGTH}px;
        height: ${UNHIDE_ICON_EDGE_LENGTH}px;
        position: absolute;
        overflow: hidden;
        border-radius: 2px;
        top: calc(${HEADER_HEIGHT}px / 2 - ${UNHIDE_ICON_EDGE_LENGTH}px / 2);
      }
      .o-unhide:hover {
        z-index: 1;
        background-color: lightgrey;
      }
      .o-unhide > svg {
        position: relative;
        top: calc(${UNHIDE_ICON_EDGE_LENGTH}px / 2 - ${ICON_EDGE_LENGTH}px / 2);
      }
    }
  `;
    class RowResizer extends AbstractResizer {
        constructor() {
            super(...arguments);
            this.PADDING = 5;
            this.MAX_SIZE_MARGIN = 60;
            this.MIN_ELEMENT_SIZE = MIN_ROW_HEIGHT;
        }
        _getEvOffset(ev) {
            return ev.offsetY + HEADER_HEIGHT;
        }
        _getStateOffset() {
            return this.getters.getActiveSnappedViewport().offsetY - HEADER_HEIGHT;
        }
        _getViewportOffset() {
            return this.getters.getActiveSnappedViewport().top;
        }
        _getClientPosition(ev) {
            return ev.clientY;
        }
        _getElementIndex(index) {
            return this.getters.getRowIndex(index, this.getters.getActiveSnappedViewport().top);
        }
        _getSelectedZoneStart() {
            return this.getters.getSelectedZone().top;
        }
        _getSelectedZoneEnd() {
            return this.getters.getSelectedZone().bottom;
        }
        _getEdgeScroll(position) {
            return this.getters.getEdgeScrollRow(position);
        }
        _getBoundaries() {
            const { top, bottom } = this.getters.getActiveSnappedViewport();
            return { first: top, last: bottom };
        }
        _getElement(index) {
            return this.getters.getRow(this.getters.getActiveSheetId(), index);
        }
        _getHeaderSize() {
            return HEADER_HEIGHT;
        }
        _getMaxSize() {
            return this.el.clientHeight;
        }
        _updateSize() {
            const index = this.state.activeElement;
            const size = this.state.delta + this._getElement(index).size;
            const rows = this.getters.getActiveRows();
            this.dispatch("RESIZE_COLUMNS_ROWS", {
                dimension: "ROW",
                sheetId: this.getters.getActiveSheetId(),
                elements: rows.has(index) ? [...rows] : [index],
                size,
            });
        }
        _moveElements() {
            const elements = [];
            const start = this._getSelectedZoneStart();
            const end = this._getSelectedZoneEnd();
            for (let rowIndex = start; rowIndex <= end; rowIndex++) {
                elements.push(rowIndex);
            }
            this.dispatch("MOVE_COLUMNS_ROWS", {
                sheetId: this.getters.getActiveSheetId(),
                dimension: "ROW",
                base: this.state.base,
                elements,
            });
        }
        _selectElement(index, ctrlKey) {
            this.dispatch("SELECT_ROW", { index, createRange: ctrlKey });
        }
        _increaseSelection(index) {
            this.dispatch("SELECT_ROW", { index, updateRange: true });
        }
        _adjustViewport(direction) {
            const { top, offsetX } = this.getters.getActiveSnappedViewport();
            const { rows } = this.getters.getActiveSheet();
            const offsetY = rows[top + direction].start;
            this.dispatch("SET_VIEWPORT_OFFSET", { offsetX, offsetY });
        }
        _fitElementSize(index) {
            const rows = this.getters.getActiveRows();
            this.dispatch("AUTORESIZE_ROWS", {
                sheetId: this.getters.getActiveSheetId(),
                rows: rows.has(index) ? [...rows] : [index],
            });
        }
        _getType() {
            return "ROW";
        }
        _getActiveElements() {
            return this.getters.getActiveRows();
        }
        _getXY(ev) {
            return {
                x: ev.offsetX,
                y: ev.offsetY + HEADER_HEIGHT,
            };
        }
        _getPreviousVisibleElement(index) {
            const rows = this.getters.getActiveSheet().rows.slice(0, index);
            const step = rows.reverse().findIndex((row) => !row.isHidden);
            return index - 1 - step;
        }
        unhide(hiddenElements) {
            this.dispatch("UNHIDE_COLUMNS_ROWS", {
                sheetId: this.getters.getActiveSheetId(),
                dimension: "ROW",
                elements: hiddenElements,
            });
        }
        unhideStyleValue(hiddenIndex) {
            const row = this.getters.getRow(this.getters.getActiveSheetId(), hiddenIndex);
            const offset = this._getStateOffset();
            return row.start - offset - this._getHeaderSize();
        }
    }
    RowResizer.template = xml$4 /* xml */ `
    <div class="o-row-resizer" t-on-mousemove.self="onMouseMove" t-on-mouseleave="onMouseLeave" t-on-mousedown.self.prevent="select"
    t-on-mouseup.self="onMouseUp" t-on-contextmenu.self="onContextMenu" t-att-class="{'o-grab': state.waitingForMove, 'o-dragging': state.isMoving}">
      <div t-if="state.isMoving" class="dragging-row-line" t-attf-style="top:{{state.draggerLinePosition}}px;"/>
      <div t-if="state.isMoving" class="dragging-row-shadow" t-attf-style="top:{{state.draggerShadowPosition}}px; height:{{state.draggerShadowThickness}}px;"/>
      <t t-if="state.resizerIsActive">
        <div class="o-handle" t-on-mousedown="onMouseDown" t-on-dblclick="onDblClick" t-on-contextmenu.prevent=""
          t-attf-style="top:{{state.draggerLinePosition - 2}}px;">
          <div class="dragging-resizer" t-if="state.isResizing"/>
        </div>
      </t>
      <t t-foreach="getters.getHiddenRowsGroups(getters.getActiveSheetId())" t-as="hiddenItem" t-key="hiddenItem_index">
        <t t-if="!hiddenItem.includes(0)">
          <div class="o-unhide" t-att-data-index="hiddenItem_index" t-attf-style="top:{{unhideStyleValue(hiddenItem[0]) - 17}}px;" t-on-click="unhide(hiddenItem)">
          ${TRIANGLE_UP_ICON}
          </div>
        </t>
        <t t-if="!hiddenItem.includes(getters.getActiveSheet().rows.length-1)">
         <div class="o-unhide" t-att-data-index="hiddenItem_index"  t-attf-style="top:{{unhideStyleValue(hiddenItem[0]) + 3}}px;" t-on-click="unhide(hiddenItem)">
         ${TRIANGLE_DOWN_ICON}
         </div>
        </t>
      </t>
    </div>`;
    RowResizer.style = css$4 /* scss */ `
    .o-row-resizer {
      position: absolute;
      top: ${HEADER_HEIGHT}px;
      left: 0;
      right: 0;
      width: ${HEADER_WIDTH}px;
      height: 100%;
      &.o-dragging {
        cursor: grabbing;
      }
      &.o-grab {
        cursor: grab;
      }
      .dragging-row-line {
        left: ${HEADER_WIDTH}px;
        position: absolute;
        width: 10000px;
        height: 2px;
        background-color: black;
      }
      .dragging-row-shadow {
        left: ${HEADER_WIDTH}px;
        position: absolute;
        width: 10000px;
        background-color: black;
        opacity: 0.1;
      }
      .o-handle {
        position: absolute;
        height: 4px;
        width: ${HEADER_WIDTH}px;
        cursor: n-resize;
        background-color: ${SELECTION_BORDER_COLOR};
      }
      .dragging-resizer {
        left: ${HEADER_WIDTH}px;
        position: absolute;
        margin-top: 2px;
        width: 10000px;
        height: 1px;
        background-color: ${SELECTION_BORDER_COLOR};
      }
      .o-unhide {
        width: ${UNHIDE_ICON_EDGE_LENGTH}px;
        height: ${UNHIDE_ICON_EDGE_LENGTH}px;
        position: absolute;
        overflow: hidden;
        border-radius: 2px;
        left: calc(${HEADER_WIDTH}px - ${UNHIDE_ICON_EDGE_LENGTH}px - 2px);
      }
      .o-unhide > svg {
        position: relative;
        left: calc(${UNHIDE_ICON_EDGE_LENGTH}px / 2 - ${ICON_EDGE_LENGTH}px / 2);
        top: calc(${UNHIDE_ICON_EDGE_LENGTH}px / 2 - ${ICON_EDGE_LENGTH}px / 2);
      }
      .o-unhide:hover {
        z-index: 1;
        background-color: lightgrey;
      }
    }
  `;
    class Overlay extends Component$4 {
        selectAll() {
            this.env.dispatch("SELECT_ALL");
        }
    }
    Overlay.template = xml$4 /* xml */ `
    <div class="o-overlay">
      <ColResizer />
      <RowResizer />
      <div class="all" t-on-mousedown.self="selectAll"/>
    </div>`;
    Overlay.style = css$4 /* scss */ `
    .o-overlay {
      .all {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        width: ${HEADER_WIDTH}px;
        height: ${HEADER_HEIGHT}px;
      }
    }
  `;
    Overlay.components = { ColResizer, RowResizer };

    class ScrollBar {
        constructor(el, direction) {
            this.el = el;
            this.direction = direction;
        }
        get scroll() {
            return this.direction === "horizontal" ? this.el.scrollLeft : this.el.scrollTop;
        }
        set scroll(value) {
            if (this.direction === "horizontal") {
                this.el.scrollLeft = value;
            }
            else {
                this.el.scrollTop = value;
            }
        }
    }

    /**
     * The Grid component is the main part of the spreadsheet UI. It is responsible
     * for displaying the actual grid, rendering it, managing events, ...
     *
     * The grid is rendered on a canvas. 3 sub components are (sometimes) displayed
     * on top of the canvas:
     * - a composer (to edit the cell content)
     * - a horizontal resizer (to resize columns)
     * - a vertical resizer (same, for rows)
     */
    const { Component: Component$3, useState: useState$3 } = owl__namespace;
    const { xml: xml$3, css: css$3 } = owl__namespace.tags;
    const { useRef: useRef$2, onMounted, onWillUnmount } = owl__namespace.hooks;
    const registries$1 = {
        ROW: rowMenuRegistry,
        COL: colMenuRegistry,
        CELL: cellMenuRegistry,
    };
    const LINK_EDITOR_WIDTH = 340;
    const LINK_EDITOR_HEIGHT = 180;
    const ERROR_TOOLTIP_HEIGHT = 40;
    const ERROR_TOOLTIP_WIDTH = 180;
    // copy and paste are specific events that should not be managed by the keydown event,
    // but they shouldn't be preventDefault and stopped (else copy and paste events will not trigger)
    // and also should not result in typing the character C or V in the composer
    const keyDownMappingIgnore = ["CTRL+C", "CTRL+V"];
    function useCellHovered(env, getViewPort) {
        const hoveredPosition = useState$3({});
        const { browser, getters } = env;
        const { Date, setInterval, clearInterval } = browser;
        const canvasRef = useRef$2("canvas");
        let x = 0;
        let y = 0;
        let lastMoved = 0;
        let interval;
        function getPosition() {
            const viewport = getViewPort();
            const col = getters.getColIndex(x, viewport.left);
            const row = getters.getRowIndex(y, viewport.top);
            return [col, row];
        }
        function checkTiming() {
            const [col, row] = getPosition();
            const delta = Date.now() - lastMoved;
            if (col !== hoveredPosition.col || row !== hoveredPosition.row) {
                hoveredPosition.col = undefined;
                hoveredPosition.row = undefined;
            }
            if (400 < delta && delta < 600) {
                if (col < 0 || row < 0) {
                    return;
                }
                hoveredPosition.col = col;
                hoveredPosition.row = row;
            }
        }
        function updateMousePosition(e) {
            x = e.offsetX;
            y = e.offsetY;
            lastMoved = Date.now();
        }
        onMounted(() => {
            canvasRef.el.addEventListener("mousemove", updateMousePosition);
            interval = setInterval(checkTiming, 200);
        });
        onWillUnmount(() => {
            canvasRef.el.removeEventListener("mousemove", updateMousePosition);
            clearInterval(interval);
        });
        return hoveredPosition;
    }
    function useTouchMove(handler, canMoveUp) {
        const canvasRef = useRef$2("canvas");
        let x = null;
        let y = null;
        function onTouchStart(ev) {
            if (ev.touches.length !== 1)
                return;
            x = ev.touches[0].clientX;
            y = ev.touches[0].clientY;
        }
        function onTouchEnd() {
            x = null;
            y = null;
        }
        function onTouchMove(ev) {
            if (ev.touches.length !== 1)
                return;
            // On mobile browsers, swiping down is often associated with "pull to refresh".
            // We only want this behavior if the grid is already at the top.
            // Otherwise we only want to move the canvas up, without triggering any refresh.
            if (canMoveUp()) {
                ev.preventDefault();
                ev.stopPropagation();
            }
            const currentX = ev.touches[0].clientX;
            const currentY = ev.touches[0].clientY;
            handler(x - currentX, y - currentY);
            x = currentX;
            y = currentY;
        }
        onMounted(() => {
            canvasRef.el.addEventListener("touchstart", onTouchStart);
            canvasRef.el.addEventListener("touchend", onTouchEnd);
            canvasRef.el.addEventListener("touchmove", onTouchMove);
        });
        onWillUnmount(() => {
            canvasRef.el.removeEventListener("touchstart", onTouchStart);
            canvasRef.el.removeEventListener("touchend", onTouchEnd);
            canvasRef.el.removeEventListener("touchmove", onTouchMove);
        });
    }
    // -----------------------------------------------------------------------------
    // TEMPLATE
    // -----------------------------------------------------------------------------
    const TEMPLATE$2 = xml$3 /* xml */ `
  <div class="o-grid" t-on-click="focus" t-on-keydown="onKeydown" t-on-wheel="onMouseWheel">
    <t t-if="getters.getEditionMode() !== 'inactive'">
      <GridComposer
        t-on-composer-unmounted="focus"
        focus="props.focusComposer"
        />
    </t>
    <canvas t-ref="canvas"
      t-on-mousedown="onMouseDown"
      t-on-dblclick="onDoubleClick"
      tabindex="-1"
      t-on-contextmenu="onCanvasContextMenu"
       />
    <t t-foreach="getters.getClientsToDisplay()" t-as="client" t-key="getClientPositionKey(client)">
      <ClientTag name="client.name"
                 color="client.color"
                 col="client.position.col"
                 row="client.position.row"
                 active="isCellHovered(client.position.col, client.position.row)"
                 />
    </t>
    <Popover
      t-if="errorTooltip.isOpen"
      position="errorTooltip.position"
      flipHorizontalOffset="errorTooltip.cellWidth"
      childWidth="${ERROR_TOOLTIP_WIDTH}"
      childHeight="${ERROR_TOOLTIP_HEIGHT}">
      <ErrorToolTip text="errorTooltip.text"/>
    </Popover>
    <Popover
      t-if="shouldDisplayLink"
      position="popoverPosition.position"
      flipHorizontalOffset="-popoverPosition.cellWidth"
      flipVerticalOffset="-popoverPosition.cellHeight"
      childWidth="${LINK_TOOLTIP_WIDTH}"
      childHeight="${LINK_TOOLTIP_HEIGHT}">
      <LinkDisplay cellPosition="activeCellPosition"/>
    </Popover>
    <Popover
      t-if="props.linkEditorIsOpen"
      position="popoverPosition.position"
      flipHorizontalOffset="-popoverPosition.cellWidth"
      flipVerticalOffset="-popoverPosition.cellHeight"
      childWidth="${LINK_EDITOR_WIDTH}"
      childHeight="${LINK_EDITOR_HEIGHT}">
      <LinkEditor cellPosition="activeCellPosition"/>
    </Popover>
    <t t-if="getters.getEditionMode() === 'inactive'">
      <Autofill position="getAutofillPosition()"/>
    </t>
    <t t-if="getters.getEditionMode() !== 'inactive'">
      <t t-foreach="getters.getHighlights()" t-as="highlight">
        <t t-if="highlight.sheet === getters.getActiveSheetId()">
          <Highlight zone="highlight.zone" color="highlight.color"/>
        </t>
      </t>
    </t>
    <Overlay t-on-open-contextmenu="onOverlayContextMenu" />
    <Menu t-if="menuState.isOpen"
      menuItems="menuState.menuItems"
      position="menuState.position"
      t-on-close.stop="closeMenu"/>
    <t t-set="gridSize" t-value="getters.getGridDimension(getters.getActiveSheet())"/>
    <FiguresContainer model="props.model" sidePanelIsOpen="props.sidePanelIsOpen" t-on-figure-deleted="focus" />
    <div class="o-scrollbar vertical" t-on-scroll="onScroll" t-ref="vscrollbar">
      <div t-attf-style="width:1px;height:{{gridSize.height}}px"/>
    </div>
    <div class="o-scrollbar horizontal" t-on-scroll="onScroll" t-ref="hscrollbar">
      <div t-attf-style="height:1px;width:{{gridSize.width}}px"/>
    </div>
  </div>`;
    // -----------------------------------------------------------------------------
    // STYLE
    // -----------------------------------------------------------------------------
    const CSS$2 = css$3 /* scss */ `
  .o-grid {
    position: relative;
    overflow: hidden;
    background-color: ${BACKGROUND_GRAY_COLOR};

    > canvas {
      border-top: 1px solid #e2e3e3;
      border-bottom: 1px solid #e2e3e3;

      &:focus {
        outline: none;
      }
    }
    .o-scrollbar {
      position: absolute;
      overflow: auto;
      z-index: 2;
      &.vertical {
        right: 0;
        top: ${HEADER_HEIGHT}px;
        bottom: ${SCROLLBAR_WIDTH$1}px;
        width: ${SCROLLBAR_WIDTH$1}px;
        overflow-x: hidden;
      }
      &.horizontal {
        bottom: 0;
        height: ${SCROLLBAR_WIDTH$1}px;
        right: ${SCROLLBAR_WIDTH$1 + 1}px;
        left: ${HEADER_WIDTH}px;
        overflow-y: hidden;
      }
    }
  }
`;
    // -----------------------------------------------------------------------------
    // JS
    // -----------------------------------------------------------------------------
    class Grid extends Component$3 {
        constructor() {
            super(...arguments);
            this.menuState = useState$3({
                isOpen: false,
                position: null,
                menuItems: [],
            });
            this.vScrollbarRef = useRef$2("vscrollbar");
            this.hScrollbarRef = useRef$2("hscrollbar");
            this.canvas = useRef$2("canvas");
            this.getters = this.env.getters;
            this.dispatch = this.env.dispatch;
            this.currentSheet = this.getters.getActiveSheetId();
            this.clickedCol = 0;
            this.clickedRow = 0;
            this.hoveredCell = useCellHovered(this.env, () => this.getters.getActiveSnappedViewport());
            // this map will handle most of the actions that should happen on key down. The arrow keys are managed in the key
            // down itself
            this.keyDownMapping = {
                ENTER: () => {
                    const cell = this.getters.getActiveCell();
                    !cell || cell.isEmpty()
                        ? this.trigger("composer-cell-focused")
                        : this.trigger("composer-content-focused");
                },
                TAB: () => this.dispatch("MOVE_POSITION", { deltaX: 1, deltaY: 0 }),
                "SHIFT+TAB": () => this.dispatch("MOVE_POSITION", { deltaX: -1, deltaY: 0 }),
                F2: () => {
                    const cell = this.getters.getActiveCell();
                    !cell || cell.isEmpty()
                        ? this.trigger("composer-cell-focused")
                        : this.trigger("composer-content-focused");
                },
                DELETE: () => {
                    this.dispatch("DELETE_CONTENT", {
                        sheetId: this.getters.getActiveSheetId(),
                        target: this.getters.getSelectedZones(),
                    });
                },
                "CTRL+A": () => this.dispatch("SELECT_ALL"),
                "CTRL+S": () => {
                    this.trigger("save-requested");
                },
                "CTRL+Z": () => this.dispatch("REQUEST_UNDO"),
                "CTRL+Y": () => this.dispatch("REQUEST_REDO"),
                "CTRL+B": () => this.dispatch("SET_FORMATTING", {
                    sheetId: this.getters.getActiveSheetId(),
                    target: this.getters.getSelectedZones(),
                    style: { bold: !this.getters.getCurrentStyle().bold },
                }),
                "CTRL+I": () => this.dispatch("SET_FORMATTING", {
                    sheetId: this.getters.getActiveSheetId(),
                    target: this.getters.getSelectedZones(),
                    style: { italic: !this.getters.getCurrentStyle().italic },
                }),
                "CTRL+U": () => this.dispatch("SET_FORMATTING", {
                    sheetId: this.getters.getActiveSheetId(),
                    target: this.getters.getSelectedZones(),
                    style: { underline: !this.getters.getCurrentStyle().underline },
                }),
                "ALT+=": () => {
                    var _a;
                    const sheetId = this.getters.getActiveSheetId();
                    const mainSelectedZone = this.getters.getSelectedZone();
                    const sums = this.getters.getAutomaticSums(sheetId, mainSelectedZone, this.getters.getPosition());
                    if (this.getters.isSingleCellOrMerge(sheetId, mainSelectedZone) ||
                        (this.getters.isEmpty(sheetId, mainSelectedZone) && sums.length <= 1)) {
                        const zone = (_a = sums[0]) === null || _a === void 0 ? void 0 : _a.zone;
                        const zoneXc = zone ? this.getters.zoneToXC(sheetId, sums[0].zone) : "";
                        const formula = `=SUM(${zoneXc})`;
                        this.trigger("composer-cell-focused", {
                            content: formula,
                            selection: { start: 5, end: 5 + zoneXc.length },
                        });
                    }
                    else {
                        this.dispatch("SUM_SELECTION");
                    }
                },
                "CTRL+HOME": () => {
                    const sheet = this.getters.getActiveSheet();
                    const [col, row] = getNextVisibleCellCoords(sheet, 0, 0);
                    this.dispatch("SELECT_CELL", { col, row });
                },
                "CTRL+END": () => {
                    const sheet = this.getters.getActiveSheet();
                    const col = findVisibleHeader(sheet, "cols", range(0, sheet.cols.length).reverse());
                    const row = findVisibleHeader(sheet, "rows", range(0, sheet.rows.length).reverse());
                    this.dispatch("SELECT_CELL", { col, row });
                },
                "SHIFT+ ": () => {
                    const { cols } = this.getters.getActiveSheet();
                    const newZone = { ...this.getters.getSelectedZone(), left: 0, right: cols.length - 1 };
                    this.dispatch("SET_SELECTION", {
                        anchor: this.getters.getPosition(),
                        zones: [newZone],
                        anchorZone: newZone,
                    });
                },
                "CTRL+ ": () => {
                    const { rows } = this.getters.getActiveSheet();
                    const newZone = { ...this.getters.getSelectedZone(), top: 0, bottom: rows.length - 1 };
                    this.dispatch("SET_SELECTION", {
                        anchor: this.getters.getPosition(),
                        zones: [newZone],
                        anchorZone: newZone,
                    });
                },
                "CTRL+SHIFT+ ": () => {
                    this.dispatch("SELECT_ALL");
                },
                "SHIFT+PAGEDOWN": () => {
                    this.dispatch("ACTIVATE_NEXT_SHEET");
                },
                "SHIFT+PAGEUP": () => {
                    this.dispatch("ACTIVATE_PREVIOUS_SHEET");
                },
            };
            this.vScrollbar = new ScrollBar(this.vScrollbarRef.el, "vertical");
            this.hScrollbar = new ScrollBar(this.hScrollbarRef.el, "horizontal");
            useTouchMove(this.moveCanvas.bind(this), () => this.vScrollbar.scroll > 0);
        }
        get errorTooltip() {
            const { col, row } = this.hoveredCell;
            if (col === undefined || row === undefined) {
                return { isOpen: false };
            }
            const sheetId = this.getters.getActiveSheetId();
            const [mainCol, mainRow] = this.getters.getMainCell(sheetId, col, row);
            const cell = this.getters.getCell(sheetId, mainCol, mainRow);
            if (cell && cell.evaluated.type === CellValueType.error) {
                const viewport = this.getters.getActiveSnappedViewport();
                const [x, y, width] = this.getters.getRect({ left: col, top: row, right: col, bottom: row }, viewport);
                return {
                    isOpen: true,
                    position: { x: x + width, y: y + TOPBAR_HEIGHT },
                    text: cell.evaluated.error,
                    cellWidth: width,
                };
            }
            return { isOpen: false };
        }
        get activeCellPosition() {
            const [col, row] = this.getters.getMainCell(this.getters.getActiveSheetId(), ...this.getters.getPosition());
            return { col, row };
        }
        get shouldDisplayLink() {
            const sheetId = this.getters.getActiveSheetId();
            const { col, row } = this.activeCellPosition;
            const viewport = this.getters.getActiveSnappedViewport();
            const cell = this.getters.getCell(sheetId, col, row);
            return (this.getters.isVisibleInViewport(col, row, viewport) &&
                !!cell &&
                cell.isLink() &&
                !this.menuState.isOpen &&
                !this.props.linkEditorIsOpen &&
                !this.props.sidePanelIsOpen);
        }
        /**
         * Get a reasonable position to display the popover, under the active cell.
         * Used by link popover components.
         */
        get popoverPosition() {
            const [col, row] = this.getters.getBottomLeftCell(this.getters.getActiveSheetId(), ...this.getters.getPosition());
            const viewport = this.getters.getActiveSnappedViewport();
            const [x, y, width, height] = this.getters.getRect({ left: col, top: row, right: col, bottom: row }, viewport);
            return {
                position: { x, y: y + height + TOPBAR_HEIGHT },
                cellWidth: width,
                cellHeight: height,
            };
        }
        mounted() {
            this.vScrollbar.el = this.vScrollbarRef.el;
            this.hScrollbar.el = this.hScrollbarRef.el;
            this.focus();
            this.resizeGrid();
            this.drawGrid();
        }
        patched() {
            this.resizeGrid();
            this.drawGrid();
        }
        focus() {
            if (!this.getters.isSelectingForComposer() && !this.getters.getSelectedFigureId()) {
                this.canvas.el.focus();
            }
        }
        resizeGrid() {
            const currentHeight = this.el.clientHeight - SCROLLBAR_WIDTH$1;
            const currentWidth = this.el.clientWidth - SCROLLBAR_WIDTH$1;
            const { height: viewportHeight, width: viewportWidth } = this.getters.getViewportDimension();
            if (currentHeight != viewportHeight || currentWidth !== viewportWidth) {
                this.dispatch("RESIZE_VIEWPORT", {
                    height: currentHeight,
                    width: currentWidth,
                });
            }
        }
        onScroll() {
            const { offsetX, offsetY } = this.getters.getActiveViewport();
            if (offsetX !== this.hScrollbar.scroll || offsetY !== this.vScrollbar.scroll) {
                const { maxOffsetX, maxOffsetY } = this.getters.getMaximumViewportOffset(this.getters.getActiveSheet());
                this.dispatch("SET_VIEWPORT_OFFSET", {
                    offsetX: Math.min(this.hScrollbar.scroll, maxOffsetX),
                    offsetY: Math.min(this.vScrollbar.scroll, maxOffsetY),
                });
            }
        }
        checkSheetChanges() {
            const currentSheet = this.getters.getActiveSheetId();
            if (currentSheet !== this.currentSheet) {
                this.focus();
                this.currentSheet = currentSheet;
            }
        }
        getAutofillPosition() {
            const zone = this.getters.getSelectedZone();
            const sheet = this.getters.getActiveSheet();
            const { offsetX, offsetY } = this.getters.getActiveSnappedViewport();
            return {
                left: sheet.cols[zone.right].end - AUTOFILL_EDGE_LENGTH / 2 + HEADER_WIDTH - offsetX,
                top: sheet.rows[zone.bottom].end - AUTOFILL_EDGE_LENGTH / 2 + HEADER_HEIGHT - offsetY,
            };
        }
        drawGrid() {
            //reposition scrollbar
            const { offsetX, offsetY } = this.getters.getActiveViewport();
            this.hScrollbar.scroll = offsetX;
            this.vScrollbar.scroll = offsetY;
            // check for position changes
            this.checkSheetChanges();
            // drawing grid on canvas
            const canvas = this.canvas.el;
            const dpr = window.devicePixelRatio || 1;
            const ctx = canvas.getContext("2d", { alpha: false });
            const thinLineWidth = 0.4 * dpr;
            const renderingContext = {
                ctx,
                viewport: this.getters.getActiveViewport(),
                dpr,
                thinLineWidth,
            };
            const { width, height } = this.getters.getViewportDimension();
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.setAttribute("style", `width:${width}px;height:${height}px;`);
            ctx.translate(-0.5, -0.5);
            ctx.scale(dpr, dpr);
            this.props.model.drawGrid(renderingContext);
        }
        moveCanvas(deltaX, deltaY) {
            this.vScrollbar.scroll = this.vScrollbar.scroll + deltaY;
            this.hScrollbar.scroll = this.hScrollbar.scroll + deltaX;
            this.dispatch("SET_VIEWPORT_OFFSET", {
                offsetX: this.hScrollbar.scroll,
                offsetY: this.vScrollbar.scroll,
            });
        }
        getClientPositionKey(client) {
            var _a, _b, _c;
            return `${client.id}-${(_a = client.position) === null || _a === void 0 ? void 0 : _a.sheetId}-${(_b = client.position) === null || _b === void 0 ? void 0 : _b.col}-${(_c = client.position) === null || _c === void 0 ? void 0 : _c.row}`;
        }
        onMouseWheel(ev) {
            if (ev.ctrlKey) {
                return;
            }
            function normalize(val) {
                return val * (ev.deltaMode === 0 ? 1 : DEFAULT_CELL_HEIGHT);
            }
            const deltaX = ev.shiftKey ? ev.deltaY : ev.deltaX;
            const deltaY = ev.shiftKey ? ev.deltaX : ev.deltaY;
            this.moveCanvas(normalize(deltaX), normalize(deltaY));
        }
        isCellHovered(col, row) {
            return this.hoveredCell.col === col && this.hoveredCell.row === row;
        }
        // ---------------------------------------------------------------------------
        // Zone selection with mouse
        // ---------------------------------------------------------------------------
        /**
         * Get the coordinates in pixels, with 0,0 being the top left of the grid itself
         */
        getCoordinates(ev) {
            const rect = this.el.getBoundingClientRect();
            const x = ev.pageX - rect.left;
            const y = ev.pageY - rect.top;
            return [x, y];
        }
        getCartesianCoordinates(ev) {
            const [x, y] = this.getCoordinates(ev);
            const { left, top } = this.getters.getActiveSnappedViewport();
            const colIndex = this.getters.getColIndex(x, left);
            const rowIndex = this.getters.getRowIndex(y, top);
            return [colIndex, rowIndex];
        }
        onMouseDown(ev) {
            if (ev.button > 0) {
                // not main button, probably a context menu
                return;
            }
            const [col, row] = this.getCartesianCoordinates(ev);
            if (col < 0 || row < 0) {
                return;
            }
            this.clickedCol = col;
            this.clickedRow = row;
            const sheetId = this.getters.getActiveSheetId();
            const [mainCol, mainRow] = this.getters.getMainCell(sheetId, col, row);
            const cell = this.getters.getCell(sheetId, mainCol, mainRow);
            if (!(cell === null || cell === void 0 ? void 0 : cell.isLink())) {
                this.closeLinkEditor();
            }
            this.dispatch(ev.ctrlKey ? "START_SELECTION_EXPANSION" : "START_SELECTION");
            if (ev.shiftKey) {
                this.dispatch("ALTER_SELECTION", { cell: [col, row] });
            }
            else {
                this.dispatch("SELECT_CELL", { col, row });
                this.checkSheetChanges();
            }
            let prevCol = col;
            let prevRow = row;
            let isEdgeScrolling = false;
            let timeOutId = null;
            let timeoutDelay = 0;
            let currentEv;
            const sheet = this.getters.getActiveSheet();
            const onMouseMove = (ev) => {
                currentEv = ev;
                if (timeOutId) {
                    return;
                }
                const [x, y] = this.getCoordinates(currentEv);
                isEdgeScrolling = false;
                timeoutDelay = 0;
                const colEdgeScroll = this.getters.getEdgeScrollCol(x);
                const rowEdgeScroll = this.getters.getEdgeScrollRow(y);
                const { left, right, top, bottom } = this.getters.getActiveSnappedViewport();
                let col, row;
                if (colEdgeScroll.canEdgeScroll) {
                    col = colEdgeScroll.direction > 0 ? right : left - 1;
                }
                else {
                    col = this.getters.getColIndex(x, left);
                    col = col === -1 ? prevCol : col;
                }
                if (rowEdgeScroll.canEdgeScroll) {
                    row = rowEdgeScroll.direction > 0 ? bottom : top - 1;
                }
                else {
                    row = this.getters.getRowIndex(y, top);
                    row = row === -1 ? prevRow : row;
                }
                isEdgeScrolling = colEdgeScroll.canEdgeScroll || rowEdgeScroll.canEdgeScroll;
                timeoutDelay = Math.min(colEdgeScroll.canEdgeScroll ? colEdgeScroll.delay : MAX_DELAY, rowEdgeScroll.canEdgeScroll ? rowEdgeScroll.delay : MAX_DELAY);
                if (col !== prevCol || row !== prevRow) {
                    prevCol = col;
                    prevRow = row;
                    this.dispatch("ALTER_SELECTION", { cell: [col, row] });
                }
                if (isEdgeScrolling) {
                    const offsetX = sheet.cols[left + colEdgeScroll.direction].start;
                    const offsetY = sheet.rows[top + rowEdgeScroll.direction].start;
                    this.dispatch("SET_VIEWPORT_OFFSET", { offsetX, offsetY });
                    timeOutId = setTimeout(() => {
                        timeOutId = null;
                        onMouseMove(currentEv);
                    }, Math.round(timeoutDelay));
                }
            };
            const onMouseUp = (ev) => {
                clearTimeout(timeOutId);
                this.dispatch(ev.ctrlKey ? "PREPARE_SELECTION_EXPANSION" : "STOP_SELECTION");
                this.canvas.el.removeEventListener("mousemove", onMouseMove);
                if (this.getters.isPaintingFormat()) {
                    this.dispatch("PASTE", {
                        target: this.getters.getSelectedZones(),
                    });
                }
            };
            startDnd(onMouseMove, onMouseUp);
        }
        onDoubleClick(ev) {
            const [col, row] = this.getCartesianCoordinates(ev);
            if (this.clickedCol === col && this.clickedRow === row) {
                const cell = this.getters.getActiveCell();
                !cell || cell.isEmpty()
                    ? this.trigger("composer-cell-focused")
                    : this.trigger("composer-content-focused");
            }
        }
        closeLinkEditor() {
            this.trigger("link-editor-closed");
        }
        // ---------------------------------------------------------------------------
        // Keyboard interactions
        // ---------------------------------------------------------------------------
        processTabKey(ev) {
            ev.preventDefault();
            const deltaX = ev.shiftKey ? -1 : 1;
            this.dispatch("MOVE_POSITION", { deltaX, deltaY: 0 });
        }
        processArrows(ev) {
            ev.preventDefault();
            ev.stopPropagation();
            this.closeLinkEditor();
            const deltaMap = {
                ArrowDown: [0, 1],
                ArrowLeft: [-1, 0],
                ArrowRight: [1, 0],
                ArrowUp: [0, -1],
            };
            const delta = deltaMap[ev.key];
            if (ev.shiftKey) {
                const oldZone = this.getters.getSelectedZone();
                this.dispatch("ALTER_SELECTION", { delta });
                const newZone = this.getters.getSelectedZone();
                const viewport = this.getters.getActiveSnappedViewport();
                const sheet = this.getters.getActiveSheet();
                const [col, row] = findCellInNewZone(oldZone, newZone, viewport);
                const { left, right, top, bottom, offsetX, offsetY } = viewport;
                const newOffsetX = col < left || col > right - 1 ? sheet.cols[left + delta[0]].start : offsetX;
                const newOffsetY = row < top || row > bottom - 1 ? sheet.rows[top + delta[1]].start : offsetY;
                if (newOffsetX !== offsetX || newOffsetY !== offsetY) {
                    this.dispatch("SET_VIEWPORT_OFFSET", { offsetX: newOffsetX, offsetY: newOffsetY });
                }
            }
            else {
                this.dispatch("MOVE_POSITION", { deltaX: delta[0], deltaY: delta[1] });
            }
            if (this.getters.isPaintingFormat()) {
                this.dispatch("PASTE", {
                    target: this.getters.getSelectedZones(),
                });
            }
        }
        onKeydown(ev) {
            if (ev.key.startsWith("Arrow")) {
                this.processArrows(ev);
                return;
            }
            let keyDownString = "";
            if (ev.ctrlKey)
                keyDownString += "CTRL+";
            if (ev.metaKey)
                keyDownString += "CTRL+";
            if (ev.altKey)
                keyDownString += "ALT+";
            if (ev.shiftKey)
                keyDownString += "SHIFT+";
            keyDownString += ev.key.toUpperCase();
            let handler = this.keyDownMapping[keyDownString];
            if (handler) {
                ev.preventDefault();
                ev.stopPropagation();
                handler();
                return;
            }
            if (!keyDownMappingIgnore.includes(keyDownString)) {
                if (ev.key.length === 1 && !ev.ctrlKey && !ev.metaKey && !ev.altKey) {
                    // if the user types a character on the grid, it means he wants to start composing the selected cell with that
                    // character
                    ev.preventDefault();
                    ev.stopPropagation();
                    this.trigger("composer-cell-focused", { content: ev.key });
                }
            }
        }
        // ---------------------------------------------------------------------------
        // Context Menu
        // ---------------------------------------------------------------------------
        onCanvasContextMenu(ev) {
            ev.preventDefault();
            const [col, row] = this.getCartesianCoordinates(ev);
            if (col < 0 || row < 0) {
                return;
            }
            const zones = this.getters.getSelectedZones();
            const lastZone = zones[zones.length - 1];
            let type = "CELL";
            if (!isInside(col, row, lastZone)) {
                this.dispatch("STOP_EDITION");
                this.dispatch("SELECT_CELL", { col, row });
            }
            else {
                if (this.getters.getActiveCols().has(col)) {
                    type = "COL";
                }
                else if (this.getters.getActiveRows().has(row)) {
                    type = "ROW";
                }
            }
            this.toggleContextMenu(type, ev.offsetX, ev.offsetY);
        }
        onOverlayContextMenu(ev) {
            const type = ev.detail.type;
            const x = ev.detail.x;
            const y = ev.detail.y;
            this.toggleContextMenu(type, x, y);
        }
        toggleContextMenu(type, x, y) {
            this.closeLinkEditor();
            this.menuState.isOpen = true;
            this.menuState.position = { x, y: y + TOPBAR_HEIGHT };
            this.menuState.menuItems = registries$1[type]
                .getAll()
                .filter((item) => !item.isVisible || item.isVisible(this.env));
        }
        closeMenu() {
            this.menuState.isOpen = false;
            this.focus();
        }
    }
    Grid.template = TEMPLATE$2;
    Grid.style = CSS$2;
    Grid.components = {
        GridComposer,
        Overlay,
        Menu,
        Autofill,
        FiguresContainer,
        ClientTag,
        Highlight,
        ErrorToolTip,
        LinkDisplay,
        LinkEditor,
        Popover,
    };

    const { Component: Component$2 } = owl__namespace;
    const { xml: xml$2, css: css$2 } = owl__namespace.tags;
    const { useState: useState$2 } = owl__namespace.hooks;
    const TEMPLATE$1 = xml$2 /* xml */ `
  <div class="o-sidePanel" >
    <div class="o-sidePanelHeader">
        <div class="o-sidePanelTitle" t-esc="getTitle()"/>
        <div class="o-sidePanelClose" t-on-click="trigger('close-side-panel')">×</div>
    </div>
    <div class="o-sidePanelBody">
      <t t-component="state.panel.Body" t-props="props.panelProps" t-key="'Body_' + props.component"/>
    </div>
    <div class="o-sidePanelFooter" t-if="state.panel.Footer">
      <t t-component="state.panel.Footer" t-props="props.panelProps" t-key="'Footer_' + props.component"/>
    </div>
  </div>`;
    const CSS$1 = css$2 /* scss */ `
  .o-sidePanel {
    display: flex;
    flex-direction: column;
    overflow-x: hidden;
    background-color: white;
    border: 1px solid darkgray;
    .o-sidePanelHeader {
      padding: 6px;
      height: 30px;
      background-color: ${BACKGROUND_HEADER_COLOR};
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid darkgray;
      border-top: 1px solid darkgray;
      font-weight: bold;
      .o-sidePanelTitle {
        font-weight: bold;
        padding: 5px 10px;
        color: dimgrey;
      }
      .o-sidePanelClose {
        font-size: 1.5rem;
        padding: 5px 10px;
        cursor: pointer;
        &:hover {
          background-color: WhiteSmoke;
        }
      }
    }
    .o-sidePanelBody {
      overflow: auto;
      width: 100%;
      height: 100%;

      .o-section {
        padding: 16px;

        .o-section-title {
          font-weight: bold;
          color: dimgrey;
          margin-bottom: 5px;
        }
      }
    }

    .o-sidepanel-error {
      color: red;
      margin-top: 10px;
    }

    .o-sidePanelButtons {
      padding: 16px;
      text-align: right;
      .o-sidePanelButton {
        border: 1px solid lightgrey;
        padding: 0px 20px 0px 20px;
        border-radius: 4px;
        font-weight: 500;
        font-size: 14px;
        height: 30px;
        line-height: 16px;
        background: white;
        margin-right: 8px;
        &:hover:enabled {
          background-color: rgba(0, 0, 0, 0.08);
        }
      }
      .o-sidePanelButton:enabled {
        cursor: pointer;
      }
      .o-sidePanelButton:last-child {
        margin-right: 0px;
      }
    }
    .o-input {
      color: #666666;
      border-radius: 4px;
      min-width: 0px;
      padding: 4px 6px;
      box-sizing: border-box;
      line-height: 1;
      width: 100%;
      .o-type-selector {
        background-position: right 5px top 11px;
      }
    }
    input.o-required {
      border-color: #4c4c4c;
    }
    input.o-invalid {
      border-color: red;
    }
    select.o-input {
      background-color: white;
      text-align: left;
    }
  }
`;
    class SidePanel extends Component$2 {
        constructor() {
            super(...arguments);
            this.state = useState$2({
                panel: sidePanelRegistry.get(this.props.component),
            });
        }
        async willUpdateProps(nextProps) {
            this.state.panel = sidePanelRegistry.get(nextProps.component);
        }
        getTitle() {
            return typeof this.state.panel.title === "function"
                ? this.state.panel.title(this.env)
                : this.state.panel.title;
        }
    }
    SidePanel.template = TEMPLATE$1;
    SidePanel.style = CSS$1;

    const { Component: Component$1, useState: useState$1, hooks } = owl__namespace;
    const { xml: xml$1, css: css$1 } = owl__namespace.tags;
    const { useExternalListener: useExternalListener$1, useRef: useRef$1 } = hooks;
    const Terms = {
        Undo: _lt("Undo"),
        Redo: _lt("Redo"),
        PaintFormat: _lt("Paint Format"),
        ClearFormat: _lt("Clear Format"),
        FormatAsPercent: _lt("Format as percent"),
        DecreaseDecimalPlaces: _lt("Decrease decimal places"),
        IncreaseDecimalPlaces: _lt("Increase decimal places"),
        MoreFormats: _lt("More formats"),
        FontSize: _lt("Font Size"),
        Bold: _lt("Bold"),
        Italic: _lt("Italic"),
        Strikethrough: _lt("Strikethrough"),
        TextColor: _lt("Text Color"),
        FillColor: _lt("Fill Color"),
        Borders: _lt("Borders"),
        MergeCells: _lt("Merge Cells"),
        HorizontalAlign: _lt("Horizontal align"),
    };
    const FORMATS = [
        { name: "general", text: _lt("General (no specific format)") },
        { name: "number", text: _lt("Number (1,000.12)"), value: "#,##0.00" },
        { name: "percent", text: _lt("Percent (10.12%)"), value: "0.00%" },
        { name: "date", text: _lt("Date (9/26/2008)"), value: "m/d/yyyy" },
        { name: "time", text: _lt("Time (10:43:00 PM)"), value: "hh:mm:ss a" },
        { name: "datetime", text: _lt("Date time (9/26/2008 22:43:00)"), value: "m/d/yyyy hh:mm:ss" },
        { name: "duration", text: _lt("Duration (27:51:38)"), value: "hhhh:mm:ss" },
    ];
    // -----------------------------------------------------------------------------
    // TopBar
    // -----------------------------------------------------------------------------
    class TopBar extends Component$1 {
        constructor() {
            super(...arguments);
            this.formats = FORMATS;
            this.currentFormat = "general";
            this.fontSizes = fontSizes;
            this.dispatch = this.env.dispatch;
            this.getters = this.env.getters;
            this.style = {};
            this.state = useState$1({
                menuState: { isOpen: false, position: null, menuItems: [] },
                activeTool: "",
            });
            this.isSelectingMenu = false;
            this.openedEl = null;
            this.inMerge = false;
            this.cannotMerge = false;
            this.undoTool = false;
            this.redoTool = false;
            this.paintFormatTool = false;
            this.fillColor = "white";
            this.textColor = "black";
            this.menus = [];
            this.menuRef = useRef$1("menuRef");
            this.composerStyle = `
    line-height: 34px;
    padding-left: 8px;
    height: 34px;
    background-color: white;
  `;
            useExternalListener$1(window, "click", this.onClick);
        }
        get topbarComponents() {
            return topbarComponentRegistry
                .getAll()
                .filter((item) => !item.isVisible || item.isVisible(this.env));
        }
        async willStart() {
            this.updateCellState();
        }
        async willUpdateProps() {
            this.updateCellState();
        }
        onClick(ev) {
            if (this.openedEl && isChildEvent(this.openedEl, ev)) {
                return;
            }
            this.closeMenus();
        }
        toogleStyle(style) {
            setStyle(this.env, { [style]: !this.style[style] });
        }
        toogleFormat(format) {
            const formatter = FORMATS.find((f) => f.name === format);
            const value = (formatter && formatter.value) || "";
            setFormatter(this.env, value);
        }
        toggleAlign(align) {
            setStyle(this.env, { ["align"]: align });
        }
        onMenuMouseOver(menu, ev) {
            if (this.isSelectingMenu) {
                this.toggleContextMenu(menu, ev);
            }
        }
        toggleDropdownTool(tool, ev) {
            const isOpen = this.state.activeTool === tool;
            this.closeMenus();
            this.state.activeTool = isOpen ? "" : tool;
            this.openedEl = isOpen ? null : ev.target;
        }
        toggleContextMenu(menu, ev) {
            this.closeMenus();
            const x = ev.target.offsetLeft;
            const y = ev.target.clientHeight + ev.target.offsetTop;
            this.state.menuState.isOpen = true;
            this.state.menuState.position = { x, y };
            this.state.menuState.menuItems = topbarMenuRegistry
                .getChildren(menu, this.env)
                .filter((item) => !item.isVisible || item.isVisible(this.env));
            this.isSelectingMenu = true;
            this.openedEl = ev.target;
        }
        closeMenus() {
            this.state.activeTool = "";
            this.state.menuState.isOpen = false;
            this.isSelectingMenu = false;
            this.openedEl = null;
            if (this.menuRef.comp) {
                this.menuRef.comp.closeSubMenus();
            }
        }
        updateCellState() {
            this.style = this.getters.getCurrentStyle();
            this.fillColor = this.style.fillColor || "white";
            this.textColor = this.style.textColor || "black";
            const zones = this.getters.getSelectedZones();
            const { top, left, right, bottom } = zones[0];
            this.cannotMerge = zones.length > 1 || (top === bottom && left === right);
            this.inMerge = false;
            if (!this.cannotMerge) {
                const [col, row] = this.getters.getPosition();
                const zone = this.getters.expandZone(this.getters.getActiveSheetId(), {
                    left: col,
                    right: col,
                    top: row,
                    bottom: row,
                });
                this.inMerge = isEqual(zones[0], zone);
            }
            this.undoTool = this.getters.canUndo();
            this.redoTool = this.getters.canRedo();
            this.paintFormatTool = this.getters.isPaintingFormat();
            const cell = this.getters.getActiveCell();
            if (cell && cell.format) {
                const format = this.formats.find((f) => f.value === cell.format);
                this.currentFormat = format ? format.name : "";
            }
            else {
                this.currentFormat = "general";
            }
            this.menus = topbarMenuRegistry
                .getAll()
                .filter((item) => !item.isVisible || item.isVisible(this.env));
        }
        getMenuName(menu) {
            return topbarMenuRegistry.getName(menu, this.env);
        }
        toggleMerge() {
            const zones = this.getters.getSelectedZones();
            const target = [zones[zones.length - 1]];
            const sheet = this.getters.getActiveSheetId();
            if (this.inMerge) {
                this.dispatch("REMOVE_MERGE", { sheetId: sheet, target });
            }
            else {
                this.dispatch("ADD_MERGE", { sheetId: sheet, target, interactive: true });
            }
        }
        setColor(target, ev) {
            setStyle(this.env, { [target]: ev.detail.color });
        }
        setBorder(command) {
            this.dispatch("SET_FORMATTING", {
                sheetId: this.getters.getActiveSheetId(),
                target: this.getters.getSelectedZones(),
                border: command,
            });
        }
        setFormat(ev) {
            const format = ev.target.dataset.format;
            if (format) {
                this.toogleFormat(format);
            }
        }
        setDecimal(step) {
            this.dispatch("SET_DECIMAL", {
                sheetId: this.getters.getActiveSheetId(),
                target: this.getters.getSelectedZones(),
                step: step,
            });
        }
        paintFormat() {
            this.dispatch("ACTIVATE_PAINT_FORMAT", {
                target: this.getters.getSelectedZones(),
            });
        }
        clearFormatting() {
            this.dispatch("CLEAR_FORMATTING", {
                sheetId: this.getters.getActiveSheetId(),
                target: this.getters.getSelectedZones(),
            });
        }
        setSize(ev) {
            const fontSize = parseFloat(ev.target.dataset.size);
            setStyle(this.env, { fontSize });
        }
        doAction(action) {
            action(this.env);
            this.closeMenus();
        }
        undo() {
            this.dispatch("REQUEST_UNDO");
        }
        redo() {
            this.dispatch("REQUEST_REDO");
        }
    }
    TopBar.template = xml$1 /* xml */ `
    <div class="o-spreadsheet-topbar">
      <div class="o-topbar-top">
        <!-- Menus -->
        <div class="o-topbar-topleft">
          <t t-foreach="menus" t-as="menu" t-key="menu_index">
            <div t-if="menu.children.length !== 0"
              class="o-topbar-menu"
              t-on-click="toggleContextMenu(menu)"
              t-on-mouseover="onMenuMouseOver(menu)"
              t-att-data-id="menu.id">
            <t t-esc="getMenuName(menu)"/>
          </div>
          </t>
          <Menu t-if="state.menuState.isOpen"
                position="state.menuState.position"
                menuItems="state.menuState.menuItems"
                t-ref="menuRef"
                t-on-close="state.menuState.isOpen=false"/>
        </div>
        <div class="o-topbar-topright">
          <div t-foreach="topbarComponents" t-as="comp" t-key="comp_index">
            <t t-component="comp.component"/>
          </div>
        </div>
      </div>
      <!-- Toolbar and Cell Content -->
      <div class="o-topbar-toolbar">
        <!-- Toolbar -->
        <div t-if="getters.isReadonly()" class="o-readonly-toolbar text-muted">
          <span>
            <i class="fa fa-eye" /> <t t-esc="env._t('Readonly Access')" />
          </span>
        </div>
        <div t-else="" class="o-toolbar-tools">
          <div class="o-tool" title="${Terms.Undo}" t-att-class="{'o-disabled': !undoTool}" t-on-click="undo" >${UNDO_ICON}</div>
          <div class="o-tool" title="${Terms.Redo}" t-att-class="{'o-disabled': !redoTool}" t-on-click="redo">${REDO_ICON}</div>
          <div class="o-tool" title="${Terms.PaintFormat}" t-att-class="{active:paintFormatTool}" t-on-click="paintFormat">${PAINT_FORMAT_ICON}</div>
          <div class="o-tool" title="${Terms.ClearFormat}" t-on-click="clearFormatting()">${CLEAR_FORMAT_ICON}</div>
          <div class="o-divider"/>
          <div class="o-tool" title="${Terms.FormatAsPercent}" t-on-click="toogleFormat('percent')">%</div>
          <div class="o-tool" title="${Terms.DecreaseDecimalPlaces}" t-on-click="setDecimal(-1)">.0</div>
          <div class="o-tool" title="${Terms.IncreaseDecimalPlaces}" t-on-click="setDecimal(+1)">.00</div>
          <div class="o-tool o-dropdown" title="${Terms.MoreFormats}" t-on-click="toggleDropdownTool('formatTool')">
            <div class="o-text-icon">123${TRIANGLE_DOWN_ICON}</div>
            <div class="o-dropdown-content o-text-options  o-format-tool "  t-if="state.activeTool === 'formatTool'" t-on-click="setFormat">
              <t t-foreach="formats" t-as="format" t-key="format.name">
                <div t-att-data-format="format.name" t-att-class="{active: currentFormat === format.name}"><t t-esc="format.text"/></div>
              </t>
            </div>
          </div>
          <div class="o-divider"/>
          <!-- <div class="o-tool" title="Font"><span>Roboto</span> ${TRIANGLE_DOWN_ICON}</div> -->
          <div class="o-tool o-dropdown" title="${Terms.FontSize}" t-on-click="toggleDropdownTool('fontSizeTool')">
            <div class="o-text-icon"><t t-esc="style.fontSize || ${DEFAULT_FONT_SIZE}"/> ${TRIANGLE_DOWN_ICON}</div>
            <div class="o-dropdown-content o-text-options "  t-if="state.activeTool === 'fontSizeTool'" t-on-click="setSize">
              <t t-foreach="fontSizes" t-as="font" t-key="font_index">
                <div t-esc="font.pt" t-att-data-size="font.pt"/>
              </t>
            </div>
          </div>
          <div class="o-divider"/>
          <div class="o-tool" title="${Terms.Bold}" t-att-class="{active:style.bold}" t-on-click="toogleStyle('bold')">${BOLD_ICON}</div>
          <div class="o-tool" title="${Terms.Italic}" t-att-class="{active:style.italic}" t-on-click="toogleStyle('italic')">${ITALIC_ICON}</div>
          <div class="o-tool" title="${Terms.Strikethrough}"  t-att-class="{active:style.strikethrough}" t-on-click="toogleStyle('strikethrough')">${STRIKE_ICON}</div>
          <div class="o-tool o-dropdown o-with-color" title="${Terms.TextColor}" t-on-click="toggleDropdownTool('textColorTool')" >
            <span t-attf-style="border-color:{{textColor}}">${TEXT_COLOR_ICON}</span>
            <ColorPicker t-if="state.activeTool === 'textColorTool'" t-on-color-picked="setColor('textColor')" t-key="textColor"/>
          </div>
          <div class="o-divider"/>
          <div class="o-tool  o-dropdown o-with-color" title="${Terms.FillColor}" t-on-click="toggleDropdownTool('fillColorTool')">
            <span t-attf-style="border-color:{{fillColor}}">${FILL_COLOR_ICON}</span>
            <ColorPicker t-if="state.activeTool === 'fillColorTool'" t-on-color-picked="setColor('fillColor')" t-key="fillColor"/>
          </div>
          <div class="o-tool o-dropdown" t-on-click="toggleDropdownTool('borderTool')" title="${Terms.Borders}">
            <span>${BORDERS_ICON}</span>
            <div class="o-dropdown-content o-border" t-if="state.activeTool === 'borderTool'">
              <div class="o-dropdown-line">
                <span class="o-line-item" t-on-click="setBorder('all')">${BORDERS_ICON}</span>
                <span class="o-line-item" t-on-click="setBorder('hv')">${BORDER_HV}</span>
                <span class="o-line-item" t-on-click="setBorder('h')">${BORDER_H}</span>
                <span class="o-line-item" t-on-click="setBorder('v')">${BORDER_V}</span>
                <span class="o-line-item" t-on-click="setBorder('external')">${BORDER_EXTERNAL}</span>
              </div>
              <div class="o-dropdown-line">
                <span class="o-line-item" t-on-click="setBorder('left')">${BORDER_LEFT}</span>
                <span class="o-line-item" t-on-click="setBorder('top')">${BORDER_TOP}</span>
                <span class="o-line-item" t-on-click="setBorder('right')">${BORDER_RIGHT}</span>
                <span class="o-line-item" t-on-click="setBorder('bottom')">${BORDER_BOTTOM}</span>
                <span class="o-line-item" t-on-click="setBorder('clear')">${BORDER_CLEAR}</span>
              </div>
            </div>
          </div>
          <div class="o-tool" title="${Terms.MergeCells}"  t-att-class="{active:inMerge, 'o-disabled': cannotMerge}" t-on-click="toggleMerge">${MERGE_CELL_ICON}</div>
          <div class="o-divider"/>
          <div class="o-tool o-dropdown" title="${Terms.HorizontalAlign}" t-on-click="toggleDropdownTool('alignTool')">
            <span>
              <t t-if="style.align === 'right'">${ALIGN_RIGHT_ICON}</t>
              <t t-elif="style.align === 'center'">${ALIGN_CENTER_ICON}</t>
              <t t-else="">${ALIGN_LEFT_ICON}</t>
              ${TRIANGLE_DOWN_ICON}
            </span>
            <div t-if="state.activeTool === 'alignTool'" class="o-dropdown-content">
              <div class="o-dropdown-item" t-on-click="toggleAlign('left')">${ALIGN_LEFT_ICON}</div>
              <div class="o-dropdown-item" t-on-click="toggleAlign('center')">${ALIGN_CENTER_ICON}</div>
              <div class="o-dropdown-item" t-on-click="toggleAlign('right')">${ALIGN_RIGHT_ICON}</div>
            </div>
          </div>
          <!-- <div class="o-tool" title="Vertical align"><span>${ALIGN_MIDDLE_ICON}</span> ${TRIANGLE_DOWN_ICON}</div> -->
          <!-- <div class="o-tool" title="Text Wrapping">${TEXT_WRAPPING_ICON}</div> -->
        </div>
        <Composer inputStyle="composerStyle" focus="props.focusComposer"/>

      </div>
    </div>`;
    TopBar.style = css$1 /* scss */ `
    .o-spreadsheet-topbar {
      background-color: white;
      line-height: 1.2;
      display: flex;
      flex-direction: column;
      font-size: 13px;
      line-height: 1.2;
      user-select: none;

      .o-topbar-top {
        border-bottom: 1px solid #e0e2e4;
        display: flex;
        padding: 2px 10px;
        justify-content: space-between;

        /* Menus */
        .o-topbar-topleft {
          display: flex;
          .o-topbar-menu {
            padding: 4px 6px;
            margin: 0 2px;
            cursor: pointer;
          }

          .o-topbar-menu:hover {
            background-color: #f1f3f4;
            border-radius: 2px;
          }
        }

        .o-topbar-topright {
          display: flex;
          justify-content: flex-end;
        }
      }
      /* Toolbar + Cell Content */
      .o-topbar-toolbar {
        border-bottom: 1px solid #e0e2e4;
        display: flex;

        .o-readonly-toolbar {
          display: flex;
          align-items: center;
          background-color: ${BACKGROUND_HEADER_COLOR};
          padding-left: 18px;
          padding-right: 18px;
        }
        .o-composer-container {
          height: 34px;
          border: 1px solid #e0e2e4;
          margin-top: -1px;
          margin-bottom: -1px;
        }

        /* Toolbar */
        .o-toolbar-tools {
          display: flex;
          flex-shrink: 0;
          margin-left: 16px;
          color: #333;
          cursor: default;

          .o-tool {
            display: flex;
            align-items: center;
            margin: 2px;
            padding: 0 3px;
            border-radius: 2px;
            cursor: pointer;
            min-width: fit-content;
          }

          .o-tool.active,
          .o-tool:not(.o-disabled):hover {
            background-color: #f1f3f4;
          }

          .o-with-color > span {
            border-bottom: 4px solid;
            height: 16px;
            margin-top: 2px;
          }

          .o-with-color {
            .o-line-item:hover {
              outline: 1px solid gray;
            }
          }

          .o-border {
            .o-line-item {
              padding: 4px;
              margin: 1px;
            }
          }

          .o-divider {
            display: inline-block;
            border-right: 1px solid #e0e2e4;
            width: 0;
            margin: 0 6px;
          }

          .o-disabled {
            opacity: 0.6;
          }

          .o-dropdown {
            position: relative;

            .o-text-icon {
              height: 100%;
              line-height: 30px;
            }

            .o-text-options > div {
              line-height: 26px;
              padding: 3px 12px;
              &:hover {
                background-color: rgba(0, 0, 0, 0.08);
              }
            }

            .o-dropdown-content {
              position: absolute;
              top: calc(100% + 5px);
              left: 0;
              z-index: 10;
              box-shadow: 1px 2px 5px 2px rgba(51, 51, 51, 0.15);
              background-color: white;

              .o-dropdown-item {
                padding: 7px 10px;
              }

              .o-dropdown-item:hover {
                background-color: rgba(0, 0, 0, 0.08);
              }

              .o-dropdown-line {
                display: flex;
                padding: 3px 6px;

                .o-line-item {
                  width: 16px;
                  height: 16px;
                  margin: 1px 3px;

                  &:hover {
                    background-color: rgba(0, 0, 0, 0.08);
                  }
                }
              }

              &.o-format-tool {
                width: 180px;
                padding: 7px 0;
                > div {
                  padding-left: 25px;

                  &.active:before {
                    content: "✓";
                    font-weight: bold;
                    position: absolute;
                    left: 10px;
                  }
                }
              }
            }
          }
        }

        /* Cell Content */
        .o-toolbar-cell-content {
          font-size: 12px;
          font-weight: 500;
          padding: 0 12px;
          margin: 0;
          line-height: 34px;
          white-space: nowrap;
          user-select: text;
        }
      }
    }
  `;
    TopBar.components = { ColorPicker, Menu, Composer };

    const { Component, useState } = owl__namespace;
    const { useRef, useExternalListener } = owl__namespace.hooks;
    const { xml, css } = owl__namespace.tags;
    const { useSubEnv } = owl__namespace.hooks;
    // -----------------------------------------------------------------------------
    // SpreadSheet
    // -----------------------------------------------------------------------------
    const TEMPLATE = xml /* xml */ `
  <div class="o-spreadsheet" t-on-save-requested="save" t-on-keydown="onKeydown">
  <TopBar
  t-on-click="focusGrid"
  t-on-composer-content-focused="onTopBarComposerFocused"
  focusComposer="focusTopBarComposer"
  class="o-two-columns"/>
    <Grid
      model="model"
      sidePanelIsOpen="sidePanel.isOpen"
      linkEditorIsOpen="linkEditor.isOpen"
      t-on-link-editor-closed="closeLinkEditor"
      t-ref="grid"
      focusComposer="focusGridComposer"
      t-on-composer-content-focused="onGridComposerContentFocused"
      t-on-composer-cell-focused="onGridComposerCellFocused"
      t-att-class="{'o-two-columns': !sidePanel.isOpen}"/>
    <SidePanel t-if="sidePanel.isOpen"
           t-on-close-side-panel="closeSidePanel"
           component="sidePanel.component"
           panelProps="sidePanel.panelProps"/>
    <BottomBar t-on-click="focusGrid" class="o-two-columns"/>
  </div>`;
    const CSS = css /* scss */ `
  .o-spreadsheet {
    position: relative;
    display: grid;
    grid-template-rows: ${TOPBAR_HEIGHT}px auto ${BOTTOMBAR_HEIGHT + 1}px;
    grid-template-columns: auto 350px;
    * {
      font-family: "Roboto", "RobotoDraft", Helvetica, Arial, sans-serif;
    }
    &,
    *,
    *:before,
    *:after {
      box-sizing: content-box;
    }
  }

  .o-two-columns {
    grid-column: 1 / 3;
  }

  .o-icon {
    width: ${ICON_EDGE_LENGTH}px;
    height: ${ICON_EDGE_LENGTH}px;
    opacity: 0.6;
    vertical-align: middle;
  }

  .o-cf-icon {
    width: ${CF_ICON_EDGE_LENGTH}px;
    height: ${CF_ICON_EDGE_LENGTH}px;
    vertical-align: sub;
  }
`;
    const t = (s) => s;
    class Spreadsheet extends Component {
        constructor(parent, props = {}) {
            super(parent, props);
            this.model = new Model(this.props.data, {
                notifyUser: (content) => this.trigger("notify-user", { content }),
                askConfirmation: (content, confirm, cancel) => this.trigger("ask-confirmation", { content, confirm, cancel }),
                editText: (title, placeholder, callback) => this.trigger("edit-text", { title, placeholder, callback }),
                openSidePanel: (panel, panelProps = {}) => this.openSidePanel(panel, panelProps),
                evalContext: { env: this.env },
                transportService: this.props.transportService,
                client: this.props.client,
                isReadonly: this.props.isReadonly,
                snapshotRequested: this.props.snapshotRequested,
            }, this.props.stateUpdateMessages);
            this.grid = useRef("grid");
            this.sidePanel = useState({ isOpen: false, panelProps: {} });
            this.linkEditor = useState({ isOpen: false });
            this.composer = useState({
                topBarFocus: "inactive",
                gridFocusMode: "inactive",
            });
            // last string that was cut or copied. It is necessary so we can make the
            // difference between a paste coming from the sheet itself, or from the
            // os clipboard
            this.clipBoardString = "";
            this.keyDownMapping = {
                "CTRL+H": () => this.toggleSidePanel("FindAndReplace", {}),
                "CTRL+F": () => this.toggleSidePanel("FindAndReplace", {}),
            };
            useSubEnv({
                openSidePanel: (panel, panelProps = {}) => this.openSidePanel(panel, panelProps),
                toggleSidePanel: (panel, panelProps = {}) => this.toggleSidePanel(panel, panelProps),
                dispatch: this.model.dispatch,
                getters: this.model.getters,
                uuidGenerator: this.model.uuidGenerator,
                _t: Spreadsheet._t,
                clipboard: navigator.clipboard,
                export: this.model.exportData.bind(this.model),
                waitForIdle: this.model.waitForIdle.bind(this.model),
                exportXLSX: this.model.exportXLSX.bind(this.model),
                openLinkEditor: () => this.openLinkEditor(),
            });
            useExternalListener(window, "resize", this.render);
            useExternalListener(document.body, "cut", this.copy.bind(this, true));
            useExternalListener(document.body, "copy", this.copy.bind(this, false));
            useExternalListener(document.body, "paste", this.paste);
            useExternalListener(document.body, "keyup", this.onKeyup.bind(this));
            useExternalListener(window, "beforeunload", this.leaveCollaborativeSession.bind(this));
            this.activateFirstSheet();
        }
        get focusTopBarComposer() {
            return this.model.getters.getEditionMode() === "inactive"
                ? "inactive"
                : this.composer.topBarFocus;
        }
        get focusGridComposer() {
            return this.model.getters.getEditionMode() === "inactive"
                ? "inactive"
                : this.composer.gridFocusMode;
        }
        mounted() {
            this.model.on("update", this, this.render);
            this.model.on("unexpected-revision-id", this, () => this.trigger("unexpected-revision-id"));
            if (this.props.client) {
                this.model.joinSession(this.props.client);
            }
        }
        willUnmount() {
            this.leaveCollaborativeSession();
        }
        async willUpdateProps(nextProps) {
            if (this.props.isReadonly !== nextProps.isReadonly) {
                this.model.updateReadOnly(nextProps.isReadonly);
            }
        }
        leaveCollaborativeSession() {
            this.model.off("update", this);
            this.model.leaveSession();
        }
        activateFirstSheet() {
            const sheetId = this.model.getters.getActiveSheetId();
            const [firstSheet] = this.model.getters.getSheets();
            if (firstSheet.id !== sheetId) {
                this.model.dispatch("ACTIVATE_SHEET", { sheetIdFrom: sheetId, sheetIdTo: firstSheet.id });
            }
        }
        destroy() {
            this.model.destroy();
            super.destroy();
        }
        openSidePanel(panel, panelProps) {
            this.sidePanel.component = panel;
            this.sidePanel.panelProps = panelProps;
            this.sidePanel.isOpen = true;
        }
        closeSidePanel() {
            this.sidePanel.isOpen = false;
            this.focusGrid();
        }
        openLinkEditor() {
            this.linkEditor.isOpen = true;
        }
        closeLinkEditor() {
            this.linkEditor.isOpen = false;
            this.focusGrid();
        }
        toggleSidePanel(panel, panelProps) {
            if (this.sidePanel.isOpen && panel === this.sidePanel.component) {
                this.sidePanel.isOpen = false;
                this.focusGrid();
            }
            else {
                this.openSidePanel(panel, panelProps);
            }
        }
        focusGrid() {
            this.grid.comp.focus();
        }
        copy(cut, ev) {
            if (!this.grid.el.contains(document.activeElement)) {
                return;
            }
            /* If we are currently editing a cell, let the default behavior */
            if (this.model.getters.getEditionMode() !== "inactive") {
                return;
            }
            const type = cut ? "CUT" : "COPY";
            const target = this.model.getters.getSelectedZones();
            this.model.dispatch(type, { target });
            const content = this.model.getters.getClipboardContent();
            this.clipBoardString = content;
            ev.clipboardData.setData("text/plain", content);
            ev.preventDefault();
        }
        paste(ev) {
            if (!this.grid.el.contains(document.activeElement)) {
                return;
            }
            const clipboardData = ev.clipboardData;
            if (clipboardData.types.indexOf("text/plain") > -1) {
                const content = clipboardData.getData("text/plain");
                const target = this.model.getters.getSelectedZones();
                if (this.clipBoardString === content) {
                    // the paste actually comes from o-spreadsheet itself
                    this.model.dispatch("PASTE", { target, interactive: true });
                }
                else {
                    this.model.dispatch("PASTE_FROM_OS_CLIPBOARD", {
                        target,
                        text: content,
                    });
                }
            }
        }
        save() {
            this.trigger("save-content", {
                data: this.model.exportData(),
            });
        }
        onKeyup(ev) {
            if (ev.key === "Control" && this.model.getters.getSelectionMode() !== SelectionMode.expanding) {
                this.model.dispatch("STOP_SELECTION");
            }
        }
        onKeydown(ev) {
            if (ev.key === "Control" && !ev.repeat) {
                this.model.dispatch(this.model.getters.getSelectionMode() === SelectionMode.idle
                    ? "PREPARE_SELECTION_EXPANSION"
                    : "START_SELECTION_EXPANSION");
            }
            let keyDownString = "";
            if (ev.ctrlKey || ev.metaKey) {
                keyDownString += "CTRL+";
            }
            keyDownString += ev.key.toUpperCase();
            let handler = this.keyDownMapping[keyDownString];
            if (handler) {
                ev.preventDefault();
                ev.stopPropagation();
                handler();
                return;
            }
        }
        onTopBarComposerFocused(ev) {
            if (this.model.getters.isReadonly()) {
                return;
            }
            this.composer.topBarFocus = "contentFocus";
            this.composer.gridFocusMode = "inactive";
            this.setComposerContent(ev.detail || {});
            this.env.dispatch("UNFOCUS_SELECTION_INPUT");
        }
        onGridComposerContentFocused(ev) {
            if (this.model.getters.isReadonly()) {
                return;
            }
            this.composer.topBarFocus = "inactive";
            this.composer.gridFocusMode = "contentFocus";
            this.setComposerContent(ev.detail || {});
            this.env.dispatch("UNFOCUS_SELECTION_INPUT");
        }
        onGridComposerCellFocused(ev) {
            if (this.model.getters.isReadonly()) {
                return;
            }
            this.composer.topBarFocus = "inactive";
            this.composer.gridFocusMode = "cellFocus";
            this.setComposerContent(ev.detail || {});
            this.env.dispatch("UNFOCUS_SELECTION_INPUT");
        }
        /**
         * Start the edition or update the content if it's already started.
         */
        setComposerContent({ content, selection, }) {
            if (this.model.getters.getEditionMode() === "inactive") {
                this.model.dispatch("START_EDITION", { text: content, selection });
            }
            else if (content) {
                this.model.dispatch("SET_CURRENT_CONTENT", { content, selection });
            }
        }
    }
    Spreadsheet.template = TEMPLATE;
    Spreadsheet.style = CSS;
    Spreadsheet.components = { TopBar, Grid, BottomBar, SidePanel, LinkEditor };
    Spreadsheet._t = t;

    /**
     * We export here all entities that needs to be accessed publicly by Odoo.
     *
     * Note that the __info__ key is actually completed by the build process (see
     * the rollup.config.js file)
     */
    const __info__ = {};
    const SPREADSHEET_DIMENSIONS = {
        MIN_ROW_HEIGHT,
        MIN_COL_WIDTH,
        HEADER_HEIGHT,
        HEADER_WIDTH,
        TOPBAR_HEIGHT,
        BOTTOMBAR_HEIGHT,
        DEFAULT_CELL_WIDTH,
        DEFAULT_CELL_HEIGHT,
        SCROLLBAR_WIDTH: SCROLLBAR_WIDTH$1,
    };
    const registries = {
        autofillModifiersRegistry,
        autofillRulesRegistry,
        cellMenuRegistry,
        colMenuRegistry,
        linkMenuRegistry,
        functionRegistry,
        uiPluginRegistry,
        corePluginRegistry,
        rowMenuRegistry,
        sidePanelRegistry,
        sheetMenuRegistry,
        topbarMenuRegistry,
        topbarComponentRegistry,
        otRegistry,
        inverseCommandRegistry,
        cellRegistry,
    };
    const cellTypes = {
        LinkCell,
    };
    const helpers = {
        args,
        toBoolean,
        toNumber,
        toString,
        toXC,
        toZone,
        toCartesian,
        numberToLetters,
        createFullMenuItem,
        UuidGenerator,
        formatDecimal,
        computeTextWidth,
        isMarkdownLink,
        parseMarkdownLink,
        markdownLink,
        createEmptyWorkbookData,
    };

    exports.CorePlugin = CorePlugin;
    exports.DATETIME_FORMAT = DATETIME_FORMAT;
    exports.DataSource = DataSource;
    exports.DispatchResult = DispatchResult;
    exports.Model = Model;
    exports.Revision = Revision;
    exports.SPREADSHEET_DIMENSIONS = SPREADSHEET_DIMENSIONS;
    exports.Spreadsheet = Spreadsheet;
    exports.UIPlugin = UIPlugin;
    exports.__DEBUG__ = DEBUG;
    exports.__info__ = __info__;
    exports.astToFormula = astToFormula;
    exports.cellTypes = cellTypes;
    exports.convertAstNodes = convertAstNodes;
    exports.coreTypes = coreTypes;
    exports.functionCache = functionCache;
    exports.helpers = helpers;
    exports.invalidateEvaluationCommands = invalidateEvaluationCommands;
    exports.normalize = normalize;
    exports.parse = parse;
    exports.readonlyAllowedCommands = readonlyAllowedCommands;
    exports.registries = registries;
    exports.setTranslationMethod = setTranslationMethod;

    Object.defineProperty(exports, '__esModule', { value: true });

    exports.__info__.version = '2.0.0';
    exports.__info__.date = '2022-09-28T11:16:36.108Z';
    exports.__info__.hash = '10e9873';

})(this.o_spreadsheet = this.o_spreadsheet || {}, owl);
//# sourceMappingURL=o_spreadsheet.js.map
